var store = [{
        "title": "Mac에서 github blog 만들기 - 1",
        "excerpt":"개발자 블로그 ???   요즘 개발자들은 취업, 포트폴리오, TIL(Today I Learned) 등 각자의 이유로 블로그를 운영하고 있습니다. 저도 부트캠프를 계기로 개발자 블로그를 운영해보기로 하였습니다.   네이버 블로그, 티스토리, 벨로그, 깃허브 블로그 등 다양한 플랫폼 중 깃허브 블로그를 선택하였습니다. (벨로그에 테스트로 글 두번 썼는데 제 마음에 들지 않았습니다.)   GitHub 블로그 선택 이유  GitHub 블로그 장점은 찾아보니 3가지 정도로 구분할 수 있는 것 같습니다.          마음대로 꾸밀 수 있다.   블로그의 테마나 레이아웃부터 폰트, 컬러 등 본인의 취향껏 변경할 수 있습니다. 뿐만 아니라 다양한 기능도 추가할 수 있습니다.            GitHub 연동  GitHub 블로그를 잘 가꾸는 것도 하나의 좋은 포트폴리오가 될 수 있습니다.            광고 추가  블로그에 Google AdSense를 링크하여 광고 수익을 기대할 수 있습니다.       저는 GitHub 사용 경험이 없어 Git, GitHub와 친해지기 위해 GitHub 블로그를 선택하였습니다.   GitHub 블로그 만들기 시작  1. 깃 설치하기  블로그를 작성하게될 줄 모르고 설치 방법은 준비하지 못했으나 구글 검색을 통하여 충분히 설치하실 수 있으실겁니다.   Git Download 바로가기   2. 깃허브 회원가입  GitHub Homepage 바로가기   3. 깃허브 Repository 생성  왼쪽 Top Repositories에서 New 버튼을 선택합니다.  Repositories name은 꼭 “GitHub계정명.github.io”로 지정해야 합니다. GitHub Pages의 규칙 중 하나이며, 이 형식을 따르지 않으면 GitHub가 해당 저장소를 정적 사이트로 호스팅하지 않습니다.    4. Git clone 하기  만들어진 Repository는 블로그를 만드는데 필요한 코드가 관리되는 곳입니다. Repository 생성 시 README.md 파일만 생성하여 저장소에 README.md 파일만 있습니다.   로컬PC에서 블로그를 작성하고 GitHub 저장소에 등록하여 블로그를 작성하게 됩니다.   그전에 저장소에 있는 README.md 파일을 로컬PC로 복사하도록 하겠습니다. 깃허브 Repository에 있는 파일을 내 로컬PC로 복사하는 작업을 clone이라고 합니다.   로컬PC에서 GitHub 블로그를 작성할 폴더를 만듭니다.  저는 바탕화면에 githubBlog 폴더를 만들었습니다.     만들어진 폴더를 우클릭하여 폴더에서 새로운 터미널 열기를 실행합니다.    명령어로 git 폴더를 만들고 git 경로로 이동합니다. git 경로에서 repository에 있는 파일을 내PC로 복사하기 위해 git clone 깃주소를 입력합니다. 깃 주소는 아래 사진에서 확인하실 수 있습니다.      git clone 명령어를 통하여 README.md 파일이 로컬PC에 복사된 것을 확인할 수 있습니다.     5. 로컬PC에 새로운 파일 만들고 Git Repository에 등록해보기  Visual Studio Code 프로그램으로 GitHub.io 폴더를 열고 index.html 파일을 생성합니다.  캡쳐는 HelloWorld.html로 만들었지만 index.html로 만드시면 저장소에 등록 후 페이지를 확인 할 수 있습니다. (https://깃허브ID.github.io/index.html)       변경사항 저장  새로 만든 html 파일을 저장하고 변경된 모든 내용을 저장하기위해 git add . 명령어를 입력합니다.     imhs@imhsui-MacBookPro limlogging.github.io % git add .            변경사항 확정  git commit -m “변경사항 입력” commit은 변경사항을 확정하는 것으로 변경사항에 대한 커멘트를 남겨(-m \"메시지\") 나중에 무엇때문에 변경사항이 발생했는지 보기 쉽게 해줍니다.     imhs@imhsui-MacBookPro limlogging.github.io % git commit -m \"파일 추가\"            GitHub 저장소에 업로드  git push 명령어를 통해 저장소에 업로드 합니다.     imhs@imhsui-MacBookPro limlogging.github.io % git push            commit, push 시 에러 관련  Warning 저는 git을 꽤 오래전에 설치하여 방치된 상태였습니다. 때문에 이메일 설정을 변경해야했고 깃허브 key 에러가 발생하였습니다.  같은 에러가 발생하신다면 제가 본 블로그를 공유드릴테니 참고해보시기 바랍니다.   git commit 후 author, email을 수정하는 방법  git@github.com: Permission denied (publickey) 에러 해결 방법   GitHub Repository 파일 업로드 확인  GitHub 저장소에도 html 파일이 추가된 것을 확인 할 수 있습니다.   이후 Ruby, Jekyll, bundler 설치, 테마를 다운로드 받아 로컬환경에서 실행하고 Repository에 등록이 필요한데 다음 포스팅에 작성해보도록 하겠습니다.  ","categories": ["GitHubBlog"],
        "tags": ["GitHub","blog","GitHub blog"],
        "url": "/GitHubBlog/start1/",
        "teaser": null
      },{
        "title": "[내배캠] 온보딩 주차 프로젝트 만들기",
        "excerpt":"프로젝트     프로젝트 주제: 팀 소개 앱 만들기   프로젝트 기간: 2/26(월) ~ 2/29(목)   인원: 4명 (팀장: 김건응 / 팀원: 박중권, 서수영, 임형섭)   주요 기능: 팀원명 선택 시 해당 팀원 정보 확인 가능       프로젝트 진행 프로세스     사다리 타기를 통해 팀장 선정   네이버 사다리를 통해 김건응님 팀장 선정   개발 전 프로그램 디자인 하기  종이에 그리기, figma 웹, 스토리보드에 그리기 등   다수결에 의한 디자인 선정  figma로 작성하신 김건응 팀장님 디자인으로 진행하기로 하였습니다.     선출된 디자인을 각자 구현 (매일 저녁 진행 단계 확인)   다수결에 의한 결과물 선정       역할 분담  김건응     스토리보드 기반 컬렉션뷰를 사용한 하단 바를 구현하려 했고, 각 팀원의 이름과 사진을 버튼으로 만들어 클릭 시 해당 프로필과 소개가 나오는 기능을 구현하려 하였습니다.    박중권     Button (홈, 김건응, 임형섭, 서수영, 박중권, More) Button을 눌렀을 때, 홈은 홈 화면으로, 맴버들 이름을 눌렀을 땐 각 맴버의 소개 페이지로 이동할 수 있는 버튼을 만들었습니다.    UIView 음영 기본 UIView가 View와 배경색이 같은 경우, 경계를 알 수 있게 음영을 추가해서 이펙트를 넣었습니다.    원형 Button  스토리보드를 통해서 Button의 모양을 바꾸는데 있어서 제한적인 부분이 많아, 구글링을 한 후 Button의 모양을 코드를 사용해 변경했습니다.  버튼을 둥글게 하기 위해     self.RoundButton1.layer.masksToBounds = true  self.RoundButton1.layer.masksToBounds = self.RoundButton1.frame.size.width / 2           코드를 사용하여 아래와 같이 구현하였습니다.         Image 추가 Asset에 Image를 추가 후, 삽입.   서수영     코드베이스로 컬렉션 뷰 구현, 스택 뷰 레이아웃 설정, 컬렉션 뷰 터치 이벤트를 구현하려고 하였습니다.     임형섭     xcode에 포함된 스포이드를 사용하여 선정된 디자인과 동일한 색상 및 디자인을 구현하였습니다.     팀원들의 제안을 받아 Scroll View, Table View를 추가하였습니다.     다양한 기능보다 우선 완성할 수 있도록 진행하였습니다.       어려웠던 점     실제로 그린 디자인을 구현하려면 어떤 button, controller 등을 사용해야하는지 몰라 어려웠습니다.       해결한 내용     Scroll View에서 inspectors에서 추가적인 설정을 통한 Scroll 기능 구현   button 5개의 이벤트를 1개의 함수로 구현하였습니다.   구조체를 사용하여 팀원 정보 인스턴스를 생성하였습니다.   Table View, Table View Cell 사용 시 필수로 사용해야하는 함수를 확인하여 구현하였습니다.       해결하지 못한 내용  TableView에서 데이터를 표출하고 다음 view로 이동하는것에 어려움이 있었습니다.  Tab Bar, Navigation Controller는 사용하지 못했습니다.       최종 결과물             느낀 점  짧은 기간이지만 기본적인 Button, Lable 사용, 사진 넣기, 단축키 등 조금 익숙해 질 수 있었습니다.  또한 실제 디자인과 구현은 차이가 있다는 걸 알았습니다.  ","categories": ["sparta"],
        "tags": ["mini Project"],
        "url": "/sparta/onBoardingProject/",
        "teaser": null
      },{
        "title": "Mac에서 github blog 만들기 - 2",
        "excerpt":"1편에 이어 Ruby, Jekyll, bundler 설치, 테마를 다운로드 받아 로컬환경에서 실행하는 방법입니다.   1. Homebrew 설치  Homebrew는 macOS 및 Linux 운영 체제를 위한 오픈 소스 패키지 관리자입니다. 이를 통해 사용자는 명령줄 인터페이스를 통해 손쉽게 소프트웨어를 설치, 업데이트, 관리할 수 있습니다. 일반적으로 Homebrew를 사용하면 다음과 같은 작업을 수행할 수 있습니다.   Homebrew Homepage 바로가기   2. Homebrew Update  brew update 명령어를 통해 Homebrew 패키지 관리자의 패키지 목록을 최신 상태로 업데이트합니다.  imhs@imhsui-MacBookPro ~ % brew update  Homebrew를 사용하여 패키지를 설치하기 전에 항상 이 명령을 실행하여 최신 버전의 패키지 목록을 가져와야 합니다. 이를 통해 최신 버전의 패키지를 사용할 수 있고, 패키지 관련 문제를 방지할 수 있습니다.   3. Ruby 버전관리도구 및 build 설치  brew install rbenv ruby-build 명령으로 rbenv와 ruby-build라는 두 가지 패키지를 Homebrew를 통해 설치합니다.  imhs@imhsui-MacBookPro ~ % brew install rbenv ruby-build     rbenv는 Ruby 버전 관리 도구로, 여러 버전의 Ruby를 시스템에 설치하고 각 프로젝트에 필요한 버전을 선택할 수 있게 해줍니다. 이를 통해 서로 다른 프로젝트에서 다른 Ruby 버전을 사용할 수 있습니다.   ruby-build는 Ruby 버전을 컴파일하고 설치하는 데 사용되는 스크립트입니다. rbenv와 함께 사용되어 rbenv로 관리되는 Ruby 버전을 설치할 수 있도록 돕습니다. 이 명령을 사용하여 rbenv와 ruby-build를 설치하면 Ruby 개발 환경을 설정하는 데 필요한 도구를 간편하게 설치할 수 있습니다.   4. rbenv 설치 및 환경 설정  rbenv versions 명령어로 설치된 버전을 확인합니다.  imhs@imhsui-MacBookPro ~ % rbenv versions system  system이라고 표시되는 경우, 이는 현재 시스템에 기본적으로 설치된 Ruby 버전을 나타냅니다.   rbenv install -l 명령어를 통하여 설치할 수 있는 Ruby 버전 목록을 확인합니다.  imhs@imhsui-MacBookPro ~ % rbenv install -l 3.0.6 3.1.4 3.2.3 3.3.0 jruby-9.4.6.0 mruby-3.3.0 picoruby-3.0.0 truffleruby-23.1.2 truffleruby+graalvm-23.1.2  Only latest stable releases for each Ruby implementation are shown. Use 'rbenv install --list-all' to show all local versions.  저는 최신버전인 3.3.0 버전을 설치하였습니다.  imhs@imhsui-MacBookPro ~ % rbenv install 3.3.0  다시 rbenv version을 확인해봅니다.  imhs@imhsui-MacBookPro ~ % rbenv versions * system   3.3.0  * 표시는 현재 활성화(선택된) Ruby 버전을 나타냅니다.  설치된 버전으로 변경하기 위해 아래 명령어를 입력합니다.  imhs@imhsui-MacBookPro ~ % rbenv global 3.3.0 imhs@imhsui-MacBookPro ~ % rbenv versions   system * 3.3.0 (set by /Users/imhs/. rbenv/version)  terminal 콘솔 창 상단에 zsh 셸을 확인하고 zsh 셸 환경을 설정합니다.  imhs@imhsui-MacBookPro ~ % vim ~/.zshrc  파일에 아래 내용을 추가합니다.  [[ -d ~/.rbenv  ]] &amp;&amp; \\   export PATH=${HOME}/.rbenv/bin:${PATH} &amp;&amp; \\   eval \"$(rbenv init -)\"   수정된 내용을 적용하기 위하여 아래 명령어를 입력합니다.  imhs@imhsui-MacBookPro ~ % source ~/.zshrc   아래 명령어를 통하여 시스템에 Bundler를 설치하여 Ruby 프로젝트의 의존성을 관리할 수 있도록 합니다.  imhs@imhsui-MacBookPro ~ % gem install bundler     gem: RubyGems는 Ruby 패키지 관리자입니다. RubyGems를 사용하면 Ruby 프로그래밍 언어로 작성된 소프트웨어 패키지를 설치, 관리 및 배포할 수 있습니다. gem 명령어는 RubyGems의 명령줄 인터페이스를 제공하며, 패키지의 설치, 업데이트, 삭제 등 다양한 작업을 수행할 수 있습니다.   install: gem install은 RubyGems를 사용하여 패키지를 시스템에 설치하는 명령어입니다. 이를 통해 지정된 패키지를 로컬 시스템에 다운로드하고 설치할 수 있습니다.   bundler: Bundler는 Ruby 프로젝트의 의존성을 관리하는 도구입니다. Bundler를 사용하면 프로젝트에 필요한 라이브러리 및 gem을 쉽게 관리할 수 있습니다.   5. Jekyll과 Bundler를 시스템에 설치  아래 명령어를 사용하여 Jekyll과 Bundler를 시스템에 설치합니다.  imhs@imhsui-MacBookPro ~ % gem install jekyll bundler  jekyll 버전을 확인합니다.  imhs@imhsui-MacBookPro ~ % jekyll -v jekyll 4.3.3   6. jekyll 테마 다운로드 및 github repository에 반영  GitHub Pages에서 지원하는 인기있는 jekyll 테마 중 Minimal Mistakes를 다운로드 합니다.   minimal-mistakes Download 바로가기    다운로드 받은 파일을 git clone을 통하여 복사한 README.md 파일이 있는 폴더에 덮어씁니다.     복사한 폴더에서 터미널 창을 열어 깃허브 저장소로 업로드 합니다.  imhs@imhsui-MacBookPro limlogging.github.io % git add. imhs@imhsui-MacBookPro limlogging.github.io % git commit -m \"테마 업로드\" imhs@imhsui-MacBookPro limlogging.github.io % git push   7. blog에 접속해 확인합니다.  https://깃허브ID.github.io에 접속하면, 테마가 적용된 블로그를 확인할 수 있습니다. 적용까지 1 ~ 2분 걸리는 것 같습니다.  ","categories": ["GitHubBlog"],
        "tags": ["GitHub","blog","GitHub blog"],
        "url": "/GitHubBlog/start2/",
        "teaser": null
      },{
        "title": "[minimal-mistakes]카테고리 옆 posting Count 추가하기",
        "excerpt":"Posting Count 추가하기  우여곡절 끝에 카테고리를 만들고 TEST 게시물을 작성하였는데요. 뭔가 허전해보여 생각했더니 Posting Count가 없었습니다.   1. navigation.yml 수정하기  children 하위에 category 항목을 추가합니다.  categories:   - title: \"iOS\"         children:        - title: \"Swift\"         url: /categories/swift/                category: \"Swift\"       - title: \"SwiftUI\"         url: /categories/swiftui/          category: \"SwiftUI\"   - title: \"git\"      children:       - title: \"Git\"         url: /categories/git/         category: \"git\"       - title: \"GitHub Blog\"         url: /categories/GitHubBlog/         category: \"GitHubBlog\"   - title: \"etc\"     children:       - title: \"내배캠 부트캠프\"         url: /categories/sparta/         category: \"sparta\"   2. nav_list 수정  아래 부분 코드를 주석하고   &lt;li&gt;&lt;a href=\"{{ child.url | relative_url }}\"{% if child.url == page.url %} class=\"active\"{% endif %}&gt;{{ child.title }}&lt;/a&gt;&lt;/li&gt;    새로 코드를 추가합니다.   {% assign post_cnt = 0 %} {% for category in site.categories %}     {% if category[0] == child.category  %}     {% assign post_cnt = category[1].size %}     {% endif %} {% endfor %} &lt;li&gt;&lt;a href=\"{{ child.url | relative_url }}\"{% if child.url == page.url %} class=\"active\"{% endif %}&gt;{{ child.title }}({{ post_cnt }})&lt;/a&gt;&lt;/li&gt;    수정된 코드입니다.     3. 결과 확인  카테고리 옆에 해당 카테고리의 전체 포스팅 수를 확인할 수 있습니다.     ","categories": ["GitHubBlog"],
        "tags": ["GitHub","blog","GitHub blog","Posting Count"],
        "url": "/GitHubBlog/postingCount/",
        "teaser": null
      },{
        "title": "[내배캠] 온보딩 주차 프로젝트 만들기 / KPT 회고 ",
        "excerpt":"온보딩 프로젝트 KPT 회고  온보딩 프로젝트 발표가 끝났습니다.   팀원들과 프로젝트를 통해 느낀 “Keep (계속할 것)”, “Problem (문제)”, “Try (시도할 것)”의 세 가지 요소를 토대로 프로젝트의 경험을 돌아보고 이야기를 나누었습니다.           Keep: 앱을 구현하는데 있어 필요한 기능을 검색하고 최선의 방법을 찾아 사용하려고 하였습니다.            Problem: 처음 프로젝트를 진행 함에 있어 필요한 요소, 기능에 대한 막연함이 있었습니다. 다양한 실습을 통해 막연함을 구체화 시키도록 해야합니다.            Try: 조금 더 소통해야 할 것 같습니다. 시간을 정하고 소통하였으나 유연하게 소통하고 의사결정을 해야합니다.       이번 프로젝트를 돌아보고 다음 프로젝트에서 발전된 방향으로 프로젝트를 진행하도록 하겠습니다.   ","categories": ["sparta"],
        "tags": ["KPT 회고"],
        "url": "/sparta/onBoardingProjectKPT/",
        "teaser": null
      },{
        "title": "[minimal-mistakes]GitHub utterances 댓글 기능 추가하기 ",
        "excerpt":"utteranc.es는 GitHub의 Issue를 기반으로 한 댓글 시스템입니다. GitHub 저장소의 Issue에 댓글을 추가하여 웹사이트나 블로그 등에 댓글 시스템을 쉽게 추가할 수 있습니다. 이를 통해 사용자는 GitHub 계정을 통해 댓글을 작성하고 관리할 수 있습니다. Utterances는 정적 웹사이트를 호스팅하는 데 매우 인기가 있으며, GitHub Issue를 사용하여 댓글을 저장하므로 데이터 손실없이 무료로 사용할 수 있습니다.   1. utterances 설치하기  https://github.com/apps/utterances에 접속하셔서 Install합니다.     깃허브 저장소를 선택하고 Instal합니다.    2. 저장소 / 맵핑 설정     repo에 소유자/저장소이름을 입력합니다.   Issue title contains page pathname을 선택합니다.     3. 테마 설정하기     원하는 테마를 선택합니다.   Enable Utterance에 설정된 정보를 _config.yml에 복사해야하기때문에 복사해놓습니다.     4. _config.yml 설정하기     3번 Enable Utterance에서 확인한 repo 정보를 repository 항모에 넣습니다.     provider에 “utterances” 입력합니다.   3번 Enable Utterance에서 확인한 theme 정보를 theme 항목에 넣습니다.   3번 Enable Utterance에서 확인한 issue-term 정보를 issue-term 항목에 넣습니다.     5. 블로그 포스팅 시 comments: true 추가  --- title: \"GitHub utterances 댓글 기능 추가하기 (minimal-mistakes)\" excerpt: \"게시글에 utterances 댓글 기능 추가하는 방법입니다.\" categories: GitHubBlog tags: [GitHub, blog, GitHub blog, utterances, Comments]  permalink: /GitHubBlog/comments/  toc: true           toc_sticky: true     comments: true      #댓글 ---    6. 깃허브 Push  적용된 모습을 확인할 수 있습니다. (로컬에서 실행하면 추가된 내용이 보이지 않는 것 같습니다.)   ","categories": ["GitHubBlog"],
        "tags": ["GitHub","blog","GitHub blog","utterances","Comments"],
        "url": "/GitHubBlog/comments/",
        "teaser": null
      },{
        "title": "[TIL] 내배캠 iOS앱 개발 공부 6일차",
        "excerpt":"1~5일차는?  인터넷 뉴스 댓글, 유튜브 댓글도 작성하지 않는데 매일 매일 블로그 작성하라니… 시작하기 조금 어려웠다. 1~5일차 온보딩 프로젝트를 진행하면서 TIL은 흐지부지 되는 듯 했으나 오늘부터 본격적으로 강의를 시작하고 새로 팀을 구성하면서 팀원들의 TIL을 확인하고 나도 작성해보기로 했다. (그래도 알고리즘 문제는 매일 풀었다!)   오늘부터 시작, 데일리 스크럼부터  1~5일차 같은 노션 템플릿으로 팀 약속, 목표만 작성하고 데일리 스크럼은 다들 작성하지 않았다. (변명하자면 다들 작성 경험이 없어서... 누군가 먼저 작성했더라면 다들 적었을 것 같다.) 팀이 변경되고 처음부터 꾸준히 적은 팀원을 만나 작성된 내용을 확인하고 나도 데일리 스크럼을 작성하였다.      TIL 저녁에 작성하기로 했는데 오늘은 처음 작성하는거라 30분만에 작성하기 힘들 것 같아 조금씩 적었다.   이번주는 Swift 기초 문법 강의를 듣고 개인 과제도 만들어야하는데 강의 12개, 길이가 최대 30분이라 한번 듣고 다시 들으면서 swift 카테고리에 정리해봐야겠다.   앞으로  다들 너무 열심히 해서 열심히 해야겠다.  노션, 깃, 강의, 실습, 블로그 관리까지… TIL 계속 쓸 수 있겠지?  ","categories": ["TIL"],
        "tags": ["TIL"],
        "url": "/TIL/til6/",
        "teaser": null
      },{
        "title": "[Swift] 변수와 상수 ",
        "excerpt":"변수와 상수      변수나 상수를 이용하여 프로그램에서 사용되는 데이터를 메모리에 저장합니다.   let a: Int = 1 let b: Int = 2   변수     생성 후 데이터 변경 가능합니다.   var 변수명: 데이터 타입 = 값     var myMoney: Int = 10000 //현재 내 돈 만원 myMoney = 20000 // 알고보니 이만원, 이만원으로 수정             상수     한번 값을 설정하면 다음에 변경 할 수 없습니다.   let 상수명: 데이터 타입 = 값     let tenWon: Int = 10 //10원   tenWon = 20          //에러 발생 10원은 10원             상수로 선언된 10원을 20원으로 수정하면 에러가 발생합니다.  let을 var로 변경하여 값을 변경 가능하게 만들어야합니다.       상수 값 변경 시 에러  error: MyPlayground.playground:60:1: error: cannot assign to value: 'tenWon' is a 'let' constant tenWon = 20 ^~~~~~  MyPlayground.playground:59:1: note: change 'let' to 'var' to make it mutable let tenWon: Int = 10 ^~~ var   ","categories": ["swift"],
        "tags": ["swift","variable","constant"],
        "url": "/swift/variableAndConstant/",
        "teaser": null
      },{
        "title": "[Swift] 데이터 타입 ",
        "excerpt":"데이터 타입     데이터 타입은 데이터 종류입니다.   첫 글자가 대문자로 시작하는 대문자 카멜케이스 사용합니다.       Int, UInt     Int: +, - 부호가 있는 정수입니다.   UInt: - 를 포함하지 않는 0을 포함한 양의 정수입니다.   var a: Int = 0 var b: UInt = 0  a = 9223372036854775807 + 1 // 범위를 벗어나면 에러가 발생합니다.    print(Int.min)  // -9223372036854775808 print(Int.max)  // 9223372036854775807 print(UInt.min) // 0 print(UInt.max) // 18446744073709551615  error: MyPlayground.playground:62:25: error: arithmetic operation '9223372036854775807 + 1' (on type 'Int') results in an overflow a = 9223372036854775807 + 1     ~~~~~~~~~~~~~~~~~~~ ^ ~      Float, Double  Float     소수점을 표현하는 데이터 타입으로 32비트 부동 소수를 표현할 수 있습니다.   Float의 정밀도는 소수점 이하 6자리까지 가능합니다.   var interestRate: Float = 1.2345678910 // Float 타입 print(\"이자율은 \\(interestRate) % 입니다\") // 출력값: 이자율은 1.2345679 % 입니다   Double     소수점을 표현하는 데이터 타입으로 64비트 부동소수를 표현할 수 있습니다.   Double의 정밀도는 소수점 이하 15자리 이상 가능합니다.   두 유형 모두 적합한 상황에서는 Double을 사용하는 것이 좋습니다.   var interestRate: Double = 1.2345678910123456789 // Double 타입 print(\"이자율은 \\(interestRate) % 입니다\") // 출력값: 이자율은 1.2345678910123457 % 입니다       Boolean     참(true), 거짓(false)만 값으로 가집니다.   true, false 가 아니면 에러가 발생합니다.   var isTrue: Bool = true var isFalse: Bool = false isTrue = 100    //에러 isTrue = \"true\" //에러     error: MyPlayground.playground:64:10: error: cannot assign value of type 'Int' to type 'Bool' isTrue = 100          ^~~  error: MyPlayground.playground:65:10: error: cannot assign value of type 'String' to type 'Bool' isTrue = \"True\"          ^~~~~~       Character     단 하나의 문자입니다.   var a: Character = \"a\"  a = \"aa\" //에러   error: MyPlayground.playground:62:5: error: cannot assign value of type 'String' to type 'Character' a = \"aa\"     ^~~~       String     문자열을 표현하는 데이터 타입 입니다.   var str: String = \"string\"        Any     모든 데이터 타입을 사용할 수 있습니다.   var a: Any = \"a\" a = \"aa\" a = 1 a = 1234.5678       Tuple     튜플은 여러 값을 하나로 그룹화한 값입니다.   Tuple은 관련 값의 단순한 그룹에 유용합니다. 복잡한 데이터 구조를 만드는 데는 적합하지 않습니다.   var person: (String, Int) = (\"홍길동\", 20) //튜플 값에 접근하려면 순서를 알고 있어야합니다.  print(person.0) //홍길동 print(person.1) //20  var test: (Int, String) = (aaaa: 200, bbbb: \"TEST\") //엘리먼트에 이름 붙일 수 있습니다.  // 많은 데이터를 담는 데는 적합하지 않다 - 사용하는 쪽에서 또 매핑(Mapping)을 해야 함 let myInfo: (String, Int, Int, Int, String, String) =  (name: \"peter\", registrationNumber: 970212, height: 185, weight: 75, job: \"developer\", hobby: \"soccer\")       배열     같은 타입의 데이터를 순서대로 저장합니다.   var arr: [Int] = [1,2,3,4,5]       Dictionary     key, value 쌍의 모음입니다.   var fruit: [String: Int] = [\"바나나\": 5000, \"사과\": 6000, \"키위\": 8000]       Set     같은 타입의 데이터를 순서 없이 하나의 묶음으로 저장합니다..   중복된 값이 존재 하지 않습니다.   var name1: Set&lt;String&gt; = Set&lt;String&gt;() //빈 세트 생성  var name2: Set&lt;String&gt; = [] //빈 세트 생성 var name3: Set&lt;String&gt; = [\"aaa\", \"bbb\", \"ccc\"]  ","categories": ["swift"],
        "tags": ["swift","Data Type"],
        "url": "/swift/dataType/",
        "teaser": null
      },{
        "title": "[Swift] 옵셔널(Optional)",
        "excerpt":"옵셔널?  Swift에서 옵셔널(Optional)은 값이 있을 수도 있고 없을 수도 있는 값을 나타내는 형식입니다. 변수 또는 상수에 값을 갖지 않을 수 있는 경우에 사용합니다.   nil?  Swift에서 값이 없으면 nil로 나타냅니다. “” 같은 빈 문자열과 다름   옵셔널 사용     물음표로 나타냅니다.   var num1: Int? = 1           //? 사용하여 축약 타입 표현 var num2: Optional&lt;Int&gt; = 1 //정식 타입 표현     num1 + num2 //옵셔널 타입끼리 연산이 불가능, 에러 발생     Optional 추출 (Unwapping)     옵셔널의 값을 옵셔널이 아닌 값으로 추출하는 방법입니다.   1. 강제 추출   //강제 추출   var x: Int? = 1 print(x)    //결과: Optional(1) print(x!)   //결과: 1   //if문으로 nil만 확인하고 강제 추출  if x != nil {     print(x!) }   2. 옵셔널 바인딩  옵셔널 값이 빈 값인지 아닌지 검사 후 값이 있는 경우 그 값을 다른 변수/상수에 대입시키는 것입니다.   var num: Int? = nil  if let number = num {     print(number) //출력 값 없음 }  var x: Int? = 1  if let xx = x {      print(xx)   //1 출력  }  //옵셔널 바인딩 할 변수가 여러개 인 경우 콤마 사용  var boyName: String? = \"김철수\" var girlName2: String? = \"김영희\"   if let boy = boyName, let girl = girlName {     print(boy, girl)    //김철수, 김영희 출력  }  // guard let 사용 func opbinding() {     guard let x = x else { return }     print(x)      guard let y = y else { return } // y는 nil 이므로 여기서 return     print(y) // 위에서 return 하였기 때문에 이 코드 라인은 실행되지 않음 }  opbinding() // 출력값: 10   3. Nil Coalescing 닐 코얼레싱  값이 nil일때 기본 값을 적용     옵셔널 ?? 기본값   var num: Int? = nil var number = num ?? 0   // num이 nill이면 기본 값으로 0  print(num, number)      // 출력: nil 0    옵셔널 체이닝  옵셔널 체이닝(Optional Chaining)은 Swift에서 옵셔널 값의 체인을 따라 연속적으로 값을 가져오는 방법을 말합니다.     옵셔널 값이 있는 여러 단계의 프로퍼티 또는 메소드 호출을 수행할 때 유용합니다.   옵셔널 체이닝을 사용하면 옵셔널이 nil일 때도 에러가 발생하지 않고, 안전하게 체인을 따라 값에 접근할 수 있습니다.   class Person {     let name: String     var pet: Animal?          init(name: String, pet: Animal? = nil) {         self.name = name         self.pet = pet     } } class Animal {     let type: String     var animalName: String?          init(type: String, animalName: String? = nil) {         self.type = type         self.animalName = animalName     } }  let park = Person(name: \"박\", pet: Animal(type: \"dog\", animalName: \"호두\")) let kim = Person(name: \"김\", pet: Animal(type: \"cat\")) let lim = Person(name: \"임\")  print(park.pet?.animalName) // Optional(\"호두\") print(kim.pet?.animalName)  // nil print(lim.pet?.type)        // nil  ","categories": ["swift"],
        "tags": ["swift","optional","Nil Coalescing"],
        "url": "/swift/optional/",
        "teaser": null
      },{
        "title": "[TIL] 내배캠 iOS앱 개발 공부 7일차",
        "excerpt":"데일리 스크럼     알고리즘  오늘의 데일리 스크럼을 작성하고 오늘의 알고리즘 문제를 바로 풀었는데….     자연수 n이 매개변수로 주어집니다. n을 3진법 상에서 앞뒤로 뒤집은 후, 이를 다시 10진법으로 표현한 수를 return 하도록 solution 함수를 완성해주세요.                n (10진법)         n (3진법)         앞뒤 반전(3진법)\t         10진법으로 표현                   45\t         1200\t         0021         7                   125\t         11122\t         22111         229        앞뒤 반전(3진법)에서 10진법으로 만드는 과정에서 제곱때문에 함수를 새로 만드느라 시간이 오래걸렸다. 그리고 답안을 제출했는데 1개가 계속 맞지 않아서 블로그 기능 확인 및 추가시간까지 알고리즘 문제를 풀었다. 아직 못해서 저녁 9시 이후에 다 지우고 새로 풀어볼 예정!      옵셔널 강의듣고 정의, nil, Unwapping, optional binding, Nil Coalescing, chaining… 관련해서 정리하면서 글을 썼더니 오후 시간이 다 가버렸다. 작성하는 내용이 맞는지 안맞는지 확인하고 플레이그라운드에 실행해보고 하는 시간이 너무 오래 걸렸다.   내일은?  개인 과제를 아직 진행하지 못해서 내일은 개인 과제를 먼저 진행해야겠다.  ","categories": ["TIL"],
        "tags": ["TIL"],
        "url": "/TIL/til7/",
        "teaser": null
      },{
        "title": "[프로그래머스/Swift] 3진법 뒤집기",
        "excerpt":"문제 설명     자연수 n이 매개변수로 주어집니다. n을 3진법 상에서 앞뒤로 뒤집은 후, 이를 다시 10진법으로 표현한 수를 return 하도록 solution 함수를 완성해주세요.   문제 풀기   제한사항     n은 1 이상 100,000,000 이하인 자연수입니다.   입출력 예                  n       return                       45       7                 125       229           입출력 예 #1     답을 도출하는 과정은 다음과 같습니다.                  n (10진법)       n (3진법)       앞뒤 반전(3진법)       10진법으로 표현                       45       1200       0021       7              따라서 7을 return 해야 합니다.   입출력 예 #2     답을 도출하는 과정은 다음과 같습니다.                  n (10진법)       n (3진법)       앞뒤 반전(3진법)       10진법으로 표현                       125       11122       22111       229              따라서 229을 return 해야 합니다.   나의 풀이  import Foundation  func square(n: Int) -&gt; Int {     var num: Int = 1     if n &gt; 0 {         for i in 1...n {             num *= 3         }     }     return num }  func solution(_ n:Int) -&gt; Int {     var num: Int = n     var sum: Int = 0     var arr: [Int] = []          //3진법으로 거꾸로 만들기     while true {         if num / 3 == 0 {             arr.append(num % 3)             break         } else {             arr.append(num % 3)             num = num / 3         }     }          print(arr)          //3진법을 다시 10진법으로 만들기     for i in 0...arr.count - 1 {         sum += (arr[i] * square(n: arr.count - i - 1))     }          return sum }  다른 사람 풀이  import Foundation    func solution(_ n:Int) -&gt; Int {         let flipToThree = String(n,radix: 3)         let answer = Int(String(flipToThree.reversed()),radix:3)!         return answer     }   의견     풀다보니 앞뒤 반전으로 저장되었다. 제곱을 구하기 위해 함수를 하나 더 만들었다 !   다른 사람꺼는 우선 봐도 모르겠다… 공부하고 다시 보는걸로  ","categories": ["Algorithm"],
        "tags": ["Algorithm","coding test","3진법 뒤집기"],
        "url": "/algorithm/3%EC%A7%84%EB%B2%95%EB%92%A4%EC%A7%91%EA%B8%B0/",
        "teaser": null
      },{
        "title": "[프로그래머스/Swift] x만큼 간격이 있는 n개의 숫자",
        "excerpt":"문제 설명     함수 solution은 정수 x와 자연수 n을 입력 받아, x부터 시작해 x씩 증가하는 숫자를 n개 지니는 리스트를 리턴해야 합니다. 다음 제한 조건을 보고, 조건을 만족하는 함수, solution을 완성해주세요.   x만큼 간격이 있는 n개의 숫자 문제 풀기   제한사항     x는 -10000000 이상, 10000000 이하인 정수입니다.   n은 1000 이하인 자연수입니다.   입출력 예                  x       n       result                       2       5       [2,4,6,8,10]                 4       3       [4,8,12]                 -4       2       [-4, -8]           나의 풀이  func solution(_ x:Int, _ n:Int) -&gt; [Int64] {     var arr: [Int64] = []     for i in 1...n {         arr.append(Int64(x * i))     }     return arr  }  다른 사람 풀이  func solution(_ x:Int, _ n:Int) -&gt; [Int64] {     return Array(1...n).map { Int64($0 * x) } }   의견     for 문에 사로잡힌 나의 모습  ","categories": ["Algorithm"],
        "tags": ["Algorithm","coding test","x만큼 간격이 있는 n개의 숫자"],
        "url": "/algorithm/x%EB%A7%8C%ED%81%BC%EA%B0%84%EA%B2%A9%EC%9D%B4%EC%9E%88%EB%8A%94n%EA%B0%9C%EC%9D%98%EC%88%AB%EC%9E%90/",
        "teaser": null
      },{
        "title": "[프로그래머스/Swift] 가운데 글자 가져오기",
        "excerpt":"문제 설명     단어 s의 가운데 글자를 반환하는 함수, solution을 만들어 보세요. 단어의 길이가 짝수라면 가운데 두글자를 반환하면 됩니다.   문제 풀기   제한사항     s는 길이가 1 이상, 100이하인 스트링입니다.   입출력 예                  s       return                       “abcde”       “c”                 “qwer”       “we”           나의 풀이  func solution(_ s:String) -&gt; String {     var gubun: Bool = true      var half: Int = 0      var str: String = \"\"      var arr: [String] = []          //짝홀 구분      if s.count % 2 == 0 {          gubun = true       } else {         gubun = false      }     half = s.count / 2          for i in s {         arr.append(String(i))     }          if gubun == true {         str = arr[half - 1] + arr[half]     } else {         str = arr[half]     }          return str }  다른 사람 풀이  func solution(_ s:String) -&gt; String {      return String(s[String.Index(encodedOffset: (s.count-1)/2)...String.Index(encodedOffset: s.count/2)]) }   의견     고민하면서 풀었는데 다른 사람 풀이 보면 정말 대박…  ","categories": ["Algorithm"],
        "tags": ["Algorithm","coding test","가운데 글자 가져오기"],
        "url": "/algorithm/%EA%B0%80%EC%9A%B4%EB%8D%B0%EA%B8%80%EC%9E%90%EA%B0%80%EC%A0%B8%EC%98%A4%EA%B8%B0/",
        "teaser": null
      },{
        "title": "[프로그래머스/Swift] 각도기",
        "excerpt":"문제 설명     각에서 0도 초과 90도 미만은 예각, 90도는 직각, 90도 초과 180도 미만은 둔각 180도는 평각으로 분류합니다. 각 angle이 매개변수로 주어질 때 예각일 때 1, 직각일 때 2, 둔각일 때 3, 평각일 때 4를 return하도록 solution 함수를 완성해주세요.   예각 : 0 &lt; angle &lt; 90   직각 : angle = 90   둔각 : 90 &lt; angle &lt; 180   평각 : angle = 180   각도기 문제 풀기   제한사항     0 &lt; angle ≤ 180   angle은 정수입니다.   입출력 예                  angle       result                       70       1                 91       3                 180       4           입출력 예 #1     angle이 70이므로 예각입니다. 따라서 1을 return합니다.   입출력 예 #2     angle이 91이므로 둔각입니다. 따라서 3을 return합니다.   입출력 예 #3     angle이 180이므로 평각입니다. 따라서 4를 return합니다.   나의 풀이  import Foundation  func solution(_ angle:Int) -&gt; Int {     switch angle {         case 1...89:             return 1         case 90:             return 2         case 91...179:             return 3         case 180:              return 4         default:              return 0     } }  다른 사람 풀이  import Foundation  func solution(_ angle:Int) -&gt; Int {     return angle &lt; 90 ? 1 : angle == 90 ? 2 : angle &lt; 180 ? 3 : 4 }   의견     삼항연산자를 중첩사용하여 푼 사람이 많았다. 풀이가 제각각인게 흥미롭다.  ","categories": ["Algorithm"],
        "tags": ["Algorithm","coding test","각도기"],
        "url": "/algorithm/%EA%B0%81%EB%8F%84%EA%B8%B0/",
        "teaser": null
      },{
        "title": "[프로그래머스/Swift] 나누어 떨어지는 숫자 배열",
        "excerpt":"문제 설명     array의 각 element 중 divisor로 나누어 떨어지는 값을 오름차순으로 정렬한 배열을 반환하는 함수, solution을 작성해주세요. divisor로 나누어 떨어지는 element가 하나도 없다면 배열에 -1을 담아 반환하세요.   문제 풀기   제한사항     arr은 자연수를 담은 배열입니다.   정수 i, j에 대해 i ≠ j 이면 arr[i] ≠ arr[j] 입니다.   divisor는 자연수입니다.   array는 길이 1 이상인 배열입니다.   입출력 예                  arr       divisor       return                       [5,9,7,10]       5       [5,10]                 [2,36,1,3]       1       [1,2,3,36]                 [3,2,6]       10       [-1]           입출력 예 #1     arr의 원소 중 5로 나누어 떨어지는 원소는 5와 10입니다. 따라서 [5, 10]을 리턴합니다.   입출력 예 #2     arr의 모든 원소는 1으로 나누어 떨어집니다. 원소를 오름차순으로 정렬해 [1, 2, 3, 36]을 리턴합니다.   입출력 예 #3     3, 2, 6은 10으로 나누어 떨어지지 않습니다. 나누어 떨어지는 원소가 없으므로 [-1]을 리턴합니다.   나의 풀이  func solution(_ arr:[Int], _ divisor:Int) -&gt; [Int] {     var rtnArr: [Int] = []     var temp: Int = 0           if divisor &gt; 0 {         for i in arr {             if i % divisor == 0 {                 rtnArr.append(i)             }         }                  //나누어 떨어지는게 없다면 -1          if rtnArr.count == 0 {             rtnArr.append(-1)         } else {             if rtnArr.count &gt; 1 {                 //나누어 떨어졌으면 오름차순 정렬                  for i in 0...rtnArr.count - 2 {                     for j in i + 1...rtnArr.count - 1 {                         if rtnArr[i] &gt; rtnArr[j] {                             temp = rtnArr[j]                              rtnArr[j] = rtnArr[i]                              rtnArr[i] = temp                          }                     }                 }             }         }     }          return rtnArr }  다른 사람 풀이  func solution(_ arr:[Int], _ divisor:Int) -&gt; [Int] {     let result = arr.filter{ $0 % divisor == 0}.sorted()     return result.isEmpty ? [-1] : result }   의견     정렬하는것 때문에 플레이 그라운드에서 고민 많이 했는데 filter와 sorted라니… 다른 사람들은 쉽게 쉽게 풀었네  ","categories": ["Algorithm"],
        "tags": ["Algorithm","coding test","나누어 떨어지는 숫자 배열"],
        "url": "/algorithm/%EB%82%98%EB%88%84%EC%96%B4%EB%96%A8%EC%96%B4%EC%A7%80%EB%8A%94%EC%88%AB%EC%9E%90%EB%B0%B0%EC%97%B4/",
        "teaser": null
      },{
        "title": "[프로그래머스/Swift] 나머지가 1이 되는 수 찾기",
        "excerpt":"문제 설명     자연수 n이 매개변수로 주어집니다. n을 x로 나눈 나머지가 1이 되도록 하는 가장 작은 자연수 x를 return 하도록 solution 함수를 완성해주세요. 답이 항상 존재함은 증명될 수 있습니다.   나머지가 1이 되는 수 찾기 문제 풀기   제한사항     3 ≤ n ≤ 1,000,000   입출력 예                  n       result                       10       3                 12       11           입출력 예 #1     10을 3으로 나눈 나머지가 1이고, 3보다 작은 자연수 중에서 문제의 조건을 만족하는 수가 없으므로, 3을 return 해야 합니다.   입출력 예 #2     12를 11로 나눈 나머지가 1이고, 11보다 작은 자연수 중에서 문제의 조건을 만족하는 수가 없으므로, 11을 return 해야 합니다.   나의 풀이  import Foundation  func solution(_ n:Int) -&gt; Int {     var num: Int = 0           if n &gt;= 3 &amp;&amp; n &lt;= 1000000 {         for i in 2...n {             if n % i == 1 {                 num = i                 break             }         }     } else {         num = 1     }     return num }  다른 사람 풀이  import Foundation  func solution(_ n:Int) -&gt; Int {     return (1...n).filter{n % $0 == 1}.min()! }   의견     이번 문제는 비슷하게 푼 사람들이 많았다. 지금 보고 이해안되는 풀이는 우선 기록  ","categories": ["Algorithm"],
        "tags": ["Algorithm","coding test","나머지가 1이 되는 수 찾기"],
        "url": "/algorithm/%EB%82%98%EB%A8%B8%EC%A7%80%EA%B0%801%EC%9D%B4%EB%90%98%EB%8A%94%EC%88%98%EC%B0%BE%EA%B8%B0/",
        "teaser": null
      },{
        "title": "[프로그래머스/Swift] 나이 출력",
        "excerpt":"문제 설명     머쓱이는 40살인 선생님이 몇 년도에 태어났는지 궁금해졌습니다. 나이 age가 주어질 때, 2022년을 기준 출생 연도를 return 하는 solution 함수를 완성해주세요.   나이 출력 문제 풀기   제한사항     0 &lt; age ≤ 120   나이는 태어난 연도에 1살이며 1년마다 1씩 증가합니다.   입출력 예                  age       result                       40       1983                 23       2000           입출력 예 #1     2022년 기준 40살이므로 1983년생입니다.   입출력 예 #2     2022년 기준 23살이므로 2000년생입니다.   나의 풀이  import Foundation  func solution(_ age:Int) -&gt; Int {     return (2022 - age) + 1  }  다른 사람 풀이  import Foundation  func solution(_ age:Int) -&gt; Int {     guard age &gt; 0, age &lt;= 120 else { return 0 }     return 2023 - age }   의견     제한사항이 있으나 없어도 통과는 되었다. 다른 사람도 대부분 제한사항이 없었으나 추가한 사람이 있어 비교해보았다. 우선 제한사항 없이 풀어볼 예정  ","categories": ["Algorithm"],
        "tags": ["Algorithm","coding test","나이 출력"],
        "url": "/algorithm/%EB%82%98%EC%9D%B4%EC%B6%9C%EB%A0%A5/",
        "teaser": null
      },{
        "title": "[프로그래머스/Swift] 내적",
        "excerpt":"문제 설명     길이가 같은 두 1차원 정수 배열 a, b가 매개변수로 주어집니다. a와 b의 내적을 return 하도록 solution 함수를 완성해주세요.   이때, a와 b의 내적은 a[0]b[0] + a[1]b[1] + … + a[n-1]*b[n-1] 입니다. (n은 a, b의 길이)   문제 풀기   제한사항     a, b의 길이는 1 이상 1,000 이하입니다.   a, b의 모든 수는 -1,000 이상 1,000 이하입니다.   입출력 예                  a       b       result                       [1,2,3,4]       [-3,-1,0,2]       3                 [-1,0,1]       [1,0,-1]       -2           입출력 예 #1     a와 b의 내적은 1(-3) + 2(-1) + 30 + 42 = 3 입니다.   입출력 예 #2     a와 b의 내적은 (-1)1 + 00 + 1*(-1) = -2 입니다.   나의 풀이  import Foundation  func solution(_ a:[Int], _ b:[Int]) -&gt; Int {     var sum: Int = 0      for i in 0...a.count - 1 {         sum = sum + (a[i] * b[i])     }     return sum }  다른 사람 풀이  import Foundation  func solution(_ a:[Int], _ b:[Int]) -&gt; Int {     return zip(a, b).map(*).reduce(0, +) }   의견     다른 사람들 풀이로 많이 배우면서 생각하게 되는듯  ","categories": ["Algorithm"],
        "tags": ["Algorithm","coding test","내적"],
        "url": "/algorithm/%EB%82%B4%EC%A0%81/",
        "teaser": null
      },{
        "title": "[프로그래머스/Swift] 두 수의 곱",
        "excerpt":"문제 설명     정수 num1, num2가 매개변수 주어집니다. num1과 num2를 곱한 값을 return 하도록 solution 함수를 완성해주세요.   두수의 곱 문제 풀기   제한사항     0 ≤ num1 ≤ 100   0 ≤ num2 ≤ 100   입출력 예                  num1       num2       result                       3       4       12                 27       19       513           입출력 예 #1     num1이 3, num2가 4이므로 3 * 4 = 12를 return합니다.   입출력 예 #2     num1이 27, num2가 19이므로 27 * 19 = 513을 return합니다.   나의 풀이  import Foundation  func solution(_ num1:Int, _ num2:Int) -&gt; Int {     return num1 * num2  }  다른 사람 풀이  import Foundation  func solution(_ num1:Int, _ num2:Int) -&gt; Int {     guard (num1 &gt;= 0 &amp;&amp; num1 &lt;= 100) , (num2 &gt;= 0 &amp;&amp; num2 &lt;= 100) else {         return 0     }     return  num1 * num2  }   의견     제한사항이 있으나 없어도 통과는 되었다. 다른 사람도 대부분 제한사항이 없었으나 추가한 사람이 있어 비교해보았다. 우선 제한사항 없이 풀어볼 예정  ","categories": ["Algorithm"],
        "tags": ["Algorithm","coding test","두수의 곱"],
        "url": "/algorithm/%EB%91%90%EC%88%98%EC%9D%98%EA%B3%B1/",
        "teaser": null
      },{
        "title": "[프로그래머스/Swift] 두 수의 나눗셈",
        "excerpt":"문제 설명     정수 num1과 num2가 매개변수로 주어질 때, num1을 num2로 나눈 값에 1,000을 곱한 후 정수 부분을 return 하도록 soltuion 함수를 완성해주세요.   두 수의 나눗셈 문제 풀기   제한사항     0 ≤ num1 ≤ 100   0 ≤ num2 ≤ 100   입출력 예                  num1       num2       result                       3       2       1500                 7       3       2333                 1       16       62           입출력 예 #1     num1이 3, num2가 2이므로 3 / 2 = 1.5에 1,000을 곱하면 1500이 됩니다.   입출력 예 #2     num1이 7, num2가 3이므로 7 / 3 = 2.33333…에 1,000을 곱하면 2333.3333…. 이 되며, 정수 부분은 2333입니다.   입출력 예 #3     num1이 1, num2가 16이므로 1 / 16 = 0.0625에 1,000을 곱하면 62.5가 되며, 정수 부분은 62입니다.   나의 풀이  import Foundation  func solution(_ num1:Int, _ num2:Int) -&gt; Int {     return Int((Double(num1) / Double(num2)) * 1000) }  다른 사람 풀이  import Foundation  func solution(_ num1:Int, _ num2:Int) -&gt; Int {     guard ( num1 &gt; 0 &amp;&amp; num1 &lt;= 100),( num2 &gt; 0 &amp;&amp; num2 &lt;= 100) else {         return 0     }     return Int((Double(num1) / Double(num2)) * 1000) }   의견     제한사항이 있으나 없어도 통과는 되었다. 다른 사람도 대부분 제한사항이 없었으나 추가한 사람이 있어 비교해보았다. 우선 제한사항 없이 풀어볼 예정  ","categories": ["Algorithm"],
        "tags": ["Algorithm","coding test","두수의 나눗셈"],
        "url": "/algorithm/%EB%91%90%EC%88%98%EC%9D%98%EB%82%98%EB%88%97%EC%85%88/",
        "teaser": null
      },{
        "title": "[프로그래머스/Swift] 두 수의 차",
        "excerpt":"문제 설명     정수 num1과 num2가 주어질 때, num1에서 num2를 뺀 값을 return하도록 soltuion 함수를 완성해주세요.   두수의 차 문제 풀기   제한사항     -50000 ≤ num1 ≤ 50000   -50000 ≤ num2 ≤ 50000   입출력 예                  num1       num2       result                       2       3       -1                 100       2       98           입출력 예 #1     num1이 2이고 num2가 3이므로 2 - 3 = -1을 return합니다.   입출력 예 #2     num1이 100이고 num2가 2이므로 100 - 2 = 98을 return합니다.   나의 풀이  import Foundation  func solution(_ num1:Int, _ num2:Int) -&gt; Int {     return num1 - num2 }  다른 사람 풀이  import Foundation  func solution(_ num1:Int, _ num2:Int) -&gt; Int {     guard (num1 &lt;= 50000 &amp;&amp; num1 &gt;= -50000) , (num2 &lt;= 50000 &amp;&amp; num2 &gt;= -50000) else {         return -1     }      return num1-num2 }   의견     제한사항이 있으나 없어도 통과는 되었다. 다른 사람도 대부분 제한사항이 없었으나 추가한 사람이 있어 비교해보았다. 우선 제한사항 없이 풀어볼 예정  ","categories": ["Algorithm"],
        "tags": ["Algorithm","coding test","두수의 차"],
        "url": "/algorithm/%EB%91%90%EC%88%98%EC%9D%98%EC%B0%A8/",
        "teaser": null
      },{
        "title": "[프로그래머스/Swift] 두 수의 합",
        "excerpt":"문제 설명     정수 num1과 num2가 주어질 때, num1과 num2의 합을 return하도록 soltuion 함수를 완성해주세요.   두 수의 합 문제 풀기   제한사항     -50,000 ≤ num1 ≤ 50,000   -50,000 ≤ num2 ≤ 50,000   입출력 예                  num1       num2       result                       2       3       5                 100       2       102           입출력 예 #1     num1이 2이고 num2가 3이므로 2 + 3 = 5를 return합니다.   입출력 예 #2     num1이 100이고 num2가 2이므로 100 + 2 = 102를 return합니다.   나의 풀이  import Foundation  func solution(_ num1:Int, _ num2:Int) -&gt; Int {     return num1 + num2 }  다른 사람 풀이  import Foundation  func solution(_ num1:Int, _ num2:Int) -&gt; Int {         guard (num1 &gt;= -500000 &amp;&amp; num1 &lt;= 500000) , (num2 &gt;= -500000 &amp;&amp; num2 &lt;= 500000) else {         return -1     }     return num1 + num2 }   의견     제한사항이 있으나 없어도 통과는 되었다. 다른 사람도 대부분 제한사항이 없었으나 추가한 사람이 있어 비교해보았다. 우선 제한사항 없이 풀어볼 예정  ","categories": ["Algorithm"],
        "tags": ["Algorithm","coding test","두 수의 합"],
        "url": "/algorithm/%EB%91%90%EC%88%98%EC%9D%98%ED%95%A9/",
        "teaser": null
      },{
        "title": "[프로그래머스/Swift] 두 정수 사이의 합",
        "excerpt":"문제 설명     두 정수 a, b가 주어졌을 때 a와 b 사이에 속한 모든 정수의 합을 리턴하는 함수, solution을 완성하세요. 예를 들어 a = 3, b = 5인 경우, 3 + 4 + 5 = 12이므로 12를 리턴합니다.   두 정수 사이의 합 문제 풀기   제한사항     a와 b가 같은 경우는 둘 중 아무 수나 리턴하세요.   a와 b는 -10,000,000 이상 10,000,000 이하인 정수입니다.   a와 b의 대소관계는 정해져있지 않습니다.   입출력 예                  a       b       return                       3       5       12                 3       3       3                 5       3       12           나의 풀이  func solution(_ a:Int, _ b:Int) -&gt; Int64 {     var sum: Int = 0           if a == b {         sum = a      } else if a &lt; b {          for i in a...b {             sum += i          }     } else {         for i in b...a {             sum += i         }     }          return Int64(sum) }  다른 사람 풀이  func solution(_ a:Int, _ b:Int) -&gt; Int64 {     return Int64(Array(a &gt; b ? b...a : a...b).reduce(0, +))   }   의견     모든 걸 한줄로 해결하는 다른 사람들… 대단한듯  ","categories": ["Algorithm"],
        "tags": ["Algorithm","coding test","두 정수 사이의 합"],
        "url": "/algorithm/%EB%91%90%EC%A0%95%EC%88%98%EC%82%AC%EC%9D%B4%EC%9D%98%ED%95%A9/",
        "teaser": null
      },{
        "title": "[프로그래머스/Swift] 몫 구하기",
        "excerpt":"문제 설명     정수 num1, num2가 매개변수로 주어질 때, num1을 num2로 나눈 몫을 return 하도록 solution 함수를 완성해주세요.   몫 구하기 문제 풀기   제한사항     0 &lt; num1 ≤ 100   0 &lt; num2 ≤ 100   입출력 예                  num1       num2       result                       10       5       2                 7       2       3           입출력 예 #1     num1이 10, num2가 5이므로 10을 5로 나눈 몫 2를 return 합니다.   입출력 예 #2     num1이 7, num2가 2이므로 7을 2로 나눈 몫 3을 return 합니다.   나의 풀이  import Foundation  func solution(_ num1:Int, _ num2:Int) -&gt; Int {     return num1 / num2 }  다른 사람 풀이  import Foundation  func solution(_ num1:Int, _ num2:Int) -&gt; Int {     guard (num1 &gt; 0 &amp;&amp; num1 &lt;= 100) &amp;&amp; ( num2 &gt; 0 &amp;&amp; num2 &lt;= 100 ) else { return 0 }     let result = num1 / num2     return result }   의견     제한사항이 있으나 없어도 통과는 되었다. 다른 사람도 대부분 제한사항이 없었으나 추가한 사람이 있어 비교해보았다. 우선 제한사항 없이 풀어볼 예정  ","categories": ["Algorithm"],
        "tags": ["Algorithm","coding test","몫 구하기"],
        "url": "/algorithm/%EB%AA%AB%EA%B5%AC%ED%95%98%EA%B8%B0/",
        "teaser": null
      },{
        "title": "[프로그래머스/Swift] 문자열 내림차순으로 배치하기",
        "excerpt":"문제 설명     문자열 s에 나타나는 문자를 큰것부터 작은 순으로 정렬해 새로운 문자열을 리턴하는 함수, solution을 완성해주세요. s는 영문 대소문자로만 구성되어 있으며, 대문자는 소문자보다 작은 것으로 간주합니다.   문제 풀기   제한사항     str은 길이 1 이상인 문자열입니다.   입출력 예                  s       return                       “Zbcdefg”       “gfedcbZ”           나의 풀이  func solution(_ s:String) -&gt; String {     var str: String = \"\"      var arr: [String] = []      var temp: String = \"\"           for i in s {         arr.append(String(i))     }      for i in 0...arr.count - 2 {         for j in i + 1...arr.count - 1 {             if arr[i] &lt; arr[j] {                 temp = arr[j]                  arr[j] = arr[i]                  arr[i] = temp              }         }     }         for i in arr {         str += i      }         return str }  다른 사람 풀이  func solution(_ s:String) -&gt; String {     return String(s.sorted { $0 &gt; $1 }) }   의견     다른 사람 풀이 아직 백프로 이해 못했다 ㅠ  ","categories": ["Algorithm"],
        "tags": ["Algorithm","coding test","문자열 내림차순으로 배치하기"],
        "url": "/algorithm/%EB%AC%B8%EC%9E%90%EC%97%B4%EB%82%B4%EB%A6%BC%EC%B0%A8%EC%88%9C%EC%9C%BC%EB%A1%9C%EB%B0%B0%EC%B9%98%ED%95%98%EA%B8%B0/",
        "teaser": null
      },{
        "title": "[프로그래머스/Swift] 문자열 다루기 기본",
        "excerpt":"문제 설명     문자열 s의 길이가 4 혹은 6이고, 숫자로만 구성돼있는지 확인해주는 함수, solution을 완성하세요. 예를 들어 s가 “a234”이면 False를 리턴하고 “1234”라면 True를 리턴하면 됩니다.   문제 풀기   제한사항     s는 길이 1 이상, 길이 8 이하인 문자열입니다.   s는 영문 알파벳 대소문자 또는 0부터 9까지 숫자로 이루어져 있습니다.   입출력 예                  s       return                       “a234”       false                 “1234”       true           나의 풀이  func solution(_ s:String) -&gt; Bool {     var strCheck: Bool = false     var numCheck: Bool = false     var check: Bool = false          var arr: [String] = []          for i in s {         arr.append(String(i))     }      for i in 0...arr.count - 1 {         if let gubun = Int(arr[i]) {             numCheck = true         } else {             strCheck = true         }     }      if (s.count == 4 || s.count == 6) &amp;&amp; numCheck == true &amp;&amp; strCheck == false {         check = true     }           return check  }  다른 사람 풀이  func solution(_ s:String) -&gt; Bool {     return (Int(s) != nil &amp;&amp; (s.count == 4 || s.count == 6)) ? true : false }   의견     두 개 따로 체크해서 비교했는데 다른 사람들 풀이로 많이 배우는 것 같다.  ","categories": ["Algorithm"],
        "tags": ["Algorithm","coding test","문자열 다루기 기본"],
        "url": "/algorithm/%EB%AC%B8%EC%9E%90%EC%97%B4%EB%8B%A4%EB%A3%A8%EA%B8%B0%EA%B8%B0%EB%B3%B8/",
        "teaser": null
      },{
        "title": "[프로그래머스/Swift] 문자열을 정수로 바꾸기",
        "excerpt":"문제 설명     문자열 s를 숫자로 변환한 결과를 반환하는 함수, solution을 완성하세요.   문자열을 정수로 바꾸기 문제 풀기   제한사항     s의 길이는 1 이상 5이하입니다.   s의 맨앞에는 부호(+, -)가 올 수 있습니다.   s는 부호와 숫자로만 이루어져있습니다.   s는 “0”으로 시작하지 않습니다.   입출력 예     예를들어 str이 “1234”이면 1234를 반환하고, “-1234”이면 -1234를 반환하면 됩니다. str은 부호(+,-)와 숫자로만 구성되어 있고, 잘못된 값이 입력되는 경우는 없습니다.   나의 풀이  func solution(_ s:String) -&gt; Int {     var num: Int = 0      if s.count &gt;= 1 &amp;&amp; s.count &lt;= 5 {         num = Int(s)!     }     return num }  다른 사람 풀이  func solution(_ s:String) -&gt; Int {     return Int(s)! }   의견     Int 형변환하면 부호를 알아서 인식하니까 강제 언래핑  ","categories": ["Algorithm"],
        "tags": ["Algorithm","coding test","문자열을 정수로 바꾸기"],
        "url": "/algorithm/%EB%AC%B8%EC%9E%90%EC%97%B4%EC%9D%84%EC%A0%95%EC%88%98%EB%A1%9C%EB%B0%94%EA%BE%B8%EA%B8%B0/",
        "teaser": null
      },{
        "title": "[프로그래머스/Swift] 배열의 평균값",
        "excerpt":"문제 설명     정수 배열 numbers가 매개변수로 주어집니다. numbers의 원소의 평균값을 return하도록 solution 함수를 완성해주세요.   배열의 평균값   제한사항     0 ≤ numbers의 원소 ≤ 1,000   1 ≤ numbers의 길이 ≤ 100   정답의 소수 부분이 .0 또는 .5인 경우만 입력으로 주어집니다.   입출력 예                  numbers       result                       [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]       5.5                 [89, 90, 91, 92, 93, 94, 95, 96, 97, 98, 99]       94.0           입출력 예 #1     numbers의 원소들의 평균 값은 5.5입니다.   입출력 예 #2     numbers의 원소들의 평균 값은 94.0입니다.   나의 풀이  import Foundation  func solution(_ numbers:[Int]) -&gt; Double {     var sum: Int = 0           for i in 0...numbers.count - 1{         sum += numbers[i]      }           return Double(sum) / Double(numbers.count) }  다른 사람 풀이  import Foundation  func solution(_ numbers:[Int]) -&gt; Double {     return Double(numbers.reduce(0, +)) / Double(numbers.count) }   의견     나는 for문에 너무 익숙한데 많은 사람들이 고차함수로 풀었다… 공부 필요!  ","categories": ["Algorithm"],
        "tags": ["Algorithm","coding test","배열의 평균값"],
        "url": "/algorithm/%EB%B0%B0%EC%97%B4%EC%9D%98-%ED%8F%89%EA%B7%A0%EA%B0%92/",
        "teaser": null
      },{
        "title": "[프로그래머스/Swift] 부족한 금액 계산하기",
        "excerpt":"문제 설명     새로 생긴 놀이기구는 인기가 매우 많아 줄이 끊이질 않습니다. 이 놀이기구의 원래 이용료는 price원 인데, 놀이기구를 N 번 째 이용한다면 원래 이용료의 N배를 받기로 하였습니다. 즉, 처음 이용료가 100이었다면 2번째에는 200, 3번째에는 300으로 요금이 인상됩니다. 놀이기구를 count번 타게 되면 현재 자신이 가지고 있는 금액에서 얼마가 모자라는지를 return 하도록 solution 함수를 완성하세요. 단, 금액이 부족하지 않으면 0을 return 하세요.   문제 풀기   제한사항     놀이기구의 이용료 price : 1 ≤ price ≤ 2,500, price는 자연수   처음 가지고 있던 금액 money : 1 ≤ money ≤ 1,000,000,000, money는 자연수   놀이기구의 이용 횟수 count : 1 ≤ count ≤ 2,500, count는 자연수   입출력 예                  price       money       count       result                       3       20       4       10           입출력 예 #1     이용금액이 3인 놀이기구를 4번 타고 싶은 고객이 현재 가진 금액이 20이라면, 총 필요한 놀이기구의 이용 금액은 30 (= 3+6+9+12) 이 되어 10만큼 부족하므로 10을 return 합니다.   나의 풀이  import Foundation  func solution(_ price:Int, _ money:Int, _ count:Int) -&gt; Int64{     var answer:Int64 = 0     var sum: Int = 0           for i in 1...count {         sum += price * i     }           if sum &gt; money {          answer = Int64(sum - money)     }           return answer }  다른 사람 풀이  import Foundation  func solution(_ price:Int, _ money:Int, _ count:Int) -&gt; Int64{     let totalPrice = price * (count * (count+1)/2)      if money &gt;= totalPrice {         return 0     }      return Int64(totalPrice - money) }   의견     무난하게 풀 수 있었다  ","categories": ["Algorithm"],
        "tags": ["Algorithm","coding test","부족한 금액 계산하기"],
        "url": "/algorithm/%EB%B6%80%EC%A1%B1%ED%95%9C%EA%B8%88%EC%95%A1%EA%B3%84%EC%82%B0%ED%95%98%EA%B8%B0/",
        "teaser": null
      },{
        "title": "[프로그래머스/Swift] 서울에서 김서방 찾기",
        "excerpt":"문제 설명     String형 배열 seoul의 element중 “Kim”의 위치 x를 찾아, “김서방은 x에 있다”는 String을 반환하는 함수, solution을 완성하세요. seoul에 “Kim”은 오직 한 번만 나타나며 잘못된 값이 입력되는 경우는 없습니다.   문제 풀기   제한사항     seoul은 길이 1 이상, 1000 이하인 배열입니다.   seoul의 원소는 길이 1 이상, 20 이하인 문자열입니다.   “Kim”은 반드시 seoul 안에 포함되어 있습니다.   입출력 예                  seoul       return                       [“Jane”, “Kim”]       “김서방은 1에 있다”           나의 풀이  func solution(_ seoul:[String]) -&gt; String {     var num: Int = 0           for i in 0...seoul.count - 1 {         if seoul[i] == \"Kim\" {             num = i          }     }          return \"김서방은 \\(num)에 있다\" }  다른 사람 풀이  func solution(_ seoul:[String]) -&gt; String {     return \"김서방은 \" + seoul.index(of: \"Kim\")!.description + \"에 있다\"; }   의견     index(of)를 사용해서 찾을 수 있군..  ","categories": ["Algorithm"],
        "tags": ["Algorithm","coding test","서울에서 김서방 찾기"],
        "url": "/algorithm/%EC%84%9C%EC%9A%B8%EC%97%90%EC%84%9C%EA%B9%80%EC%84%9C%EB%B0%A9%EC%B0%BE%EA%B8%B0/",
        "teaser": null
      },{
        "title": "[프로그래머스/Swift] 수박수박수박수박수박수?",
        "excerpt":"문제 설명     길이가 n이고, “수박수박수박수….”와 같은 패턴을 유지하는 문자열을 리턴하는 함수, solution을 완성하세요. 예를들어 n이 4이면 “수박수박”을 리턴하고 3이라면 “수박수”를 리턴하면 됩니다.   문제 풀기   제한사항     n은 길이 10,000이하인 자연수입니다.   입출력 예                  n       result                       3       “수박수”                 4       “수박수박”           나의 풀이  func solution(_ n:Int) -&gt; String {     var str: String = \"\"           for i in 1...n {         if i % 2 == 0 {             str += \"박\"                 } else {             str += \"수\"         }     }     return str }  다른 사람 풀이  func solution(_ n:Int) -&gt; String {     return \"\\(String(repeating: \"수박\", count: n / 2))\\(n % 2 == 0 ? \"\" : \"수\")\" }   의견     역시…  ","categories": ["Algorithm"],
        "tags": ["Algorithm","coding test","수박수박수박수박수박수"],
        "url": "/algorithm/%EC%88%98%EB%B0%95%EC%88%98%EB%B0%95%EC%88%98%EB%B0%95%EC%88%98%EB%B0%95%EC%88%98%EB%B0%95%EC%88%98/",
        "teaser": null
      },{
        "title": "[프로그래머스/Swift] 숫자 비교하기",
        "excerpt":"문제 설명     정수 num1과 num2가 매개변수로 주어집니다. 두 수가 같으면 1 다르면 -1을 retrun하도록 solution 함수를 완성해주세요.   숫자 비교하기 문제 풀기   제한사항     0 ≤ num1 ≤ 10,000   0 ≤ num2 ≤ 10,000   입출력 예                  num1       num2       result                       2       3       -1                 11       11       1                 7       99       -1           입출력 예 #1     num1이 2이고 num2가 3이므로 다릅니다. 따라서 -1을 return합니다.   입출력 예 #2     num1이 11이고 num2가 11이므로 같습니다. 따라서 1을 return합니다.   입출력 예 #3     num1이 7이고 num2가 99이므로 다릅니다. 따라서 -1을 return합니다.   나의 풀이  import Foundation  func solution(_ num1:Int, _ num2:Int) -&gt; Int {     return num1 == num2 ? 1 : -1  }  다른 사람 풀이  import Foundation  func solution(_ num1:Int, _ num2:Int) -&gt; Int {     guard (num1 &gt;= 0 &amp;&amp; num1 &lt;= 10000) , (num2 &gt;= 0 &amp;&amp; num2 &lt;= 10000) else {         return 0     }     return num1 == num2 ? 1 : -1 }   의견     제한사항이 있으나 없어도 통과는 되었다. 다른 사람도 대부분 제한사항이 없었으나 추가한 사람이 있어 비교해보았다. 우선 제한사항 없이 풀어볼 예정  ","categories": ["Algorithm"],
        "tags": ["Algorithm","coding test","숫자 비교하기"],
        "url": "/algorithm/%EC%88%AB%EC%9E%90%EB%B9%84%EA%B5%90%ED%95%98%EA%B8%B0/",
        "teaser": null
      },{
        "title": "[프로그래머스/Swift] 약수의 개수와 덧셈",
        "excerpt":"문제 설명     두 정수 left와 right가 매개변수로 주어집니다. left부터 right까지의 모든 수들 중에서, 약수의 개수가 짝수인 수는 더하고, 약수의 개수가 홀수인 수는 뺀 수를 return 하도록 solution 함수를 완성해주세요.   문제 풀기   제한사항     1 ≤ left ≤ right ≤ 1,000   입출력 예                  left       right       result                       13       17       43                 24       27       52           입출력 예 #1     다음 표는 13부터 17까지의 수들의 약수를 모두 나타낸 것입니다.                  수       약수       약수의 개수                       13       1, 13       2                 14       1, 2, 7, 14       4                 15       1, 3, 5, 15       4                 16       1, 2, 4, 8, 16       5                 17       1, 17       2              따라서, 13 + 14 + 15 - 16 + 17 = 43을 return 해야 합니다.   입출력 예 #2     다음 표는 24부터 27까지의 수들의 약수를 모두 나타낸 것입니다.                  수       약수       약수의 개수                       24       1, 2, 3, 4, 6, 8, 12, 24       8                 25       1, 5, 25       3                 26       1, 2, 13, 26       4                 27       1, 3, 9, 27       4              따라서, 24 - 25 + 26 + 27 = 52를 return 해야 합니다.   나의 풀이  func solution(_ left:Int, _ right:Int) -&gt; Int {     var sum: Int = 0      var cnt: Int = 0            for i in left...right {          for j in 1...i {             if i % j == 0 {                 cnt += 1              }         }                  if cnt % 2 == 0 {             sum += i          } else {             sum -= i          }         cnt = 0      }         return sum }  다른 사람 풀이  func solution(_ left: Int, _ right: Int) -&gt; Int {     return (left...right).map { i in (1...i).filter { i % $0 == 0 }.count % 2 == 0 ? i : -i }.reduce(0, +) }   의견     다른 사람들 풀이도 보다보니 같은게 하나도 없어서 놀랍다.  ","categories": ["Algorithm"],
        "tags": ["Algorithm","coding test","약수의 개수와 덧셈"],
        "url": "/algorithm/%EC%95%BD%EC%88%98%EC%9D%98%EA%B0%9C%EC%88%98%EC%99%80%EB%8D%A7%EC%85%88/",
        "teaser": null
      },{
        "title": "[프로그래머스/Swift] 약수의 합",
        "excerpt":"문제 설명     정수 n을 입력받아 n의 약수를 모두 더한 값을 리턴하는 함수, solution을 완성해주세요.   약수의 합 문제 풀기   제한사항     n은 0 이상 3000이하인 정수입니다.   입출력 예                  n       result                       12       28                 5       6           입출력 예 #1     12의 약수는 1, 2, 3, 4, 6, 12입니다. 이를 모두 더하면 28입니다.   입출력 예 #2     5의 약수는 1, 5입니다. 이를 모두 더하면 6입니다.   나의 풀이  func solution(_ n:Int) -&gt; Int {     var sum: Int = 0           if n &gt; 0 &amp;&amp; n &lt;= 3000 {         for i in 1...n {             if n % i == 0 {                  sum += i              }         }     }     return sum }  다른 사람 풀이  // 1  func solution(_ n:Int) -&gt; Int {        guard n != 0 else {         return 0     }     return Array(1...n).filter{n % $0 == 0}.reduce(0, +) }  // 2  func solution(_ n:Int) -&gt; Int {     return n != 0 ? (1...n).filter{n % $0 == 0}.reduce(0){$0 + $1} : 0 }   의견     다른 사람의 풀이는 역시 신기할따름…  ","categories": ["Algorithm"],
        "tags": ["Algorithm","coding test","약수의 합"],
        "url": "/algorithm/%EC%95%BD%EC%88%98%EC%9D%98%ED%95%A9/",
        "teaser": null
      },{
        "title": "[프로그래머스/Swift] 없는 숫자 더하기",
        "excerpt":"문제 설명     0부터 9까지의 숫자 중 일부가 들어있는 정수 배열 numbers가 매개변수로 주어집니다. numbers에서 찾을 수 없는 0부터 9까지의 숫자를 모두 찾아 더한 수를 return 하도록 solution 함수를 완성해주세요.   문제 풀기   제한사항     1 ≤ numbers의 길이 ≤ 9   0 ≤ numbers의 모든 원소 ≤ 9   numbers의 모든 원소는 서로 다릅니다.   입출력 예                  numbers       result                       [1,2,3,4,6,7,8,0]       14                 [5,8,4,0,6,7,9]       6           입출력 예 #1     5, 9가 numbers에 없으므로, 5 + 9 = 14를 return 해야 합니다.   입출력 예 #2     1, 2, 3이 numbers에 없으므로, 1 + 2 + 3 = 6을 return 해야 합니다.   나의 풀이  import Foundation  func solution(_ numbers:[Int]) -&gt; Int {     var sum: Int = 0      var arr: [Int] = []          for i in 0...9 {         arr.append(i)     }              if numbers.count &gt;= 1 &amp;&amp; numbers.count &lt;= 9 {         for i in 0...9 {             for j in 0...numbers.count - 1 {                 if arr[i] == numbers[j] {                     arr[i] = 0                  }             }         }     }      for i in arr {         sum += i     }     return sum }  다른 사람 풀이  func solution(_ numbers: [Int]) -&gt; Int {     return (0...9).filter { !numbers.contains($0) }.reduce(0, +) }   의견     1~28번까지 문제 풀면서 고차함수를 사용하면 짧게 풀 수 있는걸 알았다…  ","categories": ["Algorithm"],
        "tags": ["Algorithm","coding test","없는 숫자 더하기"],
        "url": "/algorithm/%EC%97%86%EB%8A%94%EC%88%AB%EC%9E%90%EB%8D%94%ED%95%98%EA%B8%B0/",
        "teaser": null
      },{
        "title": "[프로그래머스/Swift] 음양 더하기",
        "excerpt":"문제 설명     어떤 정수들이 있습니다. 이 정수들의 절댓값을 차례대로 담은 정수 배열 absolutes와 이 정수들의 부호를 차례대로 담은 불리언 배열 signs가 매개변수로 주어집니다. 실제 정수들의 합을 구하여 return 하도록 solution 함수를 완성해주세요.   문제 풀기   제한사항     absolutes의 길이는 1 이상 1,000 이하입니다.               absolutes의 모든 수는 각각 1 이상 1,000 이하입니다.           signs의 길이는 absolutes의 길이와 같습니다.               signs[i] 가 참이면 absolutes[i] 의 실제 정수가 양수임을, 그렇지 않으면 음수임을 의미합니다.           입출력 예                  absolutes       signs       result                       [4,7,12]       [true,false,true]       9                 [1,2,3]       [false,false,true]       0           입출력 예 #1     signs가 [true,false,true] 이므로, 실제 수들의 값은 각각 4, -7, 12입니다.   따라서 세 수의 합인 9를 return 해야 합니다.   입출력 예 #2     signs가 [false,false,true] 이므로, 실제 수들의 값은 각각 -1, -2, 3입니다.   따라서 세 수의 합인 0을 return 해야 합니다.   나의 풀이  import Foundation  func solution(_ absolutes:[Int], _ signs:[Bool]) -&gt; Int {     var sum: Int = 0           if absolutes.count &gt;= 1 &amp;&amp; absolutes.count &lt;= 1000 {         for i in 0...signs.count - 1 {             if signs[i] == true {                 sum += absolutes[i]             } else {                 sum -= absolutes[i]             }         }     }     return sum }  다른 사람 풀이  import Foundation  func solution(_ absolutes:[Int], _ signs:[Bool]) -&gt; Int {     return (0..&lt;absolutes.count).map { signs[$0] ? absolutes[$0] : -absolutes[$0] }.reduce(0, +) }   의견     map… reduce…  ","categories": ["Algorithm"],
        "tags": ["Algorithm","coding test","음양 더하기"],
        "url": "/algorithm/%EC%9D%8C%EC%96%91%EB%8D%94%ED%95%98%EA%B8%B0/",
        "teaser": null
      },{
        "title": "[프로그래머스/Swift] 이상한 문자 만들기",
        "excerpt":"문제 설명     문자열 s는 한 개 이상의 단어로 구성되어 있습니다. 각 단어는 하나 이상의 공백문자로 구분되어 있습니다. 각 단어의 짝수번째 알파벳은 대문자로, 홀수번째 알파벳은 소문자로 바꾼 문자열을 리턴하는 함수, solution을 완성하세요.   문제 풀기   제한사항     문자열 전체의 짝/홀수 인덱스가 아니라, 단어(공백을 기준)별로 짝/홀수 인덱스를 판단해야합니다.   첫 번째 글자는 0번째 인덱스로 보아 짝수번째 알파벳으로 처리해야 합니다.   입출력 예                  s       return                       “try hello world”       “TrY HeLlO WoRlD”           입출력 예 #1     “try hello world”는 세 단어 “try”, “hello”, “world”로 구성되어 있습니다. 각 단어의 짝수번째 문자를 대문자로, 홀수번째 문자를 소문자로 바꾸면 “TrY”, “HeLlO”, “WoRlD”입니다. 따라서 “TrY HeLlO WoRlD” 를 리턴합니다.   나의 풀이  func solution(_ s:String) -&gt; String {     var str: String = \"\"     var cnt: Int = 0          for i in s {         if cnt % 2 == 0 {             str += i.uppercased()         } else {             str += i.lowercased()         }         if i == \" \" {             cnt = 0         } else {             cnt += 1         }     }     return str }  다른 사람 풀이  import Foundation func solution(_ s:String) -&gt; String {     let a = s.components(separatedBy: \" \").map { $0.enumerated().map { $0.offset % 2 == 0 ? $0.element.uppercased() : $0.element.lowercased() } }     return a.map{ $0.map { $0 }.joined() }.joined(separator: \" \") }   의견     공감을 많이 받은 다른 사람 코드… 아직 공감이 안된다. ㅠ  ","categories": ["Algorithm"],
        "tags": ["Algorithm","coding test","이상한 문자 만들기"],
        "url": "/algorithm/%EC%9D%B4%EC%83%81%ED%95%9C%EB%AC%B8%EC%9E%90%EB%A7%8C%EB%93%A4%EA%B8%B0/",
        "teaser": null
      },{
        "title": "[프로그래머스/Swift] 자릿수 더하기",
        "excerpt":"문제 설명     자연수 N이 주어지면, N의 각 자릿수의 합을 구해서 return 하는 solution 함수를 만들어 주세요. 예를들어 N = 123이면 1 + 2 + 3 = 6을 return 하면 됩니다.   자릿수 더하기 문제 풀기   제한사항     N의 범위 : 100,000,000 이하의 자연수   입출력 예                  N       answer                       123       6                 987       24           입출력 예 #1     문제의 예시와 같습니다.   입출력 예 #2     9 + 8 + 7 = 24이므로 24를 return 하면 됩니다.   나의 풀이  import Foundation  func solution(_ n:Int) -&gt; Int {         var arr: String = String(n)      var answer:Int = 0          for index in arr {         if let i = Int(String(index)) {             answer += i          }     }          return answer }  다른 사람 풀이  import Foundation  func solution(_ n:Int) -&gt; Int {     return String(n).reduce(0, {$0+Int(String($1))!}); }   의견     고차함수쪽 공부안하고 40번까지 출었는데 앞선 문제 모두 고차함수로 간단하게 풀수 있다니 …  ","categories": ["Algorithm"],
        "tags": ["Algorithm","coding test","자릿수 더하기"],
        "url": "/algorithm/%EC%9E%90%EB%A6%BF%EC%88%98-%EB%8D%94%ED%95%98%EA%B8%B0/",
        "teaser": null
      },{
        "title": "[프로그래머스/Swift] 자연수 뒤집어 배열로 만들기",
        "excerpt":"문제 설명     자연수 n을 뒤집어 각 자리 숫자를 원소로 가지는 배열 형태로 리턴해주세요. 예를들어 n이 12345이면 [5,4,3,2,1]을 리턴합니다.   자연수 뒤집어 배열로 만들기   제한사항     n은 10,000,000,000이하인 자연수입니다.   입출력 예                  n       answer                       12345       [5,4,3,2,1]           나의 풀이  func solution(_ n:Int64) -&gt; [Int] {     var str: String = String(n)     var arr: [Int] = []           for i in str {         arr.insert(Int(String(i))!, at: 0)         }     return arr }  다른 사람 풀이  func solution(_ n:Int64) -&gt; [Int] {     return  \"\\(n)\".compactMap { $0.hexDigitValue }.reversed() }   의견     좋아요 많이 받은 다른 사람의 풀이.. 대단  ","categories": ["Algorithm"],
        "tags": ["Algorithm","coding test","자연수 뒤집어 배열로 만들기"],
        "url": "/algorithm/%EC%9E%90%EC%97%B0%EC%88%98%EB%92%A4%EC%A7%91%EC%96%B4%EB%B0%B0%EC%97%B4%EB%A1%9C%EB%A7%8C%EB%93%A4%EA%B8%B0/",
        "teaser": null
      },{
        "title": "[프로그래머스/Swift] 정수 내림차순으로 배치하기",
        "excerpt":"문제 설명     함수 solution은 정수 n을 매개변수로 입력받습니다. n의 각 자릿수를 큰것부터 작은 순으로 정렬한 새로운 정수를 리턴해주세요. 예를들어 n이 118372면 873211을 리턴하면 됩니다.   정수 내림차순으로 배치하기 문제 풀기   제한사항     n은 1이상 8000000000 이하인 자연수입니다.   입출력 예                  n       result                       118372       873211           나의 풀이  func solution(_ n:Int64) -&gt; Int64 {     var str: String = String(n)     var arr: [String] = []      var temp: String = \"\"     var num: Int64 = 0          if n &lt; 10 {         num = n     } else if n &gt;= 10 &amp;&amp; n &lt;= 8000000000 {         for i in str {             arr.append(String(i))         }          for i in 0...arr.count - 2 {             for j in i + 1...arr.count - 1 {                 if arr[i] &lt; arr[j] {                     temp = arr[i]                      arr[i] = arr[j]                      arr[j] = temp                  }             }         }         num = Int64(arr.joined(separator: \"\"))!     }     return num  }  다른 사람 풀이  func solution(_ n:Int64) -&gt; Int64 {     return Int64(String(Array(String(n)).sorted { $0 &gt; $1 }))! }   의견     고민 끝에 풀었는데 다른 사람은 한줄로 해결? ..  ","categories": ["Algorithm"],
        "tags": ["Algorithm","coding test","정수 내림차순으로 배치하기"],
        "url": "/algorithm/%EC%A0%95%EC%88%98%EB%82%B4%EB%A6%BC%EC%B0%A8%EC%88%9C%EC%9C%BC%EB%A1%9C%EB%B0%B0%EC%B9%98%ED%95%98%EA%B8%B0/",
        "teaser": null
      },{
        "title": "[프로그래머스/Swift] 정수 제곱근 판별",
        "excerpt":"문제 설명     임의의 양의 정수 n에 대해, n이 어떤 양의 정수 x의 제곱인지 아닌지 판단하려 합니다. n이 양의 정수 x의 제곱이라면 x+1의 제곱을 리턴하고, n이 양의 정수 x의 제곱이 아니라면 -1을 리턴하는 함수를 완성하세요.   정수 제곱근 판별 문제 풀기   제한사항     n은 1이상, 50000000000000 이하인 양의 정수입니다.   입출력 예                  n       result                       121       144                 3       -1           입출력 예 #1     121은 양의 정수 11의 제곱이므로, (11+1)를 제곱한 144를 리턴합니다.   입출력 예 #2     3은 양의 정수의 제곱이 아니므로, -1을 리턴합니다.   나의 풀이  func solution(_ n:Int64) -&gt; Int64 {     var num: Int64 = 0      if n &gt;= 1 &amp;&amp; n &lt;= 50000000000000 {         for i in 1...n {             if Int64(i * i) == n {                 num = Int64((i + 1) * (i + 1))                 break             } else {                 num = Int64(-1)             }         }     }     return num }  다른 사람 풀이  import Foundation func solution(_ n:Int64) -&gt; Int64 {     let t = Int64(sqrt(Double(n)))     return t * t == n ? (t+1)*(t+1) : -1 }   의견     sqrt가 제곱근 구하기.. pow가 제곱구하기..  ","categories": ["Algorithm"],
        "tags": ["Algorithm","coding test","정수 제곱근 판별"],
        "url": "/algorithm/%EC%A0%95%EC%88%98%EC%A0%9C%EA%B3%B1%EA%B7%BC%ED%8C%90%EB%B3%84/",
        "teaser": null
      },{
        "title": "[프로그래머스/Swift] 제일 작은 수 제거하기",
        "excerpt":"문제 설명     정수를 저장한 배열, arr 에서 가장 작은 수를 제거한 배열을 리턴하는 함수, solution을 완성해주세요. 단, 리턴하려는 배열이 빈 배열인 경우엔 배열에 -1을 채워 리턴하세요. 예를들어 arr이 [4,3,2,1]인 경우는 [4,3,2]를 리턴 하고, [10]면 [-1]을 리턴 합니다.   문제 풀기   제한사항     arr은 길이 1 이상인 배열입니다.   인덱스 i, j에 대해 i ≠ j이면 arr[i] ≠ arr[j] 입니다.   입출력 예                  arr       result                       [4,3,2,1]       [4,3,2]                 [10]       [-1]           나의 풀이  func solution(_ arr:[Int]) -&gt; [Int] {     var rtnArr: [Int] = []       var min: Int = arr.min()!           if arr.count == 1 {         rtnArr.append(-1)        } else {         for i in arr {             if i != min {                 rtnArr.append(i)             }         }     }     return rtnArr   }  다른 사람 풀이  func solution(_ arr:[Int]) -&gt; [Int] {     let min = arr.sorted(by: &lt;)[0]      return arr.count == 1 ? [-1] : arr.compactMap({ return $0 != min ? $0 : nil }) }   의견     나도 좀 더 쉽게 할 수 있는 방향으로..  ","categories": ["Algorithm"],
        "tags": ["Algorithm","coding test","제일 작은 수 제거하기"],
        "url": "/algorithm/%EC%A0%9C%EC%9D%BC%EC%9E%91%EC%9D%80%EC%88%98%EC%A0%9C%EA%B1%B0%ED%95%98%EA%B8%B0/",
        "teaser": null
      },{
        "title": "[프로그래머스/Swift] 직사각형 별찍기",
        "excerpt":"문제 설명     이 문제에는 표준 입력으로 두 개의 정수 n과 m이 주어집니다. 별(*) 문자를 이용해 가로의 길이가 n, 세로의 길이가 m인 직사각형 형태를 출력해보세요.   문제 풀기   제한사항     n과 m은 각각 1000 이하인 자연수입니다.   입출력 예   //입력 5 3 //출력 ***** ***** *****   나의 풀이  import Foundation var str: String = \"\"  if let input = readLine() {     let numbers = input.split(separator: \" \")     if numbers.count == 2 {         if let n = Int(numbers[0]) {             if let m = (Int(numbers[1])) {                 for i in 1...m {                     for j in 1...n {                         str += \"*\"                     }                     print(str)                     str = \"\"                  }             }         }     } }   다른 사람 풀이  import Foundation  let n = readLine()!.components(separatedBy: [\" \"]).map { Int($0)! } let (a, b) = (n[0], n[1])  for _ in 0..&lt;b {     print(Array(repeating: \"*\", count: a).joined()) }   의견     오늘도.. 다른 사람 풀이로 배웁니다.  ","categories": ["Algorithm"],
        "tags": ["Algorithm","coding test","직사각형 별찍기"],
        "url": "/algorithm/%EC%A7%81%EC%82%AC%EA%B0%81%ED%98%95%EB%B3%84%EC%B0%8D%EA%B8%B0/",
        "teaser": null
      },{
        "title": "[프로그래머스/Swift] 짝수와 홀수",
        "excerpt":"문제 설명     정수 num이 짝수일 경우 “Even”을 반환하고 홀수인 경우 “Odd”를 반환하는 함수, solution을 완성해주세요.   짝수와 홀수   제한사항     0 &lt; n ≤ 1000   입출력 예                  num       return                       3       “Odd”                 4       “Even”           나의 풀이  func solution(_ num:Int) -&gt; String {     if num % 2 == 0 {         return \"Even\"     } else {         return \"Odd\"     } }  다른 사람 풀이  func solution(_ num:Int) -&gt; String {     return num % 2 == 0 ? \"Even\" : \"Odd\" }   의견     삼항연산자로 간단하게 푼 사람들이 많았다. 문제 풀땐 생각이 잘 안난단 말이지 ..  ","categories": ["Algorithm"],
        "tags": ["Algorithm","coding test","짝수와 홀수"],
        "url": "/algorithm/%EC%A7%9D%EC%88%98%EC%99%80%ED%99%80%EC%88%98/",
        "teaser": null
      },{
        "title": "[프로그래머스/Swift] 짝수의 합",
        "excerpt":"문제 설명     정수 n이 주어질 때, n이하의 짝수를 모두 더한 값을 return 하도록 solution 함수를 작성해주세요.   짝수의 합 문제 풀기   제한사항     0 &lt; n ≤ 1000   입출력 예                  num1       num2                       10       30                 4       6           입출력 예 #1     n이 10이므로 2 + 4 + 6 + 8 + 10 = 30을 return 합니다.   입출력 예 #2     n이 4이므로 2 + 4 = 6을 return 합니다.   나의 풀이  import Foundation  func solution(_ n:Int) -&gt; Int {     var sum: Int = 0          for n in 1...n {          if (n % 2 == 0) {              sum += n         }     }         return sum }  다른 사람 풀이  import Foundation  func solution(_ n: Int) -&gt; Int { (0...n).filter { $0 % 2 == 0 }.reduce(0, +) }   의견     다른 사람들은 고차함수 사용을 많이 하였다. 난 생각도 못했는데… 고차 함수 공부가 필요하다 ㅠ  ","categories": ["Algorithm"],
        "tags": ["Algorithm","coding test","짝수의 합"],
        "url": "/algorithm/%EC%A7%9D%EC%88%98%EC%9D%98%ED%95%A9/",
        "teaser": null
      },{
        "title": "[프로그래머스/Swift] 최대공약수와 최소공배수",
        "excerpt":"문제 설명     두 수를 입력받아 두 수의 최대공약수와 최소공배수를 반환하는 함수, solution을 완성해 보세요. 배열의 맨 앞에 최대공약수, 그다음 최소공배수를 넣어 반환하면 됩니다. 예를 들어 두 수 3, 12의 최대공약수는 3, 최소공배수는 12이므로 solution(3, 12)는 [3, 12]를 반환해야 합니다.   문제 풀기   제한사항     두 수는 1이상 1000000이하의 자연수입니다.   입출력 예                  n       m       return                       3       12       [3, 12]                 2       5       [1, 10]           입출력 예 #1     문제의 설명과 같습니다.   입출력 예 #2     자연수 2와 5의 최대공약수는 1, 최소공배수는 10이므로 [1, 10]을 리턴해야 합니다.   나의 풀이  func solution(_ n:Int, _ m:Int) -&gt; [Int] {     var arr: [Int] = []     var max: Int = 0     var min: Int = 0           if n &gt; m {         max = n         min = m     } else if n &lt; m {         max = m         min = n     } else {         max = n         min = n      }              var temp: Int = 0      //작은 수로 최대공약수 구하기      for i in 1...min {         if n % i == 0 &amp;&amp; m % i == 0 {             temp = i          }     }     arr.append(temp)          //최대공약수로 나누기      temp = (n * m) / temp      arr.append(temp)          return arr }  다른 사람 풀이  func gcd(_ a: Int, _ b: Int) -&gt; Int {     let mod: Int = a % b     return 0 == mod ? min(a, b) : gcd(b, mod) }  func lcm(_ a: Int, _ b: Int) -&gt; Int {     return a * b / gcd(a, b) }  func solution(_ n:Int, _ m:Int) -&gt; [Int] {     return [gcd(n, m), lcm(n, m)] }   의견     다른 사람 코드는 역시 어렵다  ","categories": ["Algorithm"],
        "tags": ["Algorithm","coding test","최대공약수와 최소공배수"],
        "url": "/algorithm/%EC%B5%9C%EB%8C%80%EA%B3%B5%EC%95%BD%EC%88%98%EC%99%80%EC%B5%9C%EC%86%8C%EA%B3%B5%EB%B0%B0%EC%88%98/",
        "teaser": null
      },{
        "title": "[프로그래머스/Swift] 콜라츠 추측",
        "excerpt":"문제 설명     1937년 Collatz란 사람에 의해 제기된 이 추측은, 주어진 수가 1이 될 때까지 다음 작업을 반복하면, 모든 수를 1로 만들 수 있다는 추측입니다. 작업은 다음과 같습니다.   1-1. 입력된 수가 짝수라면 2로 나눕니다.   1-2. 입력된 수가 홀수라면 3을 곱하고 1을 더합니다.               결과로 나온 수에 같은 작업을 1이 될 때까지 반복합니다.           예를 들어, 주어진 수가 6이라면 6 → 3 → 10 → 5 → 16 → 8 → 4 → 2 → 1 이 되어 총 8번 만에 1이 됩니다. 위 작업을 몇 번이나 반복해야 하는지 반환하는 함수, solution을 완성해 주세요. 단, 주어진 수가 1인 경우에는 0을, 작업을 500번 반복할 때까지 1이 되지 않는다면 –1을 반환해 주세요.   문제 풀기   제한사항     입력된 수, num은 1 이상 8,000,000 미만인 정수입니다.   입출력 예                  n       result                       6       8                 16       4                 626331       -1           입출력 예 #1     문제의 설명과 같습니다.   입출력 예 #2     16 → 8 → 4 → 2 → 1 이 되어 총 4번 만에 1이 됩니다.   입출력 예 #3     626331은 500번을 시도해도 1이 되지 못하므로 -1을 리턴해야 합니다.   나의 풀이  func solution(_ num:Int) -&gt; Int {     var cnt: Int = 0     var number: Int = num           if number == 1 {         return 0      } else if number &gt; 1 &amp;&amp; number &lt; 8000000 {         while number != 1 {             if number % 2 == 0 {                 number = number / 2                 cnt += 1             } else {                 number = (number * 3) + 1                 cnt += 1              }             if cnt &gt;= 500 &amp;&amp; number != 1 {                 return -1             }         }     }          return cnt }  다른 사람 풀이  func odd(_ n: Int) -&gt; Int {     return n * 3 + 1 }  func even(_ n: Int) -&gt; Int {     return n / 2 }  func solution(_ num:Int) -&gt; Int {     var ans = num     var count = 0     while ans != 1 &amp;&amp; count &lt; 500 {         ans = ans % 2 == 0 ? even(ans) : odd(ans)         count += 1     }     return count &gt;= 500 ? -1 : count }   의견     매개변수 1일때 조건이 없어서 실행 시 바로 통과되지 않아 애먹었다 ㅠ  ","categories": ["Algorithm"],
        "tags": ["Algorithm","coding test","콜라츠 추측"],
        "url": "/algorithm/%EC%BD%9C%EB%9D%BC%EC%B8%A0%EC%B6%94%EC%B8%A1/",
        "teaser": null
      },{
        "title": "[프로그래머스/Swift] 평균 구하기",
        "excerpt":"문제 설명     정수를 담고 있는 배열 arr의 평균값을 return하는 함수, solution을 완성해보세요.   평균 구하기 문제 풀기   제한사항     arr은 길이 1 이상, 100 이하인 배열입니다.   arr의 원소는 -10,000 이상 10,000 이하인 정수입니다.   입출력 예                  arr       return                       [1,2,3,4]       2.5                 [5,5]       5           나의 풀이  func solution(_ arr:[Int]) -&gt; Double {     var sum: Int = 0          for i in arr {         sum += i     }     return Double(sum) / Double(arr.count) }  다른 사람 풀이  func solution(_ arr:[Int]) -&gt; Double {     return Double(arr.reduce(0,+))/Double(arr.count) }   의견     다른 사람들은 고차함수 사용을 많이 하였다.  ","categories": ["Algorithm"],
        "tags": ["Algorithm","coding test","평균 구하기"],
        "url": "/algorithm/%ED%8F%89%EA%B7%A0-%EA%B5%AC%ED%95%98%EA%B8%B0/",
        "teaser": null
      },{
        "title": "[프로그래머스/Swift] 하샤드 수",
        "excerpt":"문제 설명     양의 정수 x가 하샤드 수이려면 x의 자릿수의 합으로 x가 나누어져야 합니다. 예를 들어 18의 자릿수 합은 1+8=9이고, 18은 9로 나누어 떨어지므로 18은 하샤드 수입니다. 자연수 x를 입력받아 x가 하샤드 수인지 아닌지 검사하는 함수, solution을 완성해주세요.   하샤드 수   제한사항     x는 1 이상, 10000 이하인 정수입니다.   입출력 예                  x       return                       10       true                 12       true                 11       false                 13       false           입출력 예 #1     10의 모든 자릿수의 합은 1입니다. 10은 1로 나누어 떨어지므로 10은 하샤드 수입니다.   입출력 예 #2     12의 모든 자릿수의 합은 3입니다. 12는 3으로 나누어 떨어지므로 12는 하샤드 수입니다.   입출력 예 #3     11의 모든 자릿수의 합은 2입니다. 11은 2로 나누어 떨어지지 않으므로 11는 하샤드 수가 아닙니다.   입출력 예 #4     13의 모든 자릿수의 합은 4입니다. 13은 4로 나누어 떨어지지 않으므로 13은 하샤드 수가 아닙니다.   나의 풀이  func solution(_ x:Int) -&gt; Bool {     var num: String = String(x)      var sum: Int = 0      var flag = false           if x &gt;= 1 &amp;&amp; x &lt;= 10000 {          for i in num {             sum += Int(String(i))!          }          if x % sum == 0 {             flag = true          } else {              flag = false         }     }     return flag }  다른 사람 풀이  func solution(_ x:Int) -&gt; Bool {     return x % String(x).reduce(0, {$0+Int(String($1))!}) == 0 }   의견     고차함수..  ","categories": ["Algorithm"],
        "tags": ["Algorithm","coding test","하샤드 수"],
        "url": "/algorithm/%ED%95%98%EC%83%A4%EB%93%9C%EC%88%98/",
        "teaser": null
      },{
        "title": "[프로그래머스/Swift] 핸드폰 번호 가리기",
        "excerpt":"문제 설명     프로그래머스 모바일은 개인정보 보호를 위해 고지서를 보낼 때 고객들의 전화번호의 일부를 가립니다. 전화번호가 문자열 phone_number로 주어졌을 때, 전화번호의 뒷 4자리를 제외한 나머지 숫자를 전부 *으로 가린 문자열을 리턴하는 함수, solution을 완성해주세요.   문제 풀기   제한사항     phone_number는 길이 4 이상, 20이하인 문자열입니다.   입출력 예                  phone_number       return                       “01033334444”       “***4444”                 “027778888”       “*****8888”           나의 풀이  func solution(_ phone_number:String) -&gt; String {     var arr: [String] = []     var num: String = \"\"           if phone_number.count &gt;= 4 &amp;&amp; phone_number.count &lt;= 20 {         for i in phone_number {             arr.append(String(i))         }                 if arr.count &gt; 4 {              for i in 0...arr.count - 1 {                 if i &lt; arr.count - 4 {                     num += \"*\"                 } else {                     num += arr[i]                 }             }         } else {             num = phone_number         }     }         return num }  다른 사람 풀이  func solution(_ phone_number:String) -&gt; String {     return String(\"\\(String(repeating: \"*\", count: phone_number.count - 4))\\(phone_number.suffix(4))\") }   의견     suffix.. 다양한 함수가 있네  ","categories": ["Algorithm"],
        "tags": ["Algorithm","coding test","핸드폰 번호 가리기"],
        "url": "/algorithm/%ED%95%B8%EB%93%9C%ED%8F%B0%EB%B2%88%ED%98%B8%EA%B0%80%EB%A6%AC%EA%B8%B0/",
        "teaser": null
      },{
        "title": "[프로그래머스/Swift] 행렬의 덧셈",
        "excerpt":"문제 설명     행렬의 덧셈은 행과 열의 크기가 같은 두 행렬의 같은 행, 같은 열의 값을 서로 더한 결과가 됩니다. 2개의 행렬 arr1과 arr2를 입력받아, 행렬 덧셈의 결과를 반환하는 함수, solution을 완성해주세요.   문제 풀기   제한사항     행렬 arr1, arr2의 행과 열의 길이는 500을 넘지 않습니다.   입출력 예                  arr1       arr2       return                       [[1,2],[2,3]]       [[3,4],[5,6]]       [[4,6],[7,9]]                 [[1],[2]]       [[3],[4]]       [[4],[6]]           나의 풀이  func solution(_ arr1:[[Int]], _ arr2:[[Int]]) -&gt; [[Int]] {     var arr: [[Int]] = []           for i in 0...arr1.count - 1 {         arr.append([])         for j in 0...arr1[i].count - 1 {             arr[i].append(arr1[i][j] + arr2[i][j])         }     }          return arr }  다른 사람 풀이  import Foundation  func solution(_ arr1:[[Int]], _ arr2:[[Int]]) -&gt; [[Int]] {     return zip(arr1, arr2).map{zip($0,$1).map{$0+$1}} }   의견     이차원배열 출력, 다른 사람들처럼 문법에 조금 더 익숙해져야할듯.  ","categories": ["Algorithm"],
        "tags": ["Algorithm","coding test","행렬의 덧셈"],
        "url": "/algorithm/%ED%96%89%EB%A0%AC%EC%9D%98%EB%8D%A7%EC%85%88/",
        "teaser": null
      },{
        "title": "[TIL] 내배캠 iOS앱 개발 공부 8일차",
        "excerpt":"데일리 스크럼     알고리즘  오늘 오전에는 그동안 아침에 풀었던 알고리즘 문제와 나의 풀이, 다른사람의 풀이를 정리해서 포스팅했다. 내가 했던 풀이 다시 보면서 다른 사람들 풀이를 다시 보는데 너무 짧고 쉽게 푼 사람들이 많더라 공부 시급 😭   협업 관련  Git &amp; Github으로 협업하는 법 특강을 들었다.  블로그 때문에 git add. / git commit -m “커밋내용” / git push는 확실히 익숙해졌다.  3번 반복 학습하라고 하셨는데 실습하면서 하나씩 해봐야겠다.. 당장 xcode 프로젝트 github에 올리기도 잘 안되더라…   개인 과제  개인 과제를 마무리 했다. 3번 addOperation.cal(10, 20) 출력이 안되서 튜터님께 도움 요청했는데 문법적으로 문제 없는 것 같은데 실행이 안되서 이것 저것 해보다가 상속없이 다시 수정해서 제출했다.     내일은?  강의 복습하면서 문법 공부와 깃 사용 관련 공부 예정 !!  !!  ","categories": ["TIL"],
        "tags": ["TIL"],
        "url": "/TIL/til8/",
        "teaser": null
      },{
        "title": "[프로그래머스/Swift] 삼총사",
        "excerpt":"문제 설명     한국중학교에 다니는 학생들은 각자 정수 번호를 갖고 있습니다. 이 학교 학생 3명의 정수 번호를 더했을 때 0이 되면 3명의 학생은 삼총사라고 합니다. 예를 들어, 5명의 학생이 있고, 각각의 정수 번호가 순서대로 -2, 3, 0, 2, -5일 때, 첫 번째, 세 번째, 네 번째 학생의 정수 번호를 더하면 0이므로 세 학생은 삼총사입니다. 또한, 두 번째, 네 번째, 다섯 번째 학생의 정수 번호를 더해도 0이므로 세 학생도 삼총사입니다. 따라서 이 경우 한국중학교에서는 두 가지 방법으로 삼총사를 만들 수 있습니다.   한국중학교 학생들의 번호를 나타내는 정수 배열 number가 매개변수로 주어질 때, 학생들 중 삼총사를 만들 수 있는 방법의 수를 return 하도록 solution 함수를 완성하세요.     문제 풀기   제한사항     3 ≤ number의 길이 ≤ 13   -1,000 ≤ number의 각 원소 ≤ 1,000   서로 다른 학생의 정수 번호가 같을 수 있습니다.   입출력 예                  number       result                       [-2, 3, 0, 2, -5]       2                 [-3, -2, -1, 0, 1, 2, 3]       5                 [-1, 1, -1, 1]       0           입출력 예 #1     문제 예시와 같습니다.   입출력 예 #2     학생들의 정수 번호 쌍 (-3, 0, 3), (-2, 0, 2), (-1, 0, 1), (-2, -1, 3), (-3, 1, 2) 이 삼총사가 될 수 있으므로, 5를 return 합니다.   입출력 예 #3     삼총사가 될 수 있는 방법이 없습니다.   나의 풀이  import Foundation  func solution(_ number:[Int]) -&gt; Int {     var cnt: Int = 0          for i in 0...number.count - 3 {         print(\"number[i]: \\(number[i])\")         for j in i + 1...number.count - 2 {             print(\"----number[jj]: \\(number[j])\")             for k in j + 1...number.count - 1 {                 print(\"--------number[k]: \\(number[k])\")                 if number[i] + number[j] + number[k] == 0 {                     cnt += 1                 }             }         }     }     return cnt }  다른 사람 풀이  import Foundation  func solution(_ number:[Int]) -&gt; Int {     var ans = 0      for i in 0..&lt;number.count {         for j in i+1..&lt;number.count {             for z in j+1..&lt;number.count {                 if number[i] + number[j] + number[z] == 0 { ans += 1 }             }         }     }     return ans }   의견     for 문을 2개써야하나 하다가.. 종이로 써보고 3개로 수정했다. 나는 숫자 3개 때문에 범위를 수정했는데 다른 사람은 수정하지 않았다. 반복 횟수를 배열만큼 해도 if문까지 오지 않으니 … 다른 사람 코드를 보면서 반복 횟수에 대해서 다시 생각해보았다.  ","categories": ["Algorithm"],
        "tags": ["Algorithm","coding test","삼총사"],
        "url": "/algorithm/%EC%82%BC%EC%B4%9D%EC%82%AC/",
        "teaser": null
      },{
        "title": "[minimal-mistakes]조회수 추가하기 ",
        "excerpt":"깃허브 블로그는 댓글, 포스팅 개수, 조회수까지 하나씩 등록해줘야하는데요. 이번에는 많은 깃허브 블로그에서 사용하는 Hits를 추가했습니다.  hits에서 새로고침이 되었는지 알려주는 API를 제공합니다.   1. hits API 커스터마이징  hits에서는 기본 badge를 변경할 수 없어 https://hits.seeyoufarm.com/에 접속하셔서 TARGET URL을 입력하시고 원하는 색상 등 옵션을 선택합니다. 저는 색상만 통일했습니다.     2. HTML Link 복사하기     3. 메인 상단에 추가  저는 페이지 상단에 추가하였습니다. _includes/head 폴더의 customs.html 파일입니다.  페이지 하단에 추가하시려면 _includes/footer 폴더의 customs.html 파일을 수정하시면 됩니다.     &lt;!-- 방문자 수 추가 --&gt; &lt;div style=\"text-align: right;\"&gt;     &lt;a href=\"https://hits.seeyoufarm.com\"&gt;         &lt;img src=\"https://hits.seeyoufarm.com/api/count/incr/badge.svg?url=https%3A%2F%2Flimlogging.github.io&amp;count_bg=%23555555&amp;title_bg=%23555555&amp;icon=&amp;icon_color=%23E7E7E7&amp;title=hits&amp;edge_flat=false\"/&gt;     &lt;/a&gt; &lt;/div&gt;   4. 포스트 상단에 추가  _layouts 폴더에 있는 single.html 파일을 수정합니다.  3번의 코드는 github id가 포함되어있지만 포스트 상단에 추가하는 코드는 id가 변수로 대체되어 그냥 복사 붙여넣기 하시면 됩니다.    &lt;!-- 포스팅 조회수 추가 --&gt; &lt;div style=\"text-align: right;\"&gt; &lt;a href=\"https://hits.seeyoufarm.com/localhost:4000/GitHubBlog/hits/\"target=\"_blank\"&gt;     &lt;img src=\"https://hits.seeyoufarm.com/api/count/incr/badge.svg?url=https://localhost:4000/GitHubBlog/hits/&amp;count_bg=%23555555&amp;title_bg=%23555555&amp;icon=&amp;icon_color=%23E7E7E7&amp;title=hits&amp;edge_flat=false\"/&gt; &lt;/a&gt; &lt;/div&gt;   5. 확인  메인페이지와 포스트 상단에 추가가 된 것을 확인 하실 수 있습니다.   ","categories": ["GitHubBlog"],
        "tags": ["GitHub","blog","GitHub blog","hits","조회수"],
        "url": "/GitHubBlog/hits/",
        "teaser": null
      },{
        "title": "[TIL] 내배캠 iOS앱 개발 공부 9일차",
        "excerpt":"데일리 스크럼     알고리즘  오늘 알고리즘은 for문을 3번 중첩하여 조금은 빨리 풀었다. 다른 사람도 풀이가 비슷했는데 반복 범위가 달라서 해당 부분은 고민해볼 수 있었다.   블로그 조회수 추가 (새로고침 추가)  화요일 저녁에 팀원 블로그 댓글 남기기 미션이 있어 화요일 오전에 댓글 기능을 급하게 추가하고 그 뒤로 포스팅 수 추가까지 했다. 오늘은 조회수 기능을 추가하고 포스팅하였다. 다음 주에는 구글 애드센스에 도전해볼 예정     개인 과제 해설 공부  개인 과제해설 영상을 보면서 객체지향 프로그래밍의 원칙 중 가장 유명한 SOLID 원칙을 알게 되었다. 해당 원칙에 대한 공부는 못했지만 우선 메모해두고 꼭 다시 찾아보는걸로!!      단일 책임 원칙 (Single Responsibility Principle - SRP)   개방-폐쇄 원칙 (Open/Closed Principle - OCP)   리스코프 치환 원칙 (Liskov Substitution Principle - LSP)   인터페이스 분리 원칙 (Interface Segregation Principle - ISP)   의존성 역전 원칙 (Dependency Inversion Principle - DIP)   클로저  원래 깃 관련 공부를 하려고 했는데 알고리즘 문제 풀다보니 클로저, 고차함수 등 내용 공부가 필요하여 그중에서 클로저 공부를 하였다. 클로저는 함수이고 일급객체… 정리중인데 정리도 시간이 오래 걸린다. 정리하면 포스팅할 예정!   내일은?  12시간씩 하는데 공부도 하고 블로그도 쓰고 하다보면 어느새 TIL 작성시간 🤦🏻 시간이 모자라다 ? ? ? ? ? 내일은 주말이니까 .. 조금 쉬면서 체력 회복해야겠다. 깃 공부는 다음주에 다시 !  ","categories": ["TIL"],
        "tags": ["TIL"],
        "url": "/TIL/til9/",
        "teaser": null
      },{
        "title": "[프로그래머스/Swift] 크기가 작은 부분 문자열",
        "excerpt":"문제 설명     숫자로 이루어진 문자열 t와 p가 주어질 때, t에서 p와 길이가 같은 부분문자열 중에서, 이 부분문자열이 나타내는 수가 p가 나타내는 수보다 작거나 같은 것이 나오는 횟수를 return하는 함수 solution을 완성하세요.   예를 들어, t=”3141592”이고 p=”271” 인 경우, t의 길이가 3인 부분 문자열은 314, 141, 415, 159, 592입니다. 이 문자열이 나타내는 수 중 271보다 작거나 같은 수는 141, 159 2개 입니다.   문제 풀기   제한사항     1 ≤ p의 길이 ≤ 18   p의 길이 ≤ t의 길이 ≤ 10,000   t와 p는 숫자로만 이루어진 문자열이며, 0으로 시작하지 않습니다.   입출력 예                  t       p       result                       “3141592”       “271”       2                 “500220839878”       “7”       8                 “10203”       “15”       3           입출력 예 #1     문제 예시와 같습니다.   입출력 예 #2     p의 길이가 1이므로 t의 부분문자열은 “5”, “0”, 0”, “2”, “2”, “0”, “8”, “3”, “9”, “8”, “7”, “8”이며 이중 7보다 작거나 같은 숫자는 “5”, “0”, “0”, “2”, “2”, “0”, “3”, “7” 이렇게 8개가 있습니다.   입출력 예 #3     p의 길이가 2이므로 t의 부분문자열은 “10”, “02”, “20”, “03”이며, 이중 15보다 작거나 같은 숫자는 “10”, “02”, “03” 이렇게 3개입니다. “02”와 “03”은 각각 2, 3에 해당한다는 점에 주의하세요   나의 풀이  import Foundation  func solution(_ t:String, _ p:String) -&gt; Int {     var cnt: Int = 0      var temp: String = \"\"      var arr: [String] = []           //배열 변환      for i in t {         arr.append(String(i))     }          for i in 0...arr.count - p.count {         temp = arr[i]          if p.count == 1 {             if Int(temp)! &lt;= Int(p)! {                 cnt += 1             }         } else {             for j in i + 1...arr.count - 1{                 temp += arr[j]                                  //길이가 같으면 숫자 비교                  if temp.count == p.count {                     if Int(temp)! &lt;= Int(p)! {                         cnt += 1                     }                     break                 }             }         }            }     return cnt  }  다른 사람 풀이  import Foundation  func solution(_ t:String, _ p:String) -&gt; Int {     var answer = 0      for i in 0 ... t.count - p.count {         let subStr = t.dropFirst(i).prefix(p.count)         if let comp = Int(subStr), let val = Int(p) {             answer += comp - val &lt;= 0 ? 1 : 0         }     }      return answer }   의견     주말에 고차함수 공부를 해서 고차함수를 사용하여 문제를 풀어보려고했는데 아직 내공이 부족한 것 같다. 기본 제공하는 함수를 많이 사용해봐야할듯…  ","categories": ["Algorithm"],
        "tags": ["Algorithm","coding test","크기가 작은 부분 문자열"],
        "url": "/algorithm/%ED%81%AC%EA%B8%B0%EA%B0%80%EC%9E%91%EC%9D%80%EB%B6%80%EB%B6%84%EB%AC%B8%EC%9E%90%EC%97%B4/",
        "teaser": null
      },{
        "title": "[Swift] 프로퍼티와 옵저버",
        "excerpt":"프로퍼티와 옵저버     클래스 / 구조체            변수 -&gt; 속성(property)                    저장(stored) 속성, 지연(lazy) 저장 속성           계산(computed) 속성           타입(type) 속성           속성 감시자(property observer)                       함수 -&gt; 메서드(method)                    인스턴스 메서드(instance method)           타입 메서드(type method)           서브스크립트(subscripts)           생성자                            지정생성자(designated)               편의생성자(convenience) - 클래스만               필수생성자(required) - 클래스만               실패가능생성자(failable)                                   소멸자(deinitializer)                           변수에 프로퍼티 옵저버를 정의하여 프로퍼티 값의 변경 사항을 모니터링하고, 미리 구현한 코드로 이에 대응할 수 있습니다.   다시 말하면 해당 프로퍼티를 관찰(observe)하면서 변경 사항이 발생할 때 실행됩니다   willSet보다는 didSet이 많이 사용됩니다   willSet과 didSet을 둘 다 작성했을 경우 willSet이 먼저 실행됩니다   추가할 수있는 경우            저장 프로퍼티(stored property)       연산 프로퍼티(computed property)           didSet     didSet은 새 값이 저장된 직후에 호출됩니다.   이전 프로퍼티의 값이 oldValue 로 제공됩니다.   willSet     willSet은 값이 저장되기 직전에 호출됩니다.   새로운 프로퍼티의 값이 newValue 로 제공됩니다.   예시 코드 1   var myProperty: Int = 20{    didSet(oldVal){       //myProperty의 값이 변경된 직후에 호출, oldVal은 변경 전 myProperty의 값    }    willSet(newVal){       //myProperty의 값이 변경되기 직전에 호출, newVal은 변경 될 새로운 값    } }  var name: String = \"Unknown\" {     willSet {         print(\"현재 이름 = \\(name), 바뀔 이름 = \\(newValue)\")     }     didSet {         print(\"현재 이름 = \\(name), 바뀌기 전 이름 = \\(oldValue)\")     } }  name = \"Peter\" // willSet이 먼저 실행됨 // 현재 이름 = Unknown, 바뀔 이름 = Peter // 현재 이름 = Peter, 바뀌기 전 이름 = Unknown  예시코드 2  class UserAccount {     var username: String     var password: String     var loginAttempts: Int = 0 {         didSet {             if loginAttempts &gt;= 3 {                 print(\"로그인 시도가 3회 이상 실패하였습니다. 계정이 잠겼습니다.\")                 lockAccount()             }         }     }          var isLocked: Bool = false {         didSet {             if isLocked {                 print(\"계정이 잠겼습니다.\")             } else {                 print(\"계정이 잠금 해제되었습니다.\")             }         }     }          init(username: String, password: String) {         self.username = username         self.password = password     }          func login(with enteredPassword: String) {         if enteredPassword == password {             print(\"로그인 성공!\")             loginAttempts = 0 // 로그인 성공 시 로그인 시도 횟수 초기화         } else {             print(\"잘못된 비밀번호입니다.\")             loginAttempts += 1 // 로그인 실패 시 로그인 시도 횟수 증가         }     }          private func lockAccount() {         isLocked = true     }          func unlockAccount() {         isLocked = false     } }  // 사용자 계정 생성 let user = UserAccount(username: \"user123\", password: \"password123\")  // 로그인 시도 user.login(with: \"wrongpassword\")  // 출력: // 잘못된 비밀번호입니다.  user.login(with: \"wrongpassword\")  // 출력: // 잘못된 비밀번호입니다.  user.login(with: \"wrongpassword\")  // 출력: // 잘못된 비밀번호입니다. // 로그인 시도가 3회 이상 실패하였습니다. 계정이 잠겼습니다. // 계정이 잠겼습니다.  // 계정 잠금 해제 user.unlockAccount() // 계정이 잠금 해제되었습니다.  ","categories": ["swift"],
        "tags": ["swift","프로퍼티","옵저버","Property","Observer"],
        "url": "/swift/%ED%94%84%EB%A1%9C%ED%8D%BC%ED%8B%B0%EC%99%80%EC%98%B5%EC%A0%80%EB%B2%84/",
        "teaser": null
      },{
        "title": "[Swift] 타입 캐스팅",
        "excerpt":"타입 캐스팅     인스턴스의 “타입”을 확인 하거나, 해당 인스턴스를 슈퍼 클래스(부모 클래스)나 하위 클래스(자식 클래스)로 취급하는 방법   is (type check operator)     is 연산자는 타입을 체크하는 연산자로, 비교 결과를 bool 타입을 반환합니다.(타입 체킹)   예시 코드   let char: Character = \"A\"   print(char is Character) // 출력값: true print(char is String)    // 출력값: false   let bool: Bool = true  print(bool is Bool)      // 출력값: true print(bool is Character) // 출력값: false   업캐스팅 (Upcasting)     하위클래스의 메모리구조로 저장된 인스턴스를 상위클래스 타입으로 캐스팅   as     사용: 인스턴스 as 타입   as 연산자는 컴파일 단계에서 캐스팅이 실행됩니다. 따라서 항상 타입 캐스팅이 성공할 경우에만 사용할 수 있습니다.   캐스팅에 실패할 경우 에러가 발생합니다.   캐스팅하려는 타입이 같은 타입 이거나 수퍼클래스 타입이라는 것을 알 때 as 연사자를 사용합니다.   다운캐스팅 (DownCasting)     실패 가능성이 있음   사용: 인스턴스 as? 타입 / 인스턴스 as! 타입   as? (옵셔널 타입 캐스팅)     as? 연산자는 런타임에 캐스팅이 실행됩니다.   성공하면 옵셔널 타입의 인스턴스를 반환하고 실패하면 nil 을 반환합니다.   실패할 가능성이 있으면 as?를 사용하는 것이 좋습니다.   as! (강제 타입 캐스팅)     as! 연산자는 런타임에 특정 타입으로 강제 캐스팅합니다.   강제 타입 캐스팅에 실패할 경우 런타임 에러가 발생할 수 있습니다.   캐스팅에 성공한 경우 인스턴스를 반환합니다.(옵셔널 x)   예시 코드  class Person {     var id = 0     var name = \"name\"     var email = \"hgk@gmail.com\" }  class Worker: Person {     // id     // name     // email     var salary = 300 }  class Programmer: Worker {     // id     // name     // email     // salary     var lang = \"Swift\" }   // 업캐스팅 - as let person1 = Person() let worker1 = Worker() let programmer1 = Programmer()  let personList = [person1, worker1, programmer1] // 타입을 선언하지 않았지만 Person 타입으로 인식 -&gt; 즉 업캐스팅이 되었음 personList[1].name //personList[1].salary // Person 타입으로 보고 있기 때문에 salary에 접근하지 못함  let worker2 = Worker() worker2.salary  let workerPerson = worker2 as Person //workerPerson.salary // Person 타입으로 보고 있기 때문에 salary에 접근하지 못함   // 다운캐스팅 - as? / as! // as? let pro = programmer1 as? Programmer // 타입 변환이 될 수도 있고 안될 수도 있기 때문에 옵셔널을 리턴  if let person2 = programmer1 as? Programmer {     person2.lang }  if let person3 = worker1 as? Programmer {     person3.lang }  // as! let pro2 = worker2 as! Programmer // Error : 타입 변환 실패시 오류  ","categories": ["swift"],
        "tags": ["swift","타입 캐스팅","Type Casting"],
        "url": "/swift/%ED%94%84%EB%A1%9C%ED%8D%BC%ED%8B%B0%EC%99%80%EC%98%B5%EC%A0%80%EB%B2%84/",
        "teaser": null
      },{
        "title": "[TIL] 내배캠 iOS앱 개발 공부 10일차",
        "excerpt":"데일리 스크럼     알고리즘  주말에 야곰님 책으로 클로저와 고차함수 공부를 했다. 오늘 오전에 알고리즘 문제에 응용할 수 있을지 고민했는데 사용하지 못했다. 다른 사람 풀이를 보니 Swift가 제공하는 문자열 함수를 사용하여 풀었더라. 조금씩 함수형 프로그래밍을 생각하며 익숙해져야겠다.   깃 허브 강의 다시 듣기  브랜치 생성, 목록 보기, 이동, 명령어를 통한 합치기, Github에서 합치기 등 기본 내용을 다시 숙지했다. 이번주 개인 과제 업로드 할때 배운 내용을 써먹어볼 예정!   클로저  지난 주 금요일에 공부했던 클로저를 정리하면서 블로그에 올릴 준비를 하는데 생각보다 깔끔하게 정리하는게 어려운 것 같다. 다시 큰 주제를 생각하고 구체화시켜 작성해봐야겠다. 잘 쓰려고 고집부린건 아닌데 어려운 것 같다.   내일은?  오늘 공개된 강의를 하나밖에 못들어서 강의를 마저 듣고 블로그 작성할 예정. 강의는 들었으나 정리된 내용이 부족한 것 같다.  ","categories": ["TIL"],
        "tags": ["TIL"],
        "url": "/TIL/til10/",
        "teaser": null
      },{
        "title": "[프로그래머스/Swift] 최소직사각형",
        "excerpt":"문제 설명     명함 지갑을 만드는 회사에서 지갑의 크기를 정하려고 합니다. 다양한 모양과 크기의 명함들을 모두 수납할 수 있으면서, 작아서 들고 다니기 편한 지갑을 만들어야 합니다. 이러한 요건을 만족하는 지갑을 만들기 위해 디자인팀은 모든 명함의 가로 길이와 세로 길이를 조사했습니다.   아래 표는 4가지 명함의 가로 길이와 세로 길이를 나타냅니다.                  명함 번호       가로 길이       세로 길이                       1       60       50                 2       30       70                 3       60       30                 4       80       40              가장 긴 가로 길이와 세로 길이가 각각 80, 70이기 때문에 80(가로) x 70(세로) 크기의 지갑을 만들면 모든 명함들을 수납할 수 있습니다. 하지만 2번 명함을 가로로 눕혀 수납한다면 80(가로) x 50(세로) 크기의 지갑으로 모든 명함들을 수납할 수 있습니다. 이때의 지갑 크기는 4000(=80 x 50)입니다.   모든 명함의 가로 길이와 세로 길이를 나타내는 2차원 배열 sizes가 매개변수로 주어집니다. 모든 명함을 수납할 수 있는 가장 작은 지갑을 만들 때, 지갑의 크기를 return 하도록 solution 함수를 완성해주세요.   문제 풀기   제한사항     sizes의 길이는 1 이상 10,000 이하입니다.            sizes의 원소는 [w, h] 형식입니다.       w는 명함의 가로 길이를 나타냅니다.       h는 명함의 세로 길이를 나타냅니다.       w와 h는 1 이상 1,000 이하인 자연수입니다.           입출력 예                  sizes       result                       [[60, 50], [30, 70], [60, 30], [80, 40]]       4000                 [[10, 7], [12, 3], [8, 15], [14, 7], [5, 15]]       120                 [[14, 4], [19, 6], [6, 16], [18, 7], [7, 11]]       133           입출력 예 #1     문제 예시와 같습니다.   입출력 예 #2     명함들을 적절히 회전시켜 겹쳤을 때, 3번째 명함(가로: 8, 세로: 15)이 다른 모든 명함보다 크기가 큽니다. 따라서 지갑의 크기는 3번째 명함의 크기와 같으며, 120(=8 x 15)을 return 합니다.   입출력 예 #3     명함들을 적절히 회전시켜 겹쳤을 때, 모든 명함을 포함하는 가장 작은 지갑의 크기는 133(=19 x 7)입니다.   나의 풀이  import Foundation  func solution(_ sizes:[[Int]]) -&gt; Int {     var firstNum: Int = 0     var secondNum: Int = 0          for i in sizes {         //정렬해서 각 자리수에서 가장 큰 값 구하기         if firstNum &lt;= i.sorted()[0] {             firstNum = i.sorted()[0]         }         if secondNum &lt;= i.sorted()[1] {             secondNum = i.sorted()[1]         }     }          return firstNum * secondNum }  다른 사람 풀이  import Foundation func solution(_ sizes:[[Int]]) -&gt; Int {     var maxNum = 0     var minNum = 0      for size in sizes {         maxNum = max(maxNum, size.max()!)         minNum = max(minNum, size.min()!)     }     return maxNum * minNum }   의견     이번에는 무작정 for문을 사용한 정렬 아닌 sort함수를 써서 풀었다. 다른 사람 코드도 큰 풀이방법은 비슷한데 사용하는 함수가 달랐다. 다른 사람의 풀이도 자주보면서 내것으로 만들 수 있도록 해야겠다.  ","categories": ["Algorithm"],
        "tags": ["Algorithm","coding test","최소직사각형"],
        "url": "/algorithm/%EC%B5%9C%EC%86%8C%EC%A7%81%EC%82%AC%EA%B0%81%ED%98%95/",
        "teaser": null
      },{
        "title": "[Swift] 클로저(Closure)",
        "excerpt":"1. 클로저란?     일정 기능을 하는 코드를 하나의 블록(중괄호)으로 모아놓은 것을 말합니다.   함수는 클로저의 한 형태입니다. (이름 없는 함수입니다.)   클로저는 변수나 상수가 선언된 위치에서 참조를 획득하고 저장할 수 있습니다. 이를 변수나 상수의 클로징(잠금)이라고 하며 클로저는 여기서 착안된 이름입니다.         2. 클로저는 일급 객체 (First-class object)  1급 객체란 다음 세 가지 조건을 만족하는 객체를 가리킵니다.     변수나 데이터 구조 안에 담을 수 있어야 합니다.     func sayHello() -&gt; Void {  print(\"Hello!\") } //변수에 할당  let myFunction = sayHello myFunction() // \"Hello!\"를 출력합니다.           파라미터로 전달할 수 있어야 합니다.     func sayHello() -&gt; Void {  print(\"Hello!\") } func performAction(action: () -&gt; Void) {  action() } //다른 함수의 인자로 전달 performAction(action: sayHello) // \"Hello!\"를 출력합니다.           함수에서 반환값으로 사용할 수 있어야 합니다.     func sayHello() -&gt; Void {  print(\"Hello!\") } func createGreetingFunction() -&gt; () -&gt; Void {  //함수의 반환값으로 사용  return sayHello } let greetingFunction = createGreetingFunction() greetingFunction() // \"Hello!\"를 출력합니다.               3. 클로저 사용 이유     코드 간결성            클로저를 사용하면 간단한 작업을 짧은 문법으로 처리할 수 있습니다. 특히 함수형 프로그래밍 스타일을 채택한 경우에는 더욱 간결한 코드를 작성할 수 있습니다.           유연성            클로저를 사용하면 함수를 변수나 상수에 할당하거나, 함수의 인자로 전달할 수 있습니다. 이는 함수를 다른 함수의 인자로 전달하거나 함수를 반환하는 고차 함수를 구현하는 데 유용합니다.           캡처링            클로저는 자신을 둘러싼 범위에 있는 변수나 상수를 캡처할 수 있습니다. 이는 클로저가 생성된 시점의 상태를 유지하거나 변경할 수 있게 해줍니다.           비동기 작업            비동기 작업을 처리할 때 클로저를 사용하면 코드를 간결하게 작성할 수 있습니다. 주로 Grand Central Dispatch (GCD)나 Operation Queue와 함께 사용되어 비동기 작업을 처리합니다.           콜백 함수            주로 이벤트 처리나 네트워크 요청과 같은 비동기 작업에서 콜백 함수로 활용됩니다. 클로저를 사용하여 이러한 작업을 처리하면 코드의 일관성을 유지하면서도 비동기적인 작업을 처리할 수 있습니다.           컬렉션의 변형            Swift에서는 클로저를 사용하여 배열이나 딕셔너리 등의 컬렉션을 변형하는 메서드에 전달할 수 있습니다. 이를 통해 컬렉션을 필터링, 매핑, 정렬하는 등의 작업을 수행할 수 있습니다.               4. 클로저의 형태  //클로저의 형태 { (&lt;#parameters#&gt;) -&gt; &lt;#return type#&gt; in     &lt;#statements#&gt; }   클로저 형태 예시   let closure = { (name: String) -&gt; String in      return \"Hello \\(name)\" } print(closure(\"철수\")) //출력: Hello 철수   //컴파일러가 타입 추론 가능한 경우 리턴형에 대한 표기를 생략 가능  //Hello + 이름으로 문자열로 리턴하기 때문에 타입 추론 가능하여 String 생략  let closure = { (name: String) in      return \"Hello \\(name)\" } print(closure(\"철수\")) //출력: Hello 철수   // 컴파일러가 타입 추론 가능한 경우 생략 가능 let closure = { name in     return \"Hello ~ \" + name } print(closure(\"철수\"))  //출력: Hello ~ 철수  //void 생략 //let closure = { () -&gt; () in let closure {}     print(\"Hello 클로저\") } closure()   //출력: Hello 클로저       5. 함수를 클로저로 변경  //함수의 형태  func nameFunction(str: String) -&gt; String {     return \"Hello, \\(str)\" } print(nameFunction(str: \"imhs\"))   //출력: Hello, imhs  // 클로저로 변경 (nameFunction 함수를 클로저로 변경) //name 변수에 함수를 담을 수 있음  var name = {(str: String) -&gt; String in     return \"Hello, \\(str)\" } print(name(\"imhs\")) //출력: Hello, imhs       6. 문법 최적화(간소화)  //함수 정의 func closureFunction(closure: (String) -&gt; Int) {     closure(\"swift\") }  타입 추론(Type Inference)  closureFunction(closure: { (str: String) in     return str.count }) closureFunction(closure: { str in     return str.count })  싱글 익스프레션인 경우(한줄), 리턴을 생략 가능 (Implicit Return)  closureFunction(closure: { str in     str.count })   아규먼트 이름 축약(Shorthand Argements)  closureFunction(closure: {      $0.count })   트레일링(Trailing) 클로저 문법(후행 클로저 문법)     함수의 마지막 전달 인자(Argements)로 클로저 전달되는 경우, 소괄호를 생략 가능   closureFunction(closure: {     $0.count }) closureFunction() {     $0.count } closureFunction { $0.count }   트레일링 클로저 예시  //1. 클로저를 파라미터로 받는 함수 정의 func closureFunction(closure: () -&gt; Void) {     print(\"함수 시작\")     closure() } //2. 함수를 실행할때 마지막 전달 인자를 클로저 형태로 전달(소괄호를 생략 가능) closureFunction(closure: {     print(\"함수 종료\") }) closureFunction(closure: ) {      // 소괄호를 앞으로 가져오기     print(\"함수 종료\") } closureFunction() {               // 아규먼트 생략가능     print(\"함수 종료\") } // 소괄호 생략  closureFunction { //함수를 실행하고 마지막 아규먼트로 클로저를 전달했다는걸 익숙해지기      print(\"함수 종료\") }       7. 캡처 현상  값(value) 캡처     클로저가 변수나 상수의 값을 캡처합니다. 이때, 클로저 내부에서 캡처한 값이 변경되어도 원본 값은 변경되지 않습니다.   func makeIncrementer(forIncrement amount: Int) -&gt; () -&gt; Int {     var total = 0          // 클로저를 반환합니다.     let incrementer: () -&gt; Int = {         // total 변수를 캡처하여 저장합니다.         total += amount         return total     }          return incrementer } let incrementByTen = makeIncrementer(forIncrement: 10) print(incrementByTen()) // total = 10, 결과: 10 print(incrementByTen()) // total = 20, 결과: 20   참조(reference) 캡처     클로저가 변수나 상수의 참조를 캡처합니다. 따라서 클로저 내에서 해당 변수나 상수를 변경하면 원본 값도 변경됩니다.   class SimpleClass {     var value: Int = 10 } func createClosure() -&gt; (() -&gt; Int) {     let instance = SimpleClass()          // 참조 캡처를 사용하여 SimpleClass의 인스턴스를 캡처합니다.     let closure: () -&gt; Int = {         // 클로저가 참조하는 인스턴스의 속성을 업데이트합니다.         instance.value *= 2         return instance.value     }     return closure }       8. 탈출(escaping) 클로저  순차적 실행  func sequentialExecutionExample() {     print(\"Start\")      // 1. 첫 번째 작업     for i in 1...3 {         print(\"Task \\(i)\")     }      // 2. 두 번째 작업     print(\"Next Task\")      // 3. 세 번째 작업     let result = 5 + 3     print(\"Result: \\(result)\")      print(\"End\") }  sequentialExecutionExample() /* 위의 코드는 함수 sequentialExecutionExample 내에서 순차적으로 실행됩니다. 각각의 작업은 순서대로 실행되며, 한 작업이 끝나야 다음 작업이 실행됩니다.  이 예시에서는  'Start', 'Task 1', 'Task 2', 'Task 3', 'Next Task', 'Result: 8', 'End' 와 같은 순서로 출력됩니다. */   비동기 실행  func asynchronousExecutionExample() {     print(\"Start\")      // 1. 비동기로 실행되는 작업     DispatchQueue.global().async {         for i in 1...3 {             print(\"Async Task \\(i)\")         }     }      // 2. 순차적으로 실행되는 작업     print(\"Next Task\")      // 3. 또 다른 비동기 작업     DispatchQueue.global().async {         let result = 5 + 3         print(\"Async Result: \\(result)\")     }      // 4. 끝 부분     print(\"End\") } asynchronousExecutionExample() /* 위의 코드는 비동기적으로 실행되는 예시입니다.  DispatchQueue.global().async를 사용하여 클로저가 다른 스레드에서 비동기적으로 실행됩니다.  따라서 비동기 작업은 순차적인 흐름을 방해하지 않고 별도의 스레드에서 실행됩니다.  실행 결과는  'Start', 'Next Task', 'End' 순서로 출력되고,  비동기 작업은 나중에 완료되어  'Async Task 1', 'Async Task 2', 'Async Task 3', 'Async Result: 8'와 같이  순서는 보장되지 않는 시점에 출력됩니다.  이는 비동기 작업이 별도의 스레드에서 동작하기 때문에,  주 스레드의 작업과 병행적으로 실행됨을 보여줍니다. */   탈출 클로저(escaping closure)     파라미터 타입 앞에 @escaping이라는 키워드를 명시   어떤 함수의 내부에 존재하는 클로저(함수)를 외부 변수에 저장하는 경우     var defaultFunction: () -&gt; () = { print(\"출력\") } func escapingFunc(closure: @escaping () -&gt; ()) {   // 클로저를 실행하는 것이 아니라  aSavedFunction 변수에 저장.    // 함수는 변수와 달리 기본적으로 외부 할당이 불가능   defaultFunction = closure         }           이스케이핑 클로저는 클로저가 메서드의 인자로 전달됐을 때, 메서드의 실행이 종료된 후 실행되는 클로저(비동기)     func asyncEscaping(closure: @escaping (String) -&gt; ()) {   var name = \"철수\"        DispatchQueue.main.asyncAfter(deadline: .now() + 3) { //3초뒤에 실행하도록 만들기       closure(name)   } } asyncEscaping {    print(\"name : \\($0)\") }           @escaping 를 사용하는 클로저에서 self의 요소를 사용할 경우, self를 명시적으로 언급해야 합니다.     var completionHandlers: [() -&gt; Void] = [] func someFunctionWithEscapingClosure(completionHandler: @escaping () -&gt; Void) {   completionHandlers.append(completionHandler) } func someFunctionWithNonescapingClosure(closure: () -&gt; Void) {   closure()    // 함수 안에서 끝나는 클로저 } class SomeClass {   var x = 10   func doSomething() {       someFunctionWithEscapingClosure { self.x = 100 } // 명시적으로 self를 적어줘야 합니다.       someFunctionWithNonescapingClosure { x = 200 }   } } let instance = SomeClass() instance.doSomething() print(instance.x) // Prints \"200\" completionHandlers.first?() print(instance.x) // Prints \"100\"          ","categories": ["swift"],
        "tags": ["swift","Closure"],
        "url": "/swift/closure/",
        "teaser": null
      },{
        "title": "[Swift] 고차함수",
        "excerpt":"고차함수     다른 함수를 인자로 받거나, 함수의 결과로 함수를 반환하는 함수   클로저를 공부해야 원활한 사용 가능   알고리즘 문제 풀면서 익숙해집시다.   Map     map 함수는 컬렉션 내부의 기존 데이터를 변형(transform)하여 새로운 컬렉션를 생성합니다.   기존의 컬렉션의 요소에 대해 정의한 익명함수로 매핑한 결과를 새로운 컬렉션으로 반환합니다.   //문자열 배열을 정수형으로 변경하기  var intArr: [Int] = [] var strArr: [String] = [\"1\", \"2\", \"3\", \"4\", \"5\"] print(strArr)   //출력 [\"1\", \"2\", \"3\", \"4\", \"5\"]  //for문 사용 for i in 0...strArr.count - 1 {     intArr.append(Int(strArr[i])!) } print(intArr) //출력 [1, 2, 3, 4, 5]  //Map 사용 intArr = strArr.map { Int($0)! } print(intArr)   //출력 [1, 2, 3, 4, 5]     클로저의 매개변수 이름이 필요하지 않은 경우 단축 인자 이름을 활용할 수 있습니다.($0, $1)   단축 인자이름은 순서대로 $0 , $1 , $2, $3 …으로 표현합니다.   $0 은 첫번째 인자, $1은 두번째 인자를 뜻합니다.   filter     기존 컨테이너의 요소 중 조건에 만족하는 값에 대해 새로운 컨테이너를 만들어 반환합니다.   //짝수만 뽑아 내기 var arr: [Int] = [] var intArr: [Int] = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]  //for문 사용 for i in 0...intArr.count - 1 {     if intArr[i] % 2 == 0 {         arr.append(intArr[i])     } } print(arr)  //출력 [2, 4, 6, 8, 10]  //filter 사용 arr = intArr.filter { $0 % 2 == 0 } print(arr)  //출력 [2, 4, 6, 8, 10]   reduce     기존의 컨테이너의 요소에 대해 정의한 클로저로 매핑한 결과를 새로운 컨테이너로 반환합니다.   //배열 합 구하기 var sum: Int = 0 var intArr: [Int] = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]  //for문 사용 for i in 0...intArr.count - 1 {     sum += intArr[i] } print(sum)  //출력 55  //reduce 사용 sum = intArr.reduce(0) { $0 + $1 } print(sum) //출력 55   ","categories": ["swift"],
        "tags": ["swift","고차함수"],
        "url": "/swift/%EA%B3%A0%EC%B0%A8%ED%95%A8%EC%88%98/",
        "teaser": null
      },{
        "title": "[TIL] 내배캠 iOS앱 개발 공부 11일차",
        "excerpt":"데일리 스크럼     알고리즘  함수형 프로그래밍과 클로저, 고차함수를 생각하면서 무작정 for문을 쓰지 않으려고 신경써서 풀었다. 정렬은 sort 함수로 썼는데 너무 편하고 좋더라. 무작정 푸는게 아니라 생각해보고 풀어야겠다.   타입캐스팅  팀원들하고 타입캐스팅 관련해서 어려운 점을 이야기하고 각자 공부해서 이야기하는 시간으로 도움이 많이 됐던 것 같다.   심화 강의  심화 강의는 절반 정도 봤는데 전부 이해하지 못해도 완강하고 과제 하면서 다시 봐야겠다.   내일은?  강의를 완강하고 개인과제를 다시 읽어보고 풀어볼예정 !!  ","categories": ["TIL"],
        "tags": ["TIL"],
        "url": "/TIL/til11/",
        "teaser": null
      },{
        "title": "[프로그래머스/Swift] 시저 암호",
        "excerpt":"문제 설명          어떤 문장의 각 알파벳을 일정한 거리만큼 밀어서 다른 알파벳으로 바꾸는 암호화 방식을 시저 암호라고 합니다. 예를 들어 “AB”는 1만큼 밀면 “BC”가 되고, 3만큼 밀면 “DE”가 됩니다. “z”는 1만큼 밀면 “a”가 됩니다. 문자열 s와 거리 n을 입력받아 s를 n만큼 민 암호문을 만드는 함수, solution을 완성해 보세요.            문제 풀기       제한사항     공백은 아무리 밀어도 공백입니다.   s는 알파벳 소문자, 대문자, 공백으로만 이루어져 있습니다.   s의 길이는 8000이하입니다.   n은 1 이상, 25이하인 자연수입니다.   입출력 예                  s       n       result                       “AB”       1       “BC”                 “z”       1       “a”                 “a B z”       4       “e F d”           입출력 예 #1     문제 예시와 같습니다.   나의 풀이  import Foundation  func solution(_ s:String, _ n:Int) -&gt; String {       let arr = s.map { item in         if item == \" \" {             return \" \"         } else if item &gt;= \"a\" &amp;&amp; item &lt;= \"z\" {             if String(UnicodeScalar(item.asciiValue! + UInt8(n))) &gt; \"z\" {                 return String(UnicodeScalar(item.asciiValue! + UInt8(n) - 26))             } else {                 return String(UnicodeScalar(item.asciiValue! + UInt8(n)))             }         } else if item &gt;= \"A\" &amp;&amp; item &lt;= \"Z\" {             if String(UnicodeScalar(item.asciiValue! + UInt8(n))) &gt; \"Z\" {                 return String(UnicodeScalar(item.asciiValue! + UInt8(n) - 26))             } else {                 return String(UnicodeScalar(item.asciiValue! + UInt8(n)))             }         }         return \"\"     }.reduce(\"\") { $0 + $1 }           return arr }  다른 사람 풀이  func solution(_ s:String, _ n:Int) -&gt; String {     let alphabets = \"abcdefghijklmnopqrstuvwxyz\".map { $0 }     return String(s.map {         guard let index = alphabets.firstIndex(of: Character($0.lowercased())) else { return $0 }         let letter = alphabets[(index + n) % alphabets.count]         return $0.isUppercase ? Character(letter.uppercased()) : letter     }) }   의견     최초 코드 작성 시 무조건 이동시키고 a-z / A-Z 범위인지 확인하고 범위를 넘으면 -26을 시켜주었다. 테스트 문제까지 이상없었고 답안 제출때 오답으로 나왔다. a-z 아스키코드는 97-122, A-Z는 65-90 대문자에서 이동을 많이시키면 a-z 소문자로 변경되어 -26이 안되는 문제를 확인하였다.   좋아요 많이 받은 다른 사람 코드를 봤는데 역시 대단… 다양하게 생각하는 것이 어려운 것 같다.  ","categories": ["Algorithm"],
        "tags": ["Algorithm","coding test","시저 암호"],
        "url": "/algorithm/%EC%8B%9C%EC%A0%80-%EC%95%94%ED%98%B8/",
        "teaser": null
      },{
        "title": "[Swift] 아스키 코드",
        "excerpt":"아스키(ASCII)     ASCII(American Standard Code for Information Interchange, 미국 정보 교환 표준 부호)는 컴퓨터와 통신 장비에서 텍스트를 표현하기 위해 사용되는 표준 문자 인코딩 방식   나무위키 아스키코드 바로가기   아스키 코드 -&gt; 문자  let asciiValue: UInt8 = 65 let character = Character(UnicodeScalar(asciiValue)) print(character) // 출력: \"A\"   문자 -&gt; 아스키 코드  let character: Character = \"A\" if let asciiValue = character.asciiValue {     print(asciiValue) // 출력: 65 }   Swift에서 아스키코드 UInt8 타입 사용     Swift에서 ASCII 문자를 처리할 때 일반적으로 UInt8 타입을 사용하는 이유입니다.      아스키 코드의 범위: 아스키 코드는 0부터 127까지의 값을 가집니다. 이는 7비트로 표현되는 숫자입니다. 따라서 UInt8은 0부터 255까지의 값을 가지므로 아스키 코드의 범위 내에 있습니다.   메모리 사용량: UInt8은 1바이트의 메모리를 사용하므로 ASCII 문자를 표현하는 데 최소한의 메모리를 사용합니다. 이는 메모리 사용량을 최적화하고 메모리 소비를 줄이는 데 도움이 됩니다.   타입 안정성: UInt8은 부호 없는 8비트 정수를 나타내므로 음수 값을 가질 수 없습니다. 이는 아스키 코드 값의 범위가 0부터 127까지이므로 부호 없는 타입을 사용하는 것이 논리적입니다.   따라서 UInt8을 사용하는 것은 메모리 사용량을 최소화하고 아스키 코드를 나타내기에 적절한 데이터 타입을 선택하는 것입니다.  ","categories": ["swift"],
        "tags": ["swift","아스키 코드"],
        "url": "/swift/%EC%95%84%EC%8A%A4%ED%82%A4%EC%BD%94%EB%93%9C/",
        "teaser": null
      },{
        "title": "[TIL] 내배캠 iOS앱 개발 공부 12일차",
        "excerpt":"데일리 스크럼     알고리즘  오늘의 오전 알고리즘은 시간이 꽤 오래걸렸는데 아직 제출하지 못했다. 문자를 아스키 코드로 변환하는 방법이 swift에서 낯설어 문법을 찾아서 해결했다.   var str: Character = \"a\"  //문자를 아스키 코드로 변환 str.asciiValue! //출력: 97   //아스키 코드에 1을 더하고 아스키 코드를 문자로 변환 Character(UnicodeScalar(str.asciiValue! + 1)) //출력: b    문제 풀고 적용했는데 중간에 실패가 계속 떴다 ㅠ 강의듣고 과제해야하니까 우선 저녁에 다시 해보는걸로 ..     심화 강의  심화 강의는 완강 했으나 한 파트를 10분에 끝내니 한번에 숙지 못하는건 어쩌면 당연한걸까? 과제하고 다시 보는걸로!   내일은?  오늘은 개인과제 1번을 제출했는데 내일도 과제를 우선 풀고 남은 내용은 블로그 작성하기  ","categories": ["TIL"],
        "tags": ["TIL"],
        "url": "/TIL/til12/",
        "teaser": null
      },{
        "title": "[프로그래머스/Swift] 숫자 문자열과 영단어",
        "excerpt":"문제 설명          네오와 프로도가 숫자놀이를 하고 있습니다. 네오가 프로도에게 숫자를 건넬 때 일부 자릿수를 영단어로 바꾼 카드를 건네주면 프로도는 원래 숫자를 찾는 게임입니다.       다음은 숫자의 일부 자릿수를 영단어로 바꾸는 예시입니다.            1478 → “one4seveneight”       234567 → “23four5six7”       10203 → “1zerotwozero3”           이렇게 숫자의 일부 자릿수가 영단어로 바뀌어졌거나, 혹은 바뀌지 않고 그대로인 문자열 s가 매개변수로 주어집니다. s가 의미하는 원래 숫자를 return 하도록 solution 함수를 완성해주세요.   참고로 각 숫자에 대응되는 영단어는 다음 표와 같습니다.                  숫자       영단어                       0       zero                 1       one                 2       two                 3       three                 4       four                 5       five                 6       six                 7       seven                 8       eight                 9       nine              문제 풀기   제한사항     1 ≤ s의 길이 ≤ 50   s가 “zero” 또는 “0”으로 시작하는 경우는 주어지지 않습니다.   return 값이 1 이상 2,000,000,000 이하의 정수가 되는 올바른 입력만 s로 주어집니다.   입출력 예                  s       result                       “one4seveneight”       1478                 “23four5six7”       234567                 “2three45sixseven”       234567                 “123”       123           입출력 예 #1     문제 예시와 같습니다.   입출력 예 #2     문제 예시와 같습니다.   입출력 예 #3     “three”는 3, “six”는 6, “seven”은 7에 대응되기 때문에 정답은 입출력 예 #2와 같은 234567이 됩니다.   입출력 예 #2와 #3과 같이 같은 정답을 가리키는 문자열이 여러 가지가 나올 수 있습니다.   나의 풀이  import Foundation  func solution(_ s:String) -&gt; Int {     var numDictionary: [String:Int] = [\"zero\":0,\"one\":1,\"two\":2,\"three\":3,\"four\":4,\"five\":5,\"six\":6,\"seven\":7,\"eight\":8,\"nine\":9]          var temp: String = \"\"     var num: String = \"\"          for i in s {         temp += String(i)         for j in numDictionary {             //키에 해당하는 값 찾기             if j.key == temp {                 //print(\"temp: \\(temp), temp 초기화\")                 //print(\"값: \\(j.value)\")                 num += String(j.value)                 temp = \"\"             //값이면 값 출력             } else if String(j.value) == temp {                 //print(j.value)                 num += String(j.value)                 temp = \"\"             }         }     }     return Int(num)! }  다른 사람 풀이  import Foundation  func solution(_ s:String) -&gt; Int {     let arr = [\"zero\",\"one\",\"two\",\"three\",\"four\",\"five\",\"six\",\"seven\",\"eight\",\"nine\"]     var str = s     for i in 0..&lt;arr.count {         str = str.replacingOccurrences(of: arr[i], with: String(i))     }     return Int(str)! }   의견     문제설명을 보고 딕셔너리로 찾을 수 있겠구나 생각하고 생각보다 쉽게 풀었다. 다른 사람의 풀이를 보니 문자열 배열을 만들고 index로 숫자 값을 줄 수도 있다는걸 깨닳음 ㅠ 플레이 그라운드에서 한번 해보고 답 입력하는데 아직 플레이그라운드 없이 풀긴 어렵네   replacingOccurrences 가 있다는 걸 알았다.     func replacingOccurrences(of target: String, with replacement: String) -&gt; String //여기서 target은 대체하고자 하는 문자열이나 패턴을 의미하며, replacement은 target을 대체할 문자열 let originalString = \"Hello, World!\" let modifiedString = originalString.replacingOccurrences(of: \"World\", with: \"Swift\") print(modifiedString) // 출력: \"Hello, Swift!\"          ","categories": ["Algorithm"],
        "tags": ["Algorithm","coding test","숫자 문자열과 영단어"],
        "url": "/algorithm/%EC%88%AB%EC%9E%90%EB%AC%B8%EC%9E%90%EC%97%B4%EA%B3%BC%EC%98%81%EB%8B%A8%EC%96%B4/",
        "teaser": null
      },{
        "title": "[TIL] 내배캠 iOS앱 개발 공부 13일차",
        "excerpt":"데일리 스크럼     알고리즘  어제 풀지 못했던 알고리즘 시저 암호 문제를 오전에 해결했다! 자고 일어났더니 문제가 풀린 기분, 원인은 내가 먼저 알파벳을 이동 시키고 알파벳 범위를 넘어가면 다시 a부터 시작하도록 -26을 빼줬는데 이동을 많이 시키는 경우 대문자가 소문자로 변경되어 다시 A부터 시작해야하는데 정상범위라고 판단하여 발생한 문제였다.   개인과제  내일 정오까지 과제 제출해야하는데 아직 1번밖에 풀지 못했다.  클래스, 함수, 반복문 어떻게 하면 잘 활용할 수 있을까 고민했는데 시간이 너무 많이 지났다. 내일 오전까지 우선 완성은 시켜놓고 조금씩 코드 리펙토링을 진행해야겠다.   내일은?  다음주 부터는 UIKit으로 앱 만들기 강의가 시작 되는데 개인 2주간의 문법강의를 마무리하면서 복습하는 시간을 가져야겠다.   ","categories": ["TIL"],
        "tags": ["TIL"],
        "url": "/TIL/til13/",
        "teaser": null
      },{
        "title": "[내배캠] Swift 프로그래밍 심화 개인과제 - 야구게임",
        "excerpt":"개인과제 후기  1주차 온보딩, 2,3 주차 문법강의가 끝났습니다.  배운 내용을 바탕으로 과제를 만들어 제출하였습니다. 중복값을 제외하고 랜덤 값 뽑기, 스트라이크/볼 판단하는 부분에서 고민하는 시간이 많았습니다. 제출 시간이 촉박하여 우선 완성시켜놓고 최대한 기능별로 나누는 작업을 진행하였습니다. 배웠던 내용을 많이 적용하지 못한 것 같아 아쉬움이 남습니다.   Lv1 문제     1에서 9까지의 서로 다른 임의의 수 3개를 정하고 맞추는 게임   정답은 랜덤으로 만듭니다. 1에서 9까지의 서로 다른 임의의 수 3자리   import Foundation class Random {     func randomNumber(randomNumberCount cnt: Int) -&gt; [Int] {         //1. 배열에 범위만큼의 숫자 할당         var arrNumber: [Int] = Array(1...9)         var arrRandomNumber: [Int] = []                  //임의 개수만큼 반복         for _ in 1...cnt {             //2. 배열 범위에서 랜덤 숫자 인덱스 할당             var index: Int = Int.random(in: 0...arrNumber.count - 1)             //3. 할당된 숫자를 새로운 배열에 저장             arrRandomNumber.append(arrNumber[index])             //4. 할당된 숫자의 Index를 제거             arrNumber.remove(at: index)         }         return arrRandomNumber     } } //정답 확인 func answerCheck(comArr comArrNum: [Int], myArr myArrNum: [Int]) -&gt; String {     //맞춘 개수 확인     for i in 0...myArrNum.count - 1 {         if myArrNum[i] == comArrNum[i] {             rightCnt += 1         }     }      return rightCnt == 3 ? \"정답입니다.\" : \"틀렸습니다! (\\(rightCnt)개 맞췄습니다.)\" }  var comRandom: Random = Random() var comArrNum: [Int] = comRandom.randomNumber(randomNumberCount: 3).sorted() var myRandom: Random = Random() var myArrNum: [Int] = myRandom.randomNumber(randomNumberCount: 3).sorted() var result: String = \"\" var rightCnt: Int = 0  print(\"컴퓨터 선택: \\(comArrNum)\") print(\"내 선택: \\(myArrNum)\") print(answerCheck(comArr: comArrNum, myArr: myArrNum))   Lv2 문제     정답을 맞추기 위해 3자리수를 입력하고 힌트를 받습니다            힌트는 야구용어인 볼과 스트라이크입니다.       같은 자리에 같은 숫자가 있는 경우 스트라이크, 다른 자리에 숫자가 있는 경우 볼입니다.           ex) 정답 : 456 인 경우            435를 입력한 경우 → 1스트라이크 1볼       357를 입력한 경우 → 1스트라이크       678를 입력한 경우 → 1볼       123를 입력한 경우 → Nothing           ex) 정답 : 456 인 경우            435를 입력한 경우 → 1스트라이크 1볼       357를 입력한 경우 → 1스트라이크       678를 입력한 경우 → 1볼       123를 입력한 경우 → Nothing           만약 올바르지 않은 입력값에 대해서는 오류 문구를 보여주세요   3자리 숫자가 정답과 같은 경우 게임이 종료됩니다   실행 예시(정답 : 456)   &lt; 게임을 시작합니다 &gt; 숫자를 입력하세요 435 1스트라이크 1볼  숫자를 입력하세요 357 1스트라이크  숫자를 입력하세요 123 Nothing  숫자를 입력하세요 dfg // 세 자리 숫자가 아니어서 올바르지 않은 입력값 올바르지 않은 입력값입니다  숫자를 입력하세요 199 // 9가 두번 사용되어 올바르지 않은 입력값 올바르지 않은 입력값입니다  숫자를 입력하세요 103 // 0이 사용되어 올바르지 않은 입력값 올바르지 않은 입력값입니다  숫자를 입력하세요 456 정답입니다!   Lv3 문제     정답이 되는 숫자를 0에서 9까지의 서로 다른 3자리의 숫자로 바꿔주세요            맨 앞자리에 0이 오는 것은 불가능합니다                    092 → 불가능           870 → 가능           300 → 불가능                           Lv4 문제     프로그램을 시작할 때 안내문구를 보여주세요     // 예시 환영합니다! 원하시는 번호를 입력해주세요 1. 게임 시작하기  2. 게임 기록 보기  3. 종료하기           1번 게임 시작하기의 경우 “필수 구현 기능” 의 예시처럼 게임이 진행됩니다            정답을 맞혀 게임이 종료된 경우 위 안내문구를 다시 보여주세요           // 예시 환영합니다! 원하시는 번호를 입력해주세요 1. 게임 시작하기  2. 게임 기록 보기  3. 종료하기 1 // 1번 게임 시작하기 입력  &lt; 게임을 시작합니다 &gt; 숫자를 입력하세요 . . .   Lv5 문제     2번 게임 기록 보기의 경우 완료한 게임들에 대해 시도 횟수를 보여줍니다   // 예시 환영합니다! 원하시는 번호를 입력해주세요 1. 게임 시작하기  2. 게임 기록 보기  3. 종료하기 2 // 2번 게임 기록 보기 입력  &lt; 게임 기록 보기 &gt; 1번째 게임 : 시도 횟수 - 14 2번째 게임 : 시도 횟수 - 9 3번째 게임 : 시도 횟수 - 12 . . .   Lv6 문제     3번 종료하기의 경우 프로그램이 종료됩니다   // 예시 환영합니다! 원하시는 번호를 입력해주세요 1. 게임 시작하기  2. 게임 기록 보기  3. 종료하기 3 // 3번 종료하기 입력  &lt; 숫자 야구 게임을 종료합니다 &gt;      1, 2, 3 이외의 입력값에 대해서는 오류 메시지를 보여주세요   // 예시 환영합니다! 원하시는 번호를 입력해주세요 1. 게임 시작하기  2. 게임 기록 보기  3. 종료하기 4  올바른 숫자를 입력해주세요!       제출 코드   import Foundation class BaseballGame {     var comNum: String = \"\" //컴퓨터 랜덤 값     var strike: Int = 0     //스트라이크 개수     var ball: Int = 0       //볼 개수     var flag: Bool = false  //게임 정답 유무 확인          var inputCnt: Int = 0   //입력횟수          init() {         print(\"&lt; 게임을 시작합니다. &gt;\")         self.comNum = randomNum()   //컴퓨터 기본 값 셋팅     }          //컴퓨터 초기 값 셋팅     func randomNum() -&gt; String {         var index: Int = 0         var ranNum: String = \"\"         var arr: [Int] = Array(0...9)                  for i in 0...2 {             repeat {                 index = Int.random(in: 0...arr.count - 1)             } while(i == 0 &amp;&amp; index == 0) //index가 0(첫번째 숫자가 0)이면 다른 숫자가 나올때까지 반복             ranNum += String(arr[index])             arr.remove(at: index)         }                  return ranNum     }          //입력 값 받아오기     func inputData() -&gt; String {         self.inputCnt += 1         print(\"-------------------------------\")         print(\"숫자를 입력하세요\")         if let inputData = readLine() {             return inputData         } else {             return \"\"         }     }          //데이터 체크     func inputDataValidation(_ inputData: String) -&gt; Bool {         if inputData.count != 3 {             print(\"올바르지 않은 입력값입니다. (3자리 입력)\")             return false         } else {             //숫자/문자 체크             if let number = Int(inputData) {                 //숫자 중복값 체크                 if Set(String(number)).count == 3 {                     return true                 } else {                     print(\"올바르지 않은 입력값입니다. (중복 값)\")                     return false                 }             } else {                 print(\"올바르지 않은 입력값입니다. (문자 포함)\")                 return false             }         }     }          func gameStart(_ myNum: String) {         //print(\"내입력값: \\(myNum), 컴터입력값: \\(comNum)\")         let myNumArr: [String] = myNum.map { String($0) }         let comNumArr: [String] = comNum.map { String($0) }          for i in 0...myNumArr.count - 1 {             //숫자가 일치하면 스트라이크             for j in 0...myNumArr.count - 1 {                 //print(\"i: \\(i), j: \\(j), comNumArr[\\(i)]: \\(comNumArr[i]), myNumArr[\\(j)]: \\(myNumArr[j])\")                  //index와 값이 일치하면 스트라이크                 if (i == j) &amp;&amp; (comNumArr[i] == myNumArr[j]) {                     strike += 1                     //값이 일치하지만 index가 다르면 ball                 } else if (i != j) &amp;&amp; (comNumArr[i] == myNumArr[j]) {                     ball += 1                 }             }         }     }          //결과 확인     func gameResult() -&gt; Bool {         if strike == 3 {             print(\"정답입니다!!!!!!!!!!!!!!!!!!!!!!!!\")             print(\"-------------------------------\")             return true         } else if strike == 0 &amp;&amp; ball == 0 {             print(\"Nothing\")             return false         } else {             print(\"\\(self.strike) 스트라이크, \\(self.ball) 볼\")             return false         }     }          func recordClear() {         self.strike = 0         self.ball = 0     } }  class GameRecord {     var gameRecordDictionary = [Int:Int]() }  //게임 횟수 저장 let gameRecord: GameRecord = GameRecord()  while true {     print(\"환영합니다! 원하시는 번호를 입력해주세요.\")     print(\"1. 게임 시작하기 2. 게임 기록 보기 3. 종료하기\")     if let inputData = readLine() {         if let number = Int(inputData) {             switch number {             case 1:                 //컴퓨터 숫자 초기화                 let baseballGame: BaseballGame = BaseballGame()                                  //print(\"컴터 선택 값: \\(baseballGame.num)\")                 repeat {                     let myNum = baseballGame.inputData() //내 입력 숫자                                      //입력값 체크                     if baseballGame.inputDataValidation(myNum) {                         //게임 시작                         baseballGame.gameStart(myNum)                         //결과보기                         baseballGame.flag = baseballGame.gameResult()                                                  if baseballGame.flag {                             //정답시 게임 기록                             if gameRecord.gameRecordDictionary.keys.isEmpty {                                 gameRecord.gameRecordDictionary[1] = baseballGame.inputCnt                             } else {                                 gameRecord.gameRecordDictionary[gameRecord.gameRecordDictionary.keys.max()! + 1] = baseballGame.inputCnt                             }                             baseballGame.inputCnt = 0   //입력 횟수 초기화                         } else {                             //오답 시 초기화                             baseballGame.recordClear()                         }                     }                 } while (baseballGame.flag != true) //true가 될때까지 반복                                  break             case 2:                 print(\"----------------------------------\")                 print(\"게임 기록 보기\")                 if(gameRecord.gameRecordDictionary.count == 0) {                     print(\"진행한 게임이 없습니다.\")                 } else {                     for i in gameRecord.gameRecordDictionary.keys.sorted() {                         print(\"\\(i)번째 게임 : 시도 횟수 - \\(gameRecord.gameRecordDictionary[i]!)\")                     }                 }                 print(\"----------------------------------\")                 break             case 3:                 print(\"&lt;숫자 야구 게임을 종료합니다.&gt;\")                 exit(0)             default:                 print(\"올바른 숫자를 입력해주세요!\")             }         } else {             print(\"올바른 숫자를 입력해주세요!\")         }     } }   ","categories": ["sparta"],
        "tags": ["sparta","swift","야구게임"],
        "url": "/sparta/baseballGame/",
        "teaser": null
      },{
        "title": "[TIL] 내배캠 iOS앱 개발 공부 14일차",
        "excerpt":"데일리 스크럼     개인과제  맑은 정신으로 오전에 후다닥 과제를 마무리했다. 하루를 시작하는 오전에 집중이 가장 잘되는 느낌! 우선 레벨 6번까지 완성하고 제출하고 이후 공개된 해설 영상을 보았다. 랜덤 숫자를 뽑아내는 과정에서 shuffle을 사용할 수 있다는 것과 배열의 Index를 뽑아내기 위해서 항상 for문을 사용했는데 enumerated를 사용하면 인덱스와 값을 함께 출력할 수 있다는 것을 알았다!   알고리즘  오늘은 개인과제와 해설 강의를 확인한다고 알고리즘 문제를 깜빡했다. 주말에 몇개 풀어야겠다.   내배캠 지금까지  온보딩 1주, 문법강의 2주, 3주가 너무 빨리 흘렀다. 집중력을 잃을때 쯤 zep에서 공부중인 팀원들과 사람들, slack에 올라오는 각종 질문들로 정신을 차릴 수 있었다. 취업해서 서울로 갈때까지 파이팅 해야겠다 🔥   다음주?  본격적으로 UIKit으로 앱 만들기 강의가 시작 되는데 각종 버튼, 컨트롤 등 추가해보는 과정이 문법 강의보다 더 재미있을 것 같아 기대된다.  ","categories": ["TIL"],
        "tags": ["TIL"],
        "url": "/TIL/til14/",
        "teaser": null
      },{
        "title": "깃(git)과 깃허브(GitHub)란?",
        "excerpt":"깃(Git)이란?     Git은 분산 버전 관리 시스템(Distributed Version Control System)으로, 소프트웨어 개발에서 사용되는 파일들의 변경 사항을 추적하고 관리하는 도구입니다. 개발자들은 Git을 사용하여 프로젝트의 모든 버전을 기록하고, 여러 명의 개발자가 동시에 작업할 수 있도록 하며, 변경 사항을 추적하고 병합하는 등의 작업을 할 수 있습니다. Git은 분산형이기 때문에 모든 개발자가 전체 프로젝트의 복사본을 갖고 있으며, 중앙 서버에 의존하지 않고도 작업을 진행할 수 있습니다.   버전 관리란?     파일 변화를 시간에 따라 기록했다가 나중에 특정 시점의 버전을 다시 꺼내올 수 있도록 관리하는 것 입니다. 버전 관리를 위해 버전 관리 시스템(VCS, Version Control System)을 사용합니다.   로컬 버전 관리 (Local VCS, Local Version Control System)     자신의 컴퓨터에 있는 파일의 변경 사항을 추적하고 관리할 수 있습니다.   장점            파일의 변경 이력을 추적하고 관리할 수 있습니다.       변경 사항을 롤백하거나 이전 버전으로 복구할 수 있어 실수를 최소화할 수 있습니다.           단점            중앙 서버가 필요하지 않기 때문에 협업이 어려울 수 있습니다.       다수의 개발자가 동시에 작업할 때 충돌이 발생할 수 있고, 해결하기 어려울 수 있습니다.           관련 시스템            RCS (Revision Control System), CVS (Concurrent Versions System)           중앙집중식 버전 관리 (CVCS, Centralized Version Control System)     중앙집중식 버전 관리 시스템은 모든 파일의 변경 사항을 중앙 서버에 저장하고 개발자들이 중앙 서버에서 파일을 가져오고 커밋하는 방식입니다.   장점            중앙 서버에서 모든 파일의 변경 사항을 관리하므로 협업이 간편합니다.       버전 관리, 백업, 보안 등을 중앙에서 관리할 수 있습니다.           단점            중앙 서버에 의존하므로 중앙 서버에 문제가 발생하면 작업이 중단될 수 있습니다.       네트워크 연결이 필요하므로 오프라인 상황에서 작업이 어렵습니다.           관련 시스템            VSS(Visual SourceSafe), SVN(Subversion)       개인적으로는 VSS를 가장 많이 사용했습니다. 지방의 중소, 제조업 전산실에서는 VSS, SVN을 아직도 많이 사용합니다.           분산 버전 관리 시스템 (DVCS, Distributed Version Control System)     분산 버전 관리 시스템은 중앙 서버와 개발자들의 로컬 저장소 간에 변경 사항을 주고받는 시스템입니다. 각 개발자는 전체 저장소의 복사본을 갖고 있으므로 인터넷 연결 없이도 작업할 수 있습니다.   장점            각 개발자가 로컬 저장소를 갖고 있으므로 네트워크 연결이 없어도 작업할 수 있습니다.       분산 구조로 인해 중앙 서버에 의존하지 않으므로 중앙 서버의 장애에도 유연하게 대처할 수 있습니다.       협업이 용이하고 병합 작업이 간편합니다.           단점            초보자에게는 초기 설정과 사용이 어려울 수 있습니다.       중앙 서버가 없으므로 프로젝트의 모든 변경 사항을 추적하고 관리하기 어려울 수 있습니다.           관련 시스템            Git, Mercurial           깃허브(GitHub)란?     Git을 기반으로 한 코드 호스팅 플랫폼입니다. 개발자들은 GitHub을 사용하여 Git으로 관리되는 프로젝트를 호스팅하고, 다른 사용자와 협업하며, 프로젝트에 기여할 수 있습니다. GitHub은 개인 및 기업용 소프트웨어 개발 프로젝트, 오픈 소스 프로젝트, 문서 등 다양한 형태의 프로젝트를 지원하며, 이슈 트래킹, 웹 호스팅, 코드 검토, CI/CD 등의 기능을 제공합니다.   Git과 GitHub는 다르다!     Git은 버전 관리 도구   GitHub은 Git을 기반으로 한 코드 호스팅 플랫폼   Git을 사용하여 프로젝트를 관리하고, GitHub을 사용하여 프로젝트를 호스팅하고 협업할 수 있습니다.  ","categories": ["git"],
        "tags": ["git","github"],
        "url": "/git/git/",
        "teaser": null
      },{
        "title": "[TIL] 내배캠 iOS앱 개발 공부 15일차",
        "excerpt":"데일리 스크럼     알고리즘     지난 금요일, 오늘 47번에서 생각 중인데 내일 오전에는 꼭 한문제 풀어야겠다.   앱 개발 입문 강의  전체 2시간이면 볼 수 있는데 따라해보면서 포스팅한다고 3시간 좀 넘게 봤던 것 같다. 내일 남은 강의 마저 볼 예정. 강의가 짧아서 실습이 중요하다는 걸 느낀다..   내일 목표     알고리즘 문제 풀기   강의 완강   실습 하기   과제 풀기  ","categories": ["TIL"],
        "tags": ["TIL"],
        "url": "/TIL/til15/",
        "teaser": null
      },{
        "title": "[UIKit] AutoLayout - 인터페이스 요소 크기 및 위치 관리",
        "excerpt":"AutoLayout     iOS 및 macOS 애플리케이션에서 사용되는 레이아웃 시스템으로, 사용자 인터페이스 요소들의 크기 및 위치를 관리하는 데 사용됩니다.   AutoLayout은 다양한 화면 크기와 기기 방향에 대응하여 일관된 사용자 경험을 제공하고, 다양한 기기에서 애플리케이션이 잘 동작하도록 돕습니다.   특징     유연성            AutoLayout은 유연한 레이아웃 시스템으로, 다양한 화면 크기와 방향에 맞게 뷰의 크기 및 위치를 동적으로 조정할 수 있습니다. 이를 통해 한 번의 레이아웃 설계로 여러 기기에 대응할 수 있습니다.           제약조건 사용            AutoLayout은 제약조건(Constraints)을 사용하여 뷰의 크기, 위치, 간격 등을 지정합니다. 제약조건은 각 뷰의 속성을 설명하고, 다른 뷰나 슈퍼뷰와의 관계를 정의합니다.           자동으로 레이아웃 계산            AutoLayout은 제약조건에 따라 자동으로 레이아웃을 계산하고 적용합니다. 개발자는 직접 뷰의 크기나 위치를 계산할 필요가 없으며, 시스템이 자동으로 최적의 레이아웃을 계산합니다.           다양한 기능 제공            AutoLayout은 다양한 기능을 제공하여 레이아웃을 더욱 효과적으로 관리할 수 있습니다. 예를 들어, 우선순위를 사용하여 제약조건 간 충돌을 해결하거나, 애니메이션과 함께 레이아웃을 변경할 수 있습니다.           인터페이스 빌더 지원            Xcode의 인터페이스 빌더에서도 AutoLayout을 사용하여 레이아웃을 설계할 수 있습니다. 시각적으로 제약조건을 추가하고 조정하여 인터페이스를 디자인할 수 있습니다.           사용     디바이스가 달라도 일관된 사용자 경험을 제공하기 위함   개념 잡기  제약조건(Constraints)     Autolayout의 핵심 개념으로, 뷰와 뷰 사이의 관계를 나타냅니다.   제약 조건은 뷰의 위치와 크기를 결정하는 데 사용되며, 뷰의 상대적인 위치를 설정하는데 사용합니다.   오토레이아웃 엔진(AutoLayout Engine)     AutoLayout 엔진은 제약 조건을 기반으로 뷰의 최종 위치와 크기를 계산합니다.   이를 통해 다양한 화면 크기와 방향에 대응할 수 있는 유연한 UI를 구현할 수 있습니다.   Size Classes     사이즈 클래스는 화면 크기와 방향에 따른 뷰의 레이아웃을 관리하는 기능입니다.   Compact와 Regular 두 가지 사이즈 클래스가 있으며, 이를 조합하여 다양한 화면 크기와 방향에 대응할 수 있는 레이아웃을 구성할 수 있습니다.   Interface Builder(Storyboard)     Xcode의 인터페이스 빌더는 Autolayout을 사용하여 UI를 시각적으로 디자인할 수 있는 툴입니다. 제약 조건을 추가, 수정, 삭제하는 것이 가능하며, 뷰의 레이아웃을 실시간으로 확인할 수 있습니다.  ","categories": ["UIKit"],
        "tags": ["swift","iOS","AutoLayout"],
        "url": "/UIKit/AutoLayout/",
        "teaser": null
      },{
        "title": "[UIKit] LifeCycle - 생명주기",
        "excerpt":"생명주기(LifeCycle)     UIKit에서의 라이프사이클은 애플리케이션과 앱의 다양한 객체들이 어떻게 생성되고, 표시되고, 사용되고, 제거되는지에 관한 개념입니다.   App LifeCycle     Not Running     실행되지 않거나  종료된 상태.   InActive     앱이 Foreground 상태로 돌아가지만, 이벤트는 받지 않는 상태, 잠시 존재하는 상태.   아래에서 위로 스와이프 하는 순간 InActive 상태가 된다.   Active     일반적으로 앱이 돌아가는 상태(이벤트를 받는 단계)   Background 상태에서 여러 작업 수행   Background     앱이 Suspended(유예 상태) 상태로 진입하기 전 거치는 상태 (음악, 통화 앱 같은 경우는 background)   Suspended     앱이 Background 상태에 있지만, 아무 코드도 실행하지 않는 상태.   시스템이 임의로 Background 상태의 앱을 Suspended 상태로 만든다.(리소스 해제)   Not Running 과 일반적으로 동일       UIViewController LifeCycle     init()     UIViewController 객체가 생성   loadView()     컨트롤러의 뷰 계층 구조가 생성   viewDidLoad()     뷰 계층 구조가 메모리에 로드되었으며, 초기화 작업을 수행   viewWillAppear()     뷰가 화면에 나타나기 직전에 호출. 뷰를 업데이트하거나 애니메이션을 시작   viewDidAppear()     뷰가 화면에 나타나면 호출. 애니메이션을 종료하거나 뷰의 상태를 업데이트   viewWillDisappear()     뷰가 화면에서 사라지기 직전에 호출. 데이터를 저장하거나 애니메이션을 시작   viewDidDisappear()     뷰가 화면에서 사라지면 호출. 애니메이션을 종료하거나 뷰의 상태를 업데이트   deinit     UIViewController 객체가 메모리에서 해제   예제 코드  class MyViewController: UIViewController {          override init(nibName nibNameOrNil: String?, bundle nibBundleOrNil: Bundle?) {         super.init(nibName: nibNameOrNil, bundle: nibBundleOrNil)         // 초기화 메서드에서 필요한 작업 수행     }          required init?(coder: NSCoder) {         super.init(coder: coder)         // 초기화 메서드에서 필요한 작업 수행     }          override func loadView() {         // 뷰를 직접 생성하여 할당         self.view = UIView()     }          override func viewDidLoad() {         super.viewDidLoad()         // 뷰에 대한 추가 구성 작업 수행     }          override func viewWillAppear(_ animated: Bool) {         super.viewWillAppear(animated)         // 뷰가 나타나기 전에 수행할 작업 수행     }          override func viewDidAppear(_ animated: Bool) {         super.viewDidAppear(animated)         // 뷰가 나타난 후에 수행할 작업 수행     }          override func viewWillDisappear(_ animated: Bool) {         super.viewWillDisappear(animated)         // 뷰가 사라지기 전에 수행할 작업 수행     }          override func viewDidDisappear(_ animated: Bool) {         super.viewDidDisappear(animated)         // 뷰가 사라진 후에 수행할 작업 수행     }          deinit {         // 뷰 컨트롤러가 메모리에서 해제되기 전에 수행할 작업 수행     }     }  ","categories": ["UIKit"],
        "tags": ["swift","iOS","LifeCycle"],
        "url": "/UIKit/LifeCycle/",
        "teaser": null
      },{
        "title": "[UIKit] UIButton - 사용자와 상호작용하기",
        "excerpt":"UIButton     사용자와의 상호작용을 위해 화면에 버튼을 표시하는 데 사용되는 UIKit 프레임워크의 클래스   UIButton은 터치 이벤트를 감지하여 사용자의 상호작용에 반응하며, 다양한 시각적 스타일과 상태에 따른 동작을 지원   버튼의 주요 기능            탭 핸들링(Tap Handling): 사용자가 버튼을 탭할 때 발생하는 이벤트를 감지하여 적절한 동작을 수행할 수 있습니다.       상태 관리(State Management): 버튼은 일반적으로 여러 가지 상태를 가지며, 상태에 따라 다른 시각적 스타일을 표시할 수 있습니다. 주요 상태로는 보통 상태, 선택된 상태, 비활성 상태 등이 있습니다.       시각적 스타일링(Visual Styling): 버튼은 배경 이미지, 텍스트, 텍스트 색상, 글꼴 등을 사용하여 시각적으로 스타일링할 수 있습니다.       이벤트 처리(Event Handling): 버튼은 다양한 이벤트를 처리할 수 있으며, 특히 터치 이벤트에 대한 처리가 주요 기능입니다.           UIButton 생성  //시스템 스타일의 버튼 생성  let button = UIButton(type: .system)      /* 버튼 타입 종류  1. system: 시스템 기본 스타일을 가진 버튼입니다. 시스템 버튼은 일반적으로 시스템의 텍스트 색상 및 스타일을 따르며, 사용자의 시스템 설정에 따라 다를 수 있습니다. 2. custom: 사용자 지정 스타일을 가진 버튼입니다. 이 타입을 사용하면 버튼의 외관을 완전히 사용자가 지정할 수 있습니다. 3. roundedRect: iOS 6 이전 버전에서 사용되던 둥근 직사각형 스타일을 가진 버튼입니다. 이제는 잘 사용되지 않으며, system 버튼을 대체하여 사용하는 것이 좋습니다. */      UIButton 설정  버튼에 표시될 텍스트  button.setTitle(\"나는 버튼입니다.\", for: .normal) // 일반 상태에서의 텍스트 설정 button.setTitle(\"선택됨\", for: .selected) // 선택된 상태에서의 텍스트 설정 button.setTitle(\"비활성화됨\", for: .disabled) // 비활성화된 상태에서의 텍스트 설정   버튼 배경색  button.backgroundColor = UIColor.systemPink   버튼 텍스트 색상 설정  button.setTitleColor(UIColor.white, for: .normal) // 일반 상태에서의 텍스트 색상 설정 button.setTitleColor(UIColor.gray, for: .selected) // 선택된 상태에서의 텍스트 색상 설정 button.setTitleColor(UIColor.lightGray, for: .disabled) // 비활성화된 상태에서의 텍스트 색상 설정   버튼 위치와 크기 지정  //화면의 (50, 100) 위치에 위치하고, 너비가 200, 높이가 50인 사각형 영역에 버튼이 배치 button.frame = CGRect(x: 50, y: 100, width: 200, height: 50)   버튼에 대한 액션 설정 (버튼이 탭 되었을때 실행될 함수)  //버튼을 눌렀을때 text(버튼을 눌렀습니다.)가 print되는 코드  button.addTarget(self, action: #selector(buttonTapped), for: .touchUpInside) /* 첫 번째 매개변수 self는 이벤트를 수신할 대상을 나타냅니다. 일반적으로는 현재의 뷰 컨트롤러를 가리킵니다. 두 번째 매개변수 action은 이벤트가 발생했을때 호출될 메서드, @objc 어노테이션이 붙어있어야함.  - #selector는 Objective-C에서 메서드를 식별하는 문법  - @objc는 Swift 코드와 Objective-C와 상호작용하게 해줌 세 번째 매개변수 for는 이벤트 처리기 선택, touchUpInside는 버튼이 눌렀을때 호출  */ /* touchUpInside에 들어갈 수 있는 이벤트  .touchDown: 사용자가 스위치를 터치할 때 호출됩니다. .touchDownRepeat: 사용자가 스위치를 연속해서 터치할 때 호출됩니다. .touchDragInside: 사용자가 스위치를 내부로 드래그할 때 호출됩니다. .touchDragOutside: 사용자가 스위치를 외부로 드래그할 때 호출됩니다. .touchDragEnter: 사용자가 스위치의 영역으로 드래그할 때 호출됩니다. .touchDragExit: 사용자가 스위치의 영역을 벗어날 때 호출됩니다. .touchUpInside: 사용자가 스위치를 터치하고 놓을 때 호출됩니다. (가장 흔히 사용됨) .touchUpOutside: 사용자가 스위치 외부에서 터치하고 놓을 때 호출됩니다. .valueChanged: 스위치의 값이 변경될 때 호출됩니다. (가장 흔히 사용됨) .primaryActionTriggered: 주요 작업이 트리거될 때 호출됩니다. (예: 터치를 누를 때) .editingDidBegin: 편집이 시작될 때 호출됩니다. (예: 텍스트 필드 편집이 시작될 때) .editingChanged: 편집 내용이 변경될 때 호출됩니다. (예: 텍스트 필드의 텍스트가 변경될 때) .editingDidEnd: 편집이 종료될 때 호출됩니다. (예: 텍스트 필드 편집이 종료될 때) */ @objc func buttonTapped() {     print(\"버튼을 눌렀습니다.\") }  ","categories": ["UIKit"],
        "tags": ["swift","iOS","UIButton"],
        "url": "/UIKit/UIButton/",
        "teaser": null
      },{
        "title": "[UIKit] UICollectionView - 그리드나 리스트 표시",
        "excerpt":"UICollectionView     iOS 애플리케이션에서 그리드나 리스트 형식으로 데이터를 표시하는 데 사용되는 유연한 레이아웃을 가진 뷰입니다.   UICollectionView는 UITableView와 유사하지만, 보다 다양한 레이아웃과 사용자 정의 가능한 셀 디자인을 제공합니다.   특징     다양한 레이아웃            UICollectionView는 그리드, 리스트, 덱스(Stack), 커스텀 등 다양한 레이아웃을 지원합니다. 이를 통해 다양한 종류의 데이터를 효과적으로 표시할 수 있습니다.           셀 재사용            UICollectionView는 셀을 효율적으로 관리하기 위해 셀 재사용 메커니즘을 사용합니다. 이는 메모리 사용량을 최적화하고 성능을 향상시킵니다.           다중 섹션            UICollectionView는 여러 섹션을 가질 수 있으며, 각 섹션은 여러 개의 아이템을 포함할 수 있습니다. 이를 통해 데이터를 논리적으로 그룹화하고 표시할 수 있습니다.           사용자 정의 가능한 셀            UICollectionView를 사용하여 각 셀의 모양, 크기, 배치 등을 사용자 정의할 수 있습니다. 이를 통해 다양한 디자인의 인터페이스를 구현할 수 있습니다.           델리게이트 및 데이터 소스            UICollectionView는 UITableViewDelegate 및 UITableViewDataSource 프로토콜과 유사한 UICollectionViewDelegate 및 UICollectionViewDataSource 프로토콜을 사용하여 사용자 상호 작용 및 데이터 관리를 처리합니다.           사용     iOS 애플리케이션에서 다양한 유형의 데이터를 효율적으로 표시하고 사용자 상호 작용을 처리하는 데 매우 유용합니다.   주요 예로는 이미지 갤러리, 뉴스 피드, 카탈로그, 그리드 뷰 등이 있습니다.   주요 속성  dataSource     UICollectionView 데이터를 제공하는 객체를 설정합니다.   delegate     UICollectionView의 이벤트를 처리하는 객체를 설정합니다.   collectionViewLayout     UICollectionView의 레이아웃을 설정합니다.   allowsSelection     컬렉션 뷰에서 셀 선택을 허용할지 여부를 설정합니다.   allowsMultipleSelection     여러 셀을 동시에 선택할 수 있는지 여부를 설정합니다.   UICollectionView 설정  예제 코드  import UIKit      class ViewController: UIViewController, UICollectionViewDataSource, UICollectionViewDelegate, UICollectionViewDelegateFlowLayout {              let collectionView = UICollectionView(frame: .zero, collectionViewLayout: UICollectionViewFlowLayout())       // 표시할 데이터 배열을 정의     let data = [\"Item 1\", \"Item 2\", \"Item 3\"]              override func viewDidLoad() {           super.viewDidLoad()           // 컬렉션뷰의 프레임을 설정         collectionView.frame = view.bounds            // 컬렉션뷰의 데이터 소스 및 델리게이트를 설정         collectionView.dataSource = self           collectionView.delegate = self            // 셀 재사용을 위해 UICollectionViewCell을 등록         collectionView.register(UICollectionViewCell.self, forCellWithReuseIdentifier: \"Cell\")            //배경색 설정          collectionView.backgroundColor = .white            //컬렉션뷰를 루트 뷰에 추가          view.addSubview(collectionView)       }              // UICollectionViewDataSource 프로토콜 메서드      /* [필수] 행 수를 보고합니다. */     // section: 컬렉션뷰의 section을 나타내는 식별자 입니다. 이를 바탕으로 해당 섹션의 count를 반환합니다.     func collectionView(_ collectionView: UICollectionView, numberOfItemsInSection section: Int) -&gt; Int {           return data.count       }            /* [필수] 각 행에 대한 셀을 제공합니다. */     // indexPath: 컬렉션뷰에서 Row(행)을 찾는 경로입니다. 이를 바탕으로 적절한 cell을 반환합니다.     func collectionView(_ collectionView: UICollectionView, cellForItemAt indexPath: IndexPath) -&gt; UICollectionViewCell {           let cell = collectionView.dequeueReusableCell(withReuseIdentifier: \"Cell\", for: indexPath)           // 셀의 배경색을 파란색으로 설정         cell.backgroundColor = .blue            return cell       }              // UICollectionViewDelegate     /* 행이 선택되었을 때 호출 */     // indexPath: 컬렉션뷰에서 선택된 Row(행)을 찾는 경로입니다. 이를 바탕으로 어떤 행이 선택되었는지 파악할 수 있습니다.     func collectionView(_ collectionView: UICollectionView, didSelectItemAt indexPath: IndexPath) {           // 선택된 항목을 콘솔에 출력         print(\"Selected: \\(data[indexPath.row])\")           // 선택 표시를 해제         collectionView.deselectItem(at: indexPath, animated: true)       }              // UICollectionViewDelegateFlowLayout 프로토콜 메서드     /* 셀의 크기를 반환합니다 */     // collectionViewLayout: 컬렉션뷰에서 사용된 레이아웃입니다. 행의 크기를 반환할 때 참고할 수 있습니다.     // indexPath: 컬렉션뷰에서 선택된 Row(행)을 찾는 경로입니다. 이를 바탕으로 어떤 행의 크기를 반환할지 판단할 수 있습니다.     func collectionView(_ collectionView: UICollectionView, layout collectionViewLayout: UICollectionViewLayout, sizeForItemAt indexPath: IndexPath) -&gt; CGSize {           // 모든 셀의 크기를 100x100으로 설정         return CGSize(width: 100, height: 100)       }   }  ","categories": ["UIKit"],
        "tags": ["swift","iOS","UICollectionView"],
        "url": "/UIKit/UICollectionView/",
        "teaser": null
      },{
        "title": "[UIKit] UIImageView - 이미지 표시",
        "excerpt":"UIImageView     UIKit 프레임워크에서 제공하는 클래스로, 이미지를 표시하는 데 사용   UIImageView 생성  let imageView = UIImageView()       UIImageView 설정  표시할 이미지 설정  //이미지 파일명으로 UIImage 객체 생성  let image = UIImage(named: \"exampleImage\") imageView.image = image     UIImageView 위치와 크기를 정의  //화면에서 (x: 50, y: 100)에 위치하고, 너비가 200포인트이고 높이가 150포인트인 사각형 영역에 해당하는 위치에 표시 imageView.frame = CGRect(x: 50, y: 100, width: 200, height: 150)    image 표시할때 contentMode 설정     이미지 뷰의 크기와 이미지의 크기가 다를 때 .scaleAspectFit 모드를 사용하면 이미지가 이미지 뷰에 적절히 맞춰져서 화면에 나타남   //scaleAspectFit모드는 이미지의 비율을 유지하면서 이미지가 이미지 뷰에 딱 맞도록 확대 또는 축소되어 표시 imageView.contentMode = .scaleAspectFit  ","categories": ["UIKit"],
        "tags": ["swift","iOS","UIImageView"],
        "url": "/UIKit/UIImageView/",
        "teaser": null
      },{
        "title": "[UIKit] UILabel - 텍스트 표시 ",
        "excerpt":"UILabel     텍스트를 표시하는데 사용되는 UI 요소   UILabel 생성  let label = UILabel()       UILabel 설정  텍스트 입력  label.text = \"나는 UILabel 입니다.    폰트 크기 설정  label.font = UIFont.systemFont(ofSize: 20)  텍스트 색상 설정  label.textColor = UIColor.black  정렬  label.textAlignment = .left  label.textAlignment = .center  label.textAlignment = .right    최대 표시 줄  label.numberOfLines = 2 //최대 2줄까지 표시 (0으로 설정하면 자동 줄바꿈)   텍스트가 주어진 공간을 벗어날 경우  //텍스트가 UILabel의 끝 부분에서 생략되고 \"...\"이 표시 label.lineBreakMode = .byTruncatingTail   UILabel 위치와 크기를 정의  //x축과 y축으로 각각 100포인트씩 이동하고, 너비와 높이를 각각 200포인트로 설정 label.frame = CGRect(x: 100, y: 100, width: 200, height: 200)   ","categories": ["UIKit"],
        "tags": ["swift","iOS","UILabel"],
        "url": "/UIKit/UILabel/",
        "teaser": null
      },{
        "title": "[UIKit] UIPickerView - 회전 가능한 휠 형식",
        "excerpt":"UIPickerView     iOS 애플리케이션에서 선택지를 제공하고 사용자가 그 중 하나를 선택할 수 있도록 하는 뷰입니다.   주로 특정한 선택지를 제공하고 사용자가 그 중 하나를 선택할 때 사용됩니다.   특징     선택지 표시            UIPickerView는 여러 개의 컴포넌트를 가질 수 있으며, 각 컴포넌트에는 여러 개의 행(row)이 포함될 수 있습니다. 각 행은 하나의 선택지를 나타냅니다.           스크롤 기능            사용자는 UIPickerView의 컴포넌트를 위아래로 스크롤하여 여러 선택지 중 원하는 항목을 찾을 수 있습니다.           델리게이트 및 데이터 소스            UIPickerView는 데이터와 상호 작용하기 위해 데이터 소스 및 델리게이트 패턴을 사용합니다. 데이터 소스는 UIPickerView에 대해 표시할 데이터를 제공하고, 델리게이트는 사용자 상호 작용 및 선택 이벤트를 처리합니다.           사용     UIPickerView는 주로 날짜, 시간, 지역, 선택 리스트, 옵션 등과 같이 여러 선택지 중에서 하나를 선택할 필요가 있는 경우에 사용됩니다.   주요 속성  dataSource     UIPickerView의 데이터를 제공하는 객체를 설정합니다.   delegate     UIPickerView의 이벤트를 처리하는 객체를 설정합니다.   numberOfComponents     UIPickerView에서 표시할 구성 요소의 수를 반환합니다.   selectedRow(inComponent:)     지정된 구성 요소에서 선택된 행의 인덱스를 반환합니다.   UIScrollView 설정  예제 코드  import UIKit class ViewController: UIViewController, UIPickerViewDelegate, UIPickerViewDataSource {     let pickerView = UIPickerView()     let data = [\"Apple\", \"Banana\", \"Orange\", \"Grape\", \"Pineapple\"]      override func viewDidLoad() {         super.viewDidLoad()           //UIPickerView의 delegate 및 dataSource를 ViewController로 설정         pickerView.delegate = self         pickerView.dataSource = self                  //pickerView를 화면의 중앙에 위치         pickerView.center = view.center                   //pickerView를 ViewController의 뷰에 추가         view.addSubview(pickerView)     }      //UIPickerViewDataSource 프로토콜의 필수 메서드로, UIPickerView에 표시할 컴포넌트(열)의 개수를 반환     func numberOfComponents (in pickerView: UIPickerView) -&gt; Int {         return 1     }      //UIPickerViewDataSource 프로토콜의 필수 메서드로, 각 컴포넌트(열)에 표시할 행의 개수를 반환     func pickerView(_ pickerView: UIPickerView, numberOfRowsInComponent component: Int) -&gt; Int {         return data.count     }      //UIPickerViewDelegate 프로토콜의 선택적 메서드로 사용자가 특정 행을 선택 했을때 호출      func pickerView(_ pickerView: UIPickerView, titleForRow row: Int, forComponent component: Int) -&gt; String? {         return data[row]     }      //선택된 과일을 출력      func pickerView(_ pickerView: UIPickerView, didSelectRow row: Int, inComponent component: Int) {         print(\"Selected: \\(data[row])\")     } }  ","categories": ["UIKit"],
        "tags": ["swift","iOS","UIPickerView"],
        "url": "/UIKit/UIPickerView/",
        "teaser": null
      },{
        "title": "[UIKit] UIScrollView - 화면에서 스크롤 가능한 영역을 제공",
        "excerpt":"UIScrollView     iOS 애플리케이션에서 스크롤 가능한 컨텐츠를 표시하고 제어하기 위해 사용되는 컨테이너 뷰입니다.   UIScrollView는 화면에 표시되는 컨텐츠의 크기가 스크린 크기보다 큰 경우 사용자가 화면을 스크롤하여 컨텐츠를 탐색할 수 있도록 합니다.   특징     스크롤 가능한 영역            UIScrollView는 보통 자신의 bounds보다 큰 컨텐츠를 포함할 수 있습니다. 사용자는 스크롤하여 이 컨텐츠의 다른 부분을 볼 수 있습니다.           스크롤 인디케이터            UIScrollView에는 수직 및 수평으로 스크롤 가능한 경우에는 스크롤 인디케이터가 표시됩니다. 이것은 사용자에게 스크롤 가능한 영역의 현재 위치를 시각적으로 보여줍니다.           확대 및 축소            UIScrollView는 사용자가 핀치(Pinch)하여 확대 또는 축소할 수 있는 확대/축소 동작을 지원합니다.           델리게이트 패턴            UIScrollView는 UIScrollViewDelegate 프로토콜을 사용하여 사용자 상호 작용 및 스크롤 이벤트를 처리하는 메서드를 호출할 수 있는 델리게이트 패턴을 지원합니다.           사용     UIScrollView는 많은 다른 뷰와 함께 사용됩니다. 텍스트, 이미지, 뷰, 테이블 뷰 및 컬렉션 뷰와 같은 다양한 컨텐츠를 UIScrollView 내에 배치하여 스크롤 가능한 사용자 인터페이스를 만들 수 있습니다.   UIScrollView 생성  // UIScrollView 생성 및 화면 크기와 같은 프레임 설정 let scrollView = UIScrollView(frame: view.bounds)      UIScrollView 설정  스크롤 기능을 활성화  scrollView.isScrollEnabled = true    페이지 단위로 스크롤 여부 설정  // UIScrollView에서 페이지 단위로 스크롤 여부 설정 scrollView.isPagingEnabled = false    스크롤이 끝에 도달할 때 효과  // UIScrollView에서 스크롤이 끝에 도달할 때 바운스 효과 활성화 scrollView.bounces = true    크기 설정  // UIScrollView에 표시되는 전체 컨텐츠의 크기 설정 (가로 스크롤만 가능한 경우 가로 크기만 설정) scrollView.contentSize = CGSize(width: view.frame.width, height: view.frame.height * 2)   UILabel 생성 및 UIScrollView에 추가  let label = UILabel(frame: CGRect(x: 0, y: view.frame.height - 30, width: view.frame.width, height: 60)) label.textAlignment = .center scrollView.addSubview(label)  ","categories": ["UIKit"],
        "tags": ["swift","iOS","UIScrollView"],
        "url": "/UIKit/UIScrollView/",
        "teaser": null
      },{
        "title": "[UIKit] UISegmentedControl - 세그먼트를 선택하여 원하는 옵션을 선택",
        "excerpt":"UISegmentedControl     iOS 앱에서 여러 개의 상호 배타적인 옵션 중 하나를 선택할 수 있는 컨트롤입니다.   사용자는 UISegmentedControl을 탭하여 여러 세그먼트 중 하나를 선택할 수 있습니다. 각 세그먼트는 다른 옵션을 나타내며, 사용자는 이를 탭하여 해당 옵션을 선택합니다.   특징     상호 배타적인 선택            여러 옵션 중 하나만 선택할 수 있습니다. 한 번에 한 옵션만 선택됩니다.           시각적 표시            각 세그먼트는 사용자에게 다른 옵션을 시각적으로 표시합니다.           값 변경 이벤트            사용자가 세그먼트를 선택할 때마다 값을 변경하는 이벤트가 발생합니다.           사용     여러 가지 옵션 중 하나를 선택해야 하는 경우 (예: 탭 스타일 탐색 메뉴)   서로 다른 뷰 또는 데이터를 전환해야 하는 경우 (예: 세그먼트 컨트롤을 사용하여 다른 보기를 전환하는 탭 컨트롤러)   세그먼트(Segment)란?     세그먼트(Segment)란 일정한 단위로 분할된 부분   UISegmentedControl 생성  let items = [\"Option 1\", \"Option 2\", \"Option 3\"] let segmentedControl = UISegmentedControl(items: items)      UISegmentedControl 설정  초기 선택된 세그먼트 인덱스 설정  segmentedControl.selectedSegmentIndex = 0 //초기 선택된 세그먼트 인덱스 설정    세그먼트 컨트롤 색상 설정  segmentedControl.tintColor = UIColor.blue    선택 표시를 유지할지 여부 설정  segmentedControl.isMomentary = false    세그먼트 값 변경 이벤트 처리  segmentedControl.addTarget(self, action: #selector(segmentValueChanged(_:)), for: .valueChanged) /* 첫 번째 매개변수 self는 이벤트를 수신할 대상을 나타냅니다. 일반적으로는 현재의 뷰 컨트롤러를 가리킵니다. 두 번째 매개변수 action은 이벤트가 발생했을때 호출될 메서드, @objc 어노테이션이 붙어있어야함.  - #selector는 Objective-C에서 메서드를 식별하는 문법  - @objc는 Swift 코드와 Objective-C와 상호작용하게 해줌 세 번째 매개변수 for는 이벤트 처리기 선택, valueChange는 버튼이 눌렀을때 호출  */ /* .valueChange에 들어갈 수 있는 이벤트  .touchDown: 사용자가 스위치를 터치할 때 호출됩니다. .touchDownRepeat: 사용자가 스위치를 연속해서 터치할 때 호출됩니다. .touchDragInside: 사용자가 스위치를 내부로 드래그할 때 호출됩니다. .touchDragOutside: 사용자가 스위치를 외부로 드래그할 때 호출됩니다. .touchDragEnter: 사용자가 스위치의 영역으로 드래그할 때 호출됩니다. .touchDragExit: 사용자가 스위치의 영역을 벗어날 때 호출됩니다. .touchUpInside: 사용자가 스위치를 터치하고 놓을 때 호출됩니다. (가장 흔히 사용됨) .touchUpOutside: 사용자가 스위치 외부에서 터치하고 놓을 때 호출됩니다. .valueChanged: 스위치의 값이 변경될 때 호출됩니다. (가장 흔히 사용됨) .primaryActionTriggered: 주요 작업이 트리거될 때 호출됩니다. (예: 터치를 누를 때) .editingDidBegin: 편집이 시작될 때 호출됩니다. (예: 텍스트 필드 편집이 시작될 때) .editingChanged: 편집 내용이 변경될 때 호출됩니다. (예: 텍스트 필드의 텍스트가 변경될 때) .editingDidEnd: 편집이 종료될 때 호출됩니다. (예: 텍스트 필드 편집이 종료될 때) */  @objc func segmentValueChange(_ sender: UISegmentedControl) {     print(\"Selected segment index: \\(sender.selectedSegmentIndex)\") }  ","categories": ["UIKit"],
        "tags": ["swift","iOS","UISegmentedControl"],
        "url": "/UIKit/UISegmentedControl/",
        "teaser": null
      },{
        "title": "[UIKit] UISlider - 값의 범위를 가지고 사용자가 원하는 값을 선택",
        "excerpt":"UISlider     사용자 인터페이스(UI)에서 수치 범위를 나타내는 데 사용되는 컨트롤입니다.   사용자가 슬라이더를 조작하여 값이 변경될 때 이벤트가 발생합니다.   UISlider 생성  let slider = UISlider()      UISlider 설정  초기 값 설정  slider.value = 50     최대/최소 값 설정  slider.minimumValue = 0      slider.maximumValue = 100    트랙 색상 설정  slider.minimumTrackTintColor = UIColor.red      //왼쪽 트랙 색상 설정   slider.maximumTrackTintColor = UIColor.blue     //오른쪽 트랙 색상 설정   슬라이더 값 변경 이벤트 처리  slider.addTarget(self, action: #selector(sliderValueChange(_:)), for: .valueChanged) /* 첫 번째 매개변수 self는 이벤트를 수신할 대상을 나타냅니다. 일반적으로는 현재의 뷰 컨트롤러를 가리킵니다. 두 번째 매개변수 action은 이벤트가 발생했을때 호출될 메서드, @objc 어노테이션이 붙어있어야함.  - #selector는 Objective-C에서 메서드를 식별하는 문법  - @objc는 Swift 코드와 Objective-C와 상호작용하게 해줌 세 번째 매개변수 for는 이벤트 처리기 선택, valueChange는 버튼이 눌렀을때 호출  */ /* .valueChange에 들어갈 수 있는 이벤트  .touchDown: 사용자가 스위치를 터치할 때 호출됩니다. .touchDownRepeat: 사용자가 스위치를 연속해서 터치할 때 호출됩니다. .touchDragInside: 사용자가 스위치를 내부로 드래그할 때 호출됩니다. .touchDragOutside: 사용자가 스위치를 외부로 드래그할 때 호출됩니다. .touchDragEnter: 사용자가 스위치의 영역으로 드래그할 때 호출됩니다. .touchDragExit: 사용자가 스위치의 영역을 벗어날 때 호출됩니다. .touchUpInside: 사용자가 스위치를 터치하고 놓을 때 호출됩니다. (가장 흔히 사용됨) .touchUpOutside: 사용자가 스위치 외부에서 터치하고 놓을 때 호출됩니다. .valueChanged: 스위치의 값이 변경될 때 호출됩니다. (가장 흔히 사용됨) .primaryActionTriggered: 주요 작업이 트리거될 때 호출됩니다. (예: 터치를 누를 때) .editingDidBegin: 편집이 시작될 때 호출됩니다. (예: 텍스트 필드 편집이 시작될 때) .editingChanged: 편집 내용이 변경될 때 호출됩니다. (예: 텍스트 필드의 텍스트가 변경될 때) .editingDidEnd: 편집이 종료될 때 호출됩니다. (예: 텍스트 필드 편집이 종료될 때) */  @objc func sliderValueChange(_ sender: UISlider) {     print(\"Slider value: \\(sender.value)\") }  ","categories": ["UIKit"],
        "tags": ["swift","iOS","UISlider"],
        "url": "/UIKit/UISlider/",
        "teaser": null
      },{
        "title": "[UIKit] UISwitch - on/off 상태를 표시하고 제어",
        "excerpt":"UISwitch     UISwitch는 UIKit 프레임워크에서 제공하는 사용자 인터페이스 컨트롤 중 하나로, 이진(on/off) 상태를 표시하고 제어하는 데 사용합니다.   사용자가 어떤 설정을 켜고 끌 수 있는 옵션을 제공하는 데 사용합니다.   UISwitch 생성  let mySwitch = UISwitch()       UISwitch 설정  스위치 초기 상태 설정  mySwitch.isOn = true    스위치가 켜져있을 때 배경 색상  mySwitch.onTintColor = UIColor.systemPink   썸네일 색상 설정     UISwitch의 작은 원형 컨트롤(또는 ‘썸’이라고도 함)의 색상을 설정하는 속성   UISwitch의 ‘썸’이 켜진(on) 또는 꺼진(off) 상태일 때의 색상을 지정   mySwitch.thumbTintColor = UIColor.systemPink   on/off 이미지 설정 (더 이상 사용하지 않음)     onImage 및 offImage 속성은 UISwitch가 도입된 iOS 7부터 사용 가능했으나, iOS 7 이후로는 내장된 이미지를 사용하도록 변경되었기 때문에 더 이상 사용되지 않습니다. 대신 onTintColor 및 tintColor 속성을 사용하여 UISwitch의 외관을 커스터마이징할 수 있습니다.   mySwitch.onImage = UIImage(named: \"onImage\")    //켜져있을 때 표시되는 이미지 설정  mySwitch.offImage = UIImage(named: \"offImage\")  //꺼져있을 때 표시되는 이미지 설정   스위치 이벤트 처리  mySwitch.addTarget(self, action: #selector(switchValueChanged(_: )), for: .valueChanged) /* 첫 번째 매개변수 self는 이벤트를 수신할 대상을 나타냅니다. 일반적으로는 현재의 뷰 컨트롤러를 가리킵니다. 두 번째 매개변수 action은 이벤트가 발생했을때 호출될 메서드, @objc 어노테이션이 붙어있어야함.  - #selector는 Objective-C에서 메서드를 식별하는 문법  - @objc는 Swift 코드와 Objective-C와 상호작용하게 해줌 세 번째 매개변수 for는 이벤트 처리기 선택, valueChange는 버튼이 눌렀을때 호출  */ /* .valueChange에 들어갈 수 있는 이벤트  .touchDown: 사용자가 스위치를 터치할 때 호출됩니다. .touchDownRepeat: 사용자가 스위치를 연속해서 터치할 때 호출됩니다. .touchDragInside: 사용자가 스위치를 내부로 드래그할 때 호출됩니다. .touchDragOutside: 사용자가 스위치를 외부로 드래그할 때 호출됩니다. .touchDragEnter: 사용자가 스위치의 영역으로 드래그할 때 호출됩니다. .touchDragExit: 사용자가 스위치의 영역을 벗어날 때 호출됩니다. .touchUpInside: 사용자가 스위치를 터치하고 놓을 때 호출됩니다. (가장 흔히 사용됨) .touchUpOutside: 사용자가 스위치 외부에서 터치하고 놓을 때 호출됩니다. .valueChanged: 스위치의 값이 변경될 때 호출됩니다. (가장 흔히 사용됨) .primaryActionTriggered: 주요 작업이 트리거될 때 호출됩니다. (예: 터치를 누를 때) .editingDidBegin: 편집이 시작될 때 호출됩니다. (예: 텍스트 필드 편집이 시작될 때) .editingChanged: 편집 내용이 변경될 때 호출됩니다. (예: 텍스트 필드의 텍스트가 변경될 때) .editingDidEnd: 편집이 종료될 때 호출됩니다. (예: 텍스트 필드 편집이 종료될 때) */  @objc func switchValueChanged(_ sender: UISwitch) {     if sender.isOn {         print(\"Switch is On\")     } else {         print(\"Switch is Off\")     } }  ","categories": ["UIKit"],
        "tags": ["swift","iOS","UISwitch"],
        "url": "/UIKit/UISwitch/",
        "teaser": null
      },{
        "title": "[UIKit] UITextField - 사용자에게 텍스트 입력 받기",
        "excerpt":"UITextField     UITextField는 UIKit 프레임워크에서 제공하는 클래스 중 하나로, 사용자로부터 텍스트를 입력받는 데 사용   텍스트 필드, 검색 상자 또는 비밀번호 필드 등을 생성할 때 사용   UITextField 생성  let textField = UITextField()       UITextField 설정  입력 유도 메시지  textField.placeholder = \"텍스트를 입력하세요.\"   UITextField 모양  //둥근 테두리  textField.borderStyle = .roundedRect   입력용 키보드 설정     사용자가 해당 입력 필드에 입력할 때 사용할 키보드의 종류를 지정   //일반 텍스트 입력용 키보드 textField.keyboardType = .default //이메일 주소 입력  textField.keyboardType = .emailAddress //숫자만 입력  textField.keyboardType = .numberPad  /* 입력용 키보드 종류  Default: 일반적인 키보드로, 텍스트 및 숫자를 입력할 수 있습니다. ASCIICapable: ASCII 문자만 입력할 수 있는 키보드입니다. Numbers and Punctuation: 숫자와 일부 구두점 기호를 입력할 수 있는 키보드입니다. URL: URL 입력에 특화된 키보드로, .com 버튼이나 / 버튼이 추가되어 있습니다. NumberPad: 숫자만 입력할 수 있는 패드 형태의 키보드입니다. PhonePad: 전화번호를 입력할 때 사용하는 패드 형태의 키보드입니다. DecimalPad: 십진수를 입력할 수 있는 숫자 패드입니다. 소수점을 사용할 수 있습니다. EmailAddress: 이메일 주소를 입력하는데 특화된 키보드입니다. Twitter: 트위터 관련 기호와 사용할 수 있는 키보드입니다. WebSearch: 웹 검색에 사용할 수 있는 키보드입니다. */   보안 입력(비밀번호 등)  //일반 텍스트 입력용 키보드 textField.isSecureTextEntry = false   리턴(엔터) 키의 종류  //일반 텍스트 입력용 키보드 textField.returnKeyType = .done  /* ReturnKeyType의 종류 default: 기본 동작으로, 텍스트 필드의 입력을 완료합니다. go: \"이동\"이라는 동작을 수행합니다. 주로 키보드의 Return 키가 \"이동\" 동작을 수행하는데 사용됩니다. 예를 들어, 로그인 화면에서 사용자가 아이디와 비밀번호를 입력한 후 Return 키를 누르면 비밀번호 입력 필드로 이동할 때 사용됩니다. google: \"Google\" 동작을 수행합니다. 일반적으로 웹 검색 화면에서 사용됩니다. join: \"가입\" 동작을 수행합니다. 주로 가입 양식에서 사용됩니다. next: \"다음\" 동작을 수행합니다. 주로 다음 입력 필드로 포커스를 이동할 때 사용됩니다. route: \"경로\" 동작을 수행합니다. 예를 들어, 지도 앱에서 사용될 수 있습니다. search: \"검색\" 동작을 수행합니다. 주로 검색 창에서 사용됩니다. send: \"전송\" 동작을 수행합니다. 주로 메시지를 전송하는 화면에서 사용됩니다. done: \"완료\" 동작을 수행합니다. 편집 모드를 종료하거나 텍스트 입력을 완료하는 데 사용됩니다. emergencyCall: \"긴급 전화\" 동작을 수행합니다. 긴급 전화를 걸거나 전화 앱을 실행하는 데 사용됩니다. */  ","categories": ["UIKit"],
        "tags": ["swift","iOS","UITextField"],
        "url": "/UIKit/UITextField/",
        "teaser": null
      },{
        "title": "[UIKit] UIView - 가장 기본적인 뷰",
        "excerpt":"UIView     iOS 및 macOS 애플리케이션에서 사용자 인터페이스를 구성하는 데 사용되는 기본적인 뷰(위젯)입니다.   UIView는 화면에 무엇인가를 그리는 데 사용되며, 많은 UI 요소들이 UIView의 하위 클래스로 구현됩니다.   특징     컨테이너 역할            다른 뷰 및 UI 요소들을 포함하고 배치하는 데 사용됩니다. 즉, 여러 개의 서브뷰를 가질 수 있으며, 이를 통해 복잡한 사용자 인터페이스를 구성할 수 있습니다.           그리기 및 렌더링            UIView는 그리기와 렌더링을 담당합니다. 이를 통해 배경색, 텍스트, 이미지 등을 그리고 사용자의 입력에 따라 화면에 업데이트할 수 있습니다.           사용자 상호 작용            UIView는 사용자의 터치 이벤트를 감지하고 이에 대한 응답을 처리할 수 있습니다. 이를 통해 사용자와의 상호 작용을 구현할 수 있습니다.           애니메이션            UIView는 애니메이션을 사용하여 요소들을 부드럽게 이동하거나 변경할 수 있습니다. 이를 통해 인터페이스의 시각적 효과를 개선할 수 있습니다.           레이아웃 및 제약조건            UIView는 자신과 서브뷰의 레이아웃을 관리하고, 제약조건(Constraints)을 사용하여 인터페이스의 크기 및 위치를 지정할 수 있습니다.           안내 역할            사용자에게 정보를 표시하고 안내하는 데 사용될 수 있습니다. 예를 들어, UILabel, UIButton 등의 요소들이 UIView의 하위 클래스입니다.           사용     iOS 및 macOS 애플리케이션에서 사용되는 가장 기본적인 뷰 요소이며, 모든 사용자 인터페이스 요소들은 UIView의 하위 클래스로 구현됩니다.  ","categories": ["UIKit"],
        "tags": ["swift","iOS","UIView"],
        "url": "/UIKit/UIView/",
        "teaser": null
      },{
        "title": "[프로그래머스/Swift] 문자열 내 마음대로 정렬하기",
        "excerpt":"문제 설명          문자열로 구성된 리스트 strings와, 정수 n이 주어졌을 때, 각 문자열의 인덱스 n번째 글자를 기준으로 오름차순 정렬하려 합니다. 예를 들어 strings가 [“sun”, “bed”, “car”]이고 n이 1이면 각 단어의 인덱스 1의 문자 “u”, “e”, “a”로 strings를 정렬합니다.            문제 풀기       제한사항     strings는 길이 1 이상, 50이하인 배열입니다.   strings의 원소는 소문자 알파벳으로 이루어져 있습니다.   strings의 원소는 길이 1 이상, 100이하인 문자열입니다.   모든 strings의 원소의 길이는 n보다 큽니다.   인덱스 1의 문자가 같은 문자열이 여럿 일 경우, 사전순으로 앞선 문자열이 앞쪽에 위치합니다.   입출력 예                  strings       n       return                 [“sun”, “bed”, “car”]       1       [“car”, “bed”, “sun”]                 [“abce”, “abcd”, “cdx”]       2       [“abcd”, “abce”, “cdx”]           입출력 예 #1     “sun”, “bed”, “car”의 1번째 인덱스 값은 각각 “u”, “e”, “a” 입니다. 이를 기준으로 strings를 정렬하면 [“car”, “bed”, “sun”] 입니다.   입출력 예 #2     “abce”와 “abcd”, “cdx”의 2번째 인덱스 값은 “c”, “c”, “x”입니다. 따라서 정렬 후에는 “cdx”가 가장 뒤에 위치합니다. “abce”와 “abcd”는 사전순으로 정렬하면 “abcd”가 우선하므로, 답은 [“abcd”, “abce”, “cdx”] 입니다.   나의 풀이  func solution(_ strings:[String], _ n:Int) -&gt; [String] {     let arr = strings.sorted {         let ch1 = $0[$0.index($0.startIndex, offsetBy: n)]         let ch2 = $1[$1.index($1.startIndex, offsetBy: n)]                  //문자가 같으면 문자열비교         if ch1 == ch2 {             return $0 &lt; $1         } else {             return ch1 &lt; ch2         }     }          return arr }  다른 사람 풀이  func solution(_ strings:[String], _ n:Int) -&gt; [String] {     return strings.sorted{  Array($0)[n] == Array($1)[n] ? $0 &lt; $1 :  Array($0)[n] &lt; Array($1)[n] } }   의견     알고리즘 풀면서 가장 오래걸린 문제였고 어려웠다.            문제를 확인하고 입력받은 인덱스부터 마지막까지의 문자를 배열에 만들고 기존배열에서 contains를 통해 원래 문자열을 찾아서 다시 배열에 저장하고 그 배열을 리턴하는 것으로 생각했다.       딕셔너리를 만들어 key에 원래 문자열, value에 잘려진 문자열을 저장하고 value값으로 정렬 후 key값을 새로 배열에 담아 출력했다. 일부 테스트는 통과했는데 문자가 중복되는 경우 문자열 sort를 해줘야하는데 거기서 매끄럽지 못했다.       sort를 계속 하다가 sorted 클로저에서 직접 조건을 추가하고 리턴해보기로 했다. index의 문자를 구하고 테스트 했는데 또 일부는 맞고 일부는 틀린 실패가 떴다.         //수정 전  let ch1 = $0.index($0.startIndex, offsetBy: n) let ch2 = $1.index($1.startIndex, offsetBy: n) // 수정 후 let ch1 = $0[$0.index($0.startIndex, offsetBy: n)] let ch2 = $1[$1.index($1.startIndex, offsetBy: n)]                  다시 확인했는데 수정 전 코드로하면 문자가 출력되는게 아니라 Index(_rawBits: 65799) 이런식으로 String.index타입으로 출력이 되었다.  스위프트에서 문자열에 정수 인덱스 사용이 불가능 하다는 것을 알게되었다 !                   쉽게 쉽게 푸는 다른 사람들의 풀이를 보면서 오늘도 존경심을 가진다.   ","categories": ["Algorithm"],
        "tags": ["Algorithm","coding test","문자열 내 마음대로 정렬하기"],
        "url": "/algorithm/%EB%AC%B8%EC%9E%90%EC%97%B4%EB%82%B4%EB%A7%88%EC%9D%8C%EB%8C%80%EB%A1%9C%EC%A0%95%EB%A0%AC%ED%95%98%EA%B8%B0/",
        "teaser": null
      },{
        "title": "Xcode 프로젝트 깃허브(GitHub)에 추가하기",
        "excerpt":"1. 원격 저장소 추가     GitHub에 새로운 원격 저장소를 생성하고 로컬 저장소에 해당 원격 저장소를 추가합니다.    2. XCode 프로젝트 생성     Xcode 프로젝트의 이름과 GitHub 레포지토리의 이름이 반드시 같을 필요는 없습니다.     3. 터미널 오픈     프로젝트 폴더에서 우클릭 후 터미널 오픈합니다.     4. git init - 저장소 초기화     명령어는 새로운 Git 저장소를 초기화하는 데 사용됩니다.   git init            해당 명령어로 현재 디렉토리에 새로운 Git 저장소를 만듭니다. 이 저장소에는 프로젝트의 모든 변경 내역을 추적하고 관리할 수 있는 .git 디렉토리가 생성됩니다.         imhs@imhsui-MacBookPro MyTodoList % git init                  힌트 = : Using 'master' as the name for the initial branch. This default branch name 힌트: is subject to change. To configure the initial branch name to use in all 힌트 : of your new repositories, which will suppress this warning, call: 힌트 : 힌트 : git config -global init.defaultBranch ‹name&gt; 힌트 :  힌트 : Names commonly chosen instead of 'master' are 'main', 'trunk' and 힌트 : 'development'. The just-created branch can be renamed via this command: 힌트 : 힌트 : git branch -m &lt;name&gt; /users/imhs/Desktop/내배캠 스파르타/실습과제/MyTodoList/.git/ 안의 빈 깃 저 장소를 다시 초기화했습니다                            5. git add . - 스테이징 영역에 추가     명령어는 Git에서 변경된 모든 파일을 스테이징 영역에 추가하는 역할을 합니다.   git add .            현재 디렉토리 및 하위 디렉토리에서 변경된 모든 파일을 찾습니다.       변경된 파일을 스테이징 영역에 추가합니다. 이는 Git이 해당 파일의 변경 내용을 추적하고, 다음 커밋에 포함시키기 위한 준비 단계입니다.         imhs@imhsui-MacBookPro MyTodoList % git add .                            6. git commit -m “커밋메시지” - 저장소에 기록     스테이징 영역에 추가된 파일은 git commit 명령어를 사용하여 커밋할 수 있습니다. 스테이징 영역에 추가된 파일은 이후 커밋에 반영되며, 커밋을 통해 변경 내용이 저장소에 영구적으로 기록됩니다.   git commit -m “MyTodoList 추가”     imhs@imhsui-MacBookPro MyTodoList % git commit -m \"MyTodoList 추가\"            7. git branch -M main - 기본 브랜치 이름 변경     기본적으로 Git 저장소를 초기화하면 “master”라는 이름의 기본 브랜치가 생성됩니다. 그러나 최근의 표준화 노력과 함께 이를 “main”으로 변경하는 추세가 있습니다.   git branch -M main 명령어는 현재 작업 중인 브랜치를 “main”으로 변경합니다.   git branch -M main     imhs@imhsui-MacBookPro MyTodoList % git commit -m \"MyTodoList 추가\"            8. git remote add origin 저장소URL - git 저장소에 원격 저장소 추가     현재 Git 저장소에 origin이라는 이름으로 URL의 원격 저장소를 추가   git remote add origin https://github.com/limlogging/MyTodoList.git     imhs@imhsui-MacBookPro MyTodoList % git remote add origin https://github.com/limlogging/MyTodoList.git           9. git push -u origin main - 작업 중인 브랜치를 원격 저장소에 푸시     현재 작업 중인 브랜치를 원격 저장소에 푸시하는 역할을 합니다.   -u 옵션은 해당 브랜치를 원격 저장소의 기본 브랜치로 설정하는 역할을 합니다.            이 옵션을 사용하면 이후에는 git push 명령어를 실행할 때 -u 옵션 없이도 동일한 원격 저장소 및 브랜치로 푸시할 수 있습니다.           git push -u origin main     imhs@imhsui-MacBookPro MyTodoList % git push -u origin main           10. 깃허브 확인     main 브랜치가 default로 생기고 commit 메시지도 확인할 수 있습니다.     11. 브랜치 새로 만들어서 작업     git branch로 현재 브랜치를 확인합니다.   imhs@imhsui-MacBookPro MyTodoList % git branch * main      dev 브랜치를 만들고 생성된 브랜치로 이동합니다.   imhs@imhsui-MacBookPro MyTodoList % git checkout -b dev       브랜치를 확인합니다.   imhs@imhsui-MacBookPro MyTodoList % git branch  * dev   main      작업 후 커밋합니다.   imhs@imhsui-MacBookPro MyTodoList % git add . imhs@imhsui-MacBookPro MyTodoList % git commit -m \"기능추가\"  imhs@imhsui-MacBookPro MyTodoList % git push origin dev  ","categories": ["git"],
        "tags": ["git","github","xcode","add","commit","push"],
        "url": "/git/gitProjectAdd/",
        "teaser": null
      },{
        "title": "[내배캠] iOS 앱 개발 입문 - 간단한 카운터 앱 만들기",
        "excerpt":"간단한 카운터 앱 만들기     swift 문법 강의 주차가 끝나고 ios 앱 개발 입문 강의를 들으며 강의에 포함된 간단한 카운터 앱 만들기 과제를 만들었습니다.   요구사항  화면     레이아웃 요구사항     UILabel이 가운데 위치하게 해 주세요.   UILabel을 기준으로 상단에는 감소 버튼, 아래에는 증가 버튼을 위치시켜 주세요.   UILabel과 UIButton사이의 간격은 16px로 설정해 주세요.   AutoLayout을 사용해 주세요.   로직 요구사항     count의 시작은 0으로 시작해 주세요.   감소버튼을 눌렀을 때, -1씩 감소시켜 UILabel에 표시해 주세요.   증가버튼을 눌렀을 때, +1씩 증가시켜 UILabel에 표시해 주세요.   과제 완성  나의 화면     제약 조건     나의 코드  // //  ViewController.swift //  SimpleCounter // //  Created by imhs on 3/18/24. //  import UIKit  class ViewController: UIViewController {     @IBOutlet weak var counterLabel: UILabel!          var count: Int = 0          override func viewDidLoad() {         super.viewDidLoad()         counterLabel.text = String(count)     }      //감소     @IBAction func decreaseButtonTapped(_ sender: Any) {         count -= 1         counterLabel.text = String(count)     }          //증가     @IBAction func increaseButtonTapped(_ sender: Any) {         count += 1         counterLabel.text = String(count)     } }   강의 구현 코드  import UIKit  class ViewController: UIViewController {     @IBOutlet weak var textLabel: UILabel!     private var count: Int = 0       // 감소 버튼이 클릭된 경우      @IBAction func tappedDecreaseButton(_ sender: UIButton) {         self.count -= 1 // count를 -1 합니다.          self.refreshTextLabel() // textLabel을 새로고침 합니다.      }          // 증가 버튼이 클릭된 경우       @IBAction func tappedIncreaseButton(_ sender: UIButton) {         self.count += 1 // count를 +1 합니다.          self.refreshTextLabel() // textLabel을 새로고침 합니다.      }      // count값을 self.textLabel의 text에 반영합니다.      private func refreshTextLabel() {         self.textLabel.text = String(self.count)     }      // viewDidLoad 생명주기 활용      override func viewDidLoad() {         super.viewDidLoad()         self.refreshTextLabel()     } }   생명주기 활용 ?     강의 코드에서 생명주기 활용은 ViewController의 생명주기 메서드 중 하나인 viewDidLoad() 메서드를 활용하는 것을 의미   viewDidLoad() 메서드는 ViewController의 view가 메모리에 로드된 직후 호출, ViewController가 생성된 직후 초기화 작업을 수행할 때 유용   iewDidLoad() 메서드를 활용하여 textLabel의 초기 값을 설정하는 refreshTextLabel() 메서드를 호출   생명주기 활용은 ViewController의 뷰가 로드되는 시점에 필요한 초기화 작업을 수행하여 화면을 적절히 설정하는 것을 의미합니다.   필요한 작업이 적절하게 배치가 됐는지 생각해보자!  ","categories": ["sparta"],
        "tags": ["간단한카운터앱"],
        "url": "/sparta/%EA%B0%84%EB%8B%A8%ED%95%9C%EC%B9%B4%EC%9A%B4%ED%84%B0%EC%95%B1/",
        "teaser": null
      },{
        "title": "[TIL] 내배캠 iOS앱 개발 공부 16일차",
        "excerpt":"데일리 스크럼     알고리즘     오늘 47번 문제를 푸는데 가장 오래 걸렸다. 문자열 관련 처리, swift에서 제공하는 함수에 아직도 익숙하지 못한 것 같다.   문자열 자르고 배열 만들어 추가하고… 갖은 방법을 동원하다가 sorted 클로저로 풀 수 있었다.   풀이 보기            문자열 내 마음대로 정렬하기           앱 개발 입문 강의     앱 개발 입문강의를 완강하고 간단한 카운터 앱 만들기를 완성했다.   아직 생명 주기를 활용한 코딩은 어려운 것 같다.   과제 확인            간단한 카운터 앱 만들기           개인 과제     개인 과제에서 필요한 기능을 확인했다.   버튼을 누르면 text 입력이 가능하고 table View에도 추가가 되었다.   라이브러리에서 버튼, 테이블 뷰를 가져와 스토리보드 올려놓았는데 이후 로직이 조금 막막했다. 온보딩에서 한 화면 이동 등의 내용이랑은 달랐다.   과제에서 제시한 키워드를 바탕으로 내일은 하나씩 실습해봐야겠다.   내일 목표     알고리즘 문제 풀기   키워드 하나씩 실습 하기   과제 풀기  ","categories": ["TIL"],
        "tags": ["TIL"],
        "url": "/TIL/til16/",
        "teaser": null
      },{
        "title": "[프로그래머스/Swift] K번째수",
        "excerpt":"문제 설명     배열 array의 i번째 숫자부터 j번째 숫자까지 자르고 정렬했을 때, k번째에 있는 수를 구하려 합니다.   예를 들어 array가 [1, 5, 2, 6, 3, 7, 4], i = 2, j = 5, k = 3이라면            array의 2번째부터 5번째까지 자르면 [5, 2, 6, 3]입니다.       1에서 나온 배열을 정렬하면 [2, 3, 5, 6]입니다.       2에서 나온 배열의 3번째 숫자는 5입니다.                배열 array, [i, j, k]를 원소로 가진 2차원 배열 commands가 매개변수로 주어질 때, commands의 모든 원소에 대해 앞서 설명한 연산을 적용했을 때 나온 결과를 배열에 담아 return 하도록 solution 함수를 작성해주세요.       문제 풀기   제한사항     array의 길이는 1 이상 100 이하입니다.   array의 각 원소는 1 이상 100 이하입니다.   commands의 길이는 1 이상 50 이하입니다.   commands의 각 원소는 길이가 3입니다.   입출력 예                  array       commands       return                       [1, 5, 2, 6, 3, 7, 4]       [[2, 5, 3], [4, 4, 1], [1, 7, 3]]       [5, 6, 3]           입출력 예 설명     [1, 5, 2, 6, 3, 7, 4]를 2번째부터 5번째까지 자른 후 정렬합니다. [2, 3, 5, 6]의 세 번째 숫자는 5입니다.   [1, 5, 2, 6, 3, 7, 4]를 4번째부터 4번째까지 자른 후 정렬합니다. [6]의 첫 번째 숫자는 6입니다.   [1, 5, 2, 6, 3, 7, 4]를 1번째부터 7번째까지 자릅니다. [1, 2, 3, 4, 5, 6, 7]의 세 번째 숫자는 3입니다.   나의 풀이  import Foundation  func solution(_ array:[Int], _ commands:[[Int]]) -&gt; [Int] {     var arr: [Int] = []              for arrCom in commands {         //배열 자르고 정렬         let tempArr = array[arrCom[0] - 1...arrCom[1] - 1].sorted()         arr.append(tempArr[arrCom[2] - 1])     }          return arr }  다른 사람 풀이  import Foundation  func solution(_ array:[Int], _ commands:[[Int]]) -&gt; [Int] {     return commands.map({(key) in         return array[(key[0]-1)...(key[1]-1)].sorted()[key[2]-1]     }) }   의견     어제 문자열 고민을 해서 금방 풀었다. sorted뒤에 arrCom[2] - 1 부분을 붙였는데 에러가 발생해서 따로 상수를 만들었는데 다른사람의 풀이를 보니 내가 작성했던 코드 중에서 에러가 발생한 것 같다. 다시 해보니까 잘되더라     arr.append(array[arrCom[0] - 1...arrCom[1] - 1].sorted()[arrCom[2] - 1])          그치만 배열 따로 만들어서 추가 해야겠다고 생각했는데 array에서 바로 return은 생각도 못했는데 저렇게도 되는구나 ..      ","categories": ["Algorithm"],
        "tags": ["Algorithm","coding test","K번째수"],
        "url": "/algorithm/K%EB%B2%88%EC%A7%B8%EC%88%98/",
        "teaser": null
      },{
        "title": "[프로그래머스/Swift] 두 개 뽑아서 더하기",
        "excerpt":"문제 설명          정수 배열 numbers가 주어집니다. numbers에서 서로 다른 인덱스에 있는 두 개의 수를 뽑아 더해서 만들 수 있는 모든 수를 배열에 오름차순으로 담아 return 하도록 solution 함수를 완성해주세요.            문제 풀기       제한사항     numbers의 길이는 2 이상 100 이하입니다.            numbers의 모든 수는 0 이상 100 이하입니다.           입출력 예                  numbers       result                       [2,1,3,4,1]       [2,3,4,5,6,7]                 [5,0,2,7]       [2,5,7,9,12]           입출력 예 #1     2 = 1 + 1 입니다. (1이 numbers에 두 개 있습니다.)   3 = 2 + 1 입니다.   4 = 1 + 3 입니다.   5 = 1 + 4 = 2 + 3 입니다.   6 = 2 + 4 입니다.   7 = 3 + 4 입니다.   따라서 [2,3,4,5,6,7] 을 return 해야 합니다.   입출력 예 #2     2 = 0 + 2 입니다.   5 = 5 + 0 입니다.   7 = 0 + 7 = 5 + 2 입니다.   9 = 2 + 7 입니다.   12 = 5 + 7 입니다.   따라서 [2,5,7,9,12] 를 return 해야 합니다.   나의 풀이  import Foundation  func solution(_ numbers:[Int]) -&gt; [Int] {     var arr: [Int] = []          for i in 0...numbers.count - 2 {         for j in i + 1...numbers.count - 1{             arr.append(numbers[i] + numbers[j])         }     }     //중복제거 후 정렬 값 리턴     return Set(arr).sorted() }  다른 사람 풀이  import Foundation  func solution(_ numbers:[Int]) -&gt; [Int] {     var result = [Int]()      for i in 0 ..&lt; numbers.count {         for j in i + 1 ..&lt; numbers.count {             let num = numbers[i] + numbers[j]             if !result.contains(num) {                 result.append(num)             }         }     }     return result.sorted() }   의견     개인과제로 야구게임할때 중복체크하는 부분에 Set을 썼는데 이번에 잊지않고 사용했다!   다른 사람 풀이도 비슷  ","categories": ["Algorithm"],
        "tags": ["Algorithm","coding test","두 개 뽑아서 더하기"],
        "url": "/algorithm/%EB%91%90%EA%B0%9C%EB%BD%91%EC%95%84%EC%84%9C%EB%8D%94%ED%95%98%EA%B8%B0/",
        "teaser": null
      },{
        "title": "[TIL] 내배캠 iOS앱 개발 공부 17일차",
        "excerpt":"데일리 스크럼     알고리즘     어제 문자열 관련해서 고민을 많이 했어서 그런지 한문제를 금방 풀어 두 문제를 풀었다.   풀이 보기            K번째수       두 개 뽑아서 더하기           개인 과제 공부     델리게이트 패턴에 대해서 알게 되었다.   뷰와 오브젝트간의 의사소통을 위한 패턴            델리게이트 패턴           내일 목표     알고리즘 문제 풀기   키워드 하나씩 실습 하기   과제 풀기  ","categories": ["TIL"],
        "tags": ["TIL"],
        "url": "/TIL/til17/",
        "teaser": null
      },{
        "title": "[UIKit] 델리게이트(Delegate) 패턴 ",
        "excerpt":"델리게이트(Delegate) 패턴 / 위임 패턴     객체 지향 프로그래밍에서 자주 사용되는 디자인 패턴 중 하나입니다.   객체 사이의 행동을 분리하고, 특정 객체가 다른 객체의 대리자(delegate) 역할을 수행하여 해당 객체의 동작을 확장하거나 커스터마이징할 수 있도록 합니다.   델리게이트 패턴은 소프트웨어의 모듈성을 높이고 객체 간의 결합도를 줄여 유지보수와 확장성을 향상시킬 수 있습니다.        애플의 프레임워크에 사용하는 델리게이트 패턴을 위해 다양한 프로토콜이 XXXXDelegate라는 식의 이름으로 정의되어 있습니다.       객체와 객체간의 의사소통을 위함   예제 코드     ViewController와 TextField는 서로 다른 객체입니다.   TextField를 ViewController위에 올려 놓습니다.            Object를 View에 올려놓는 행위와 같은 말                    인터페이스 빌더(Interface Builder)에서 UI 요소를 배치한다.           인터페이스 빌더(Interface Builder)에서 UI를 구성한다.                           View에 올려놓은 TextField의 동작을 View에게 전달하기 위해서는 델리게이트 패턴을 적용해야합니다.   View 와 TextField(Object)간의 의사소통을 위해서 델리게이트 패턴 사용합니다.                  ViewController       TextFieldObject                                         1. 인터페이스 구성 요소의 연결     textField를 control을 누른 상태로 드래그하여 속성을 연결합니다.     2. 인터페이스의 델리게이트 설정     textField의 대리자를 ViewController로 설정합니다.   myTextField.delegate = self 추가       override func viewDidLoad() {       super.viewDidLoad() //화면 로드       myTextField.delegate = self //추가! TextField의 대리자는 ViewController   }           TextField의 대리자는 self(ViewController)로 설정합니다.   TextField와 ViewController가 소통이 가능해졌습니다.            textField의 입력, 수정, 포커스 등 이벤트를 ViewController에서 수신하고 처리할 수 있습니다.           ViewController가 화면이 로드된 후에 텍스트 필드의 델리게이트를 설정하기 위해서 super.viewDidLoad() 아래에 코드를 적습니다.   3. 델리게이트 프로토콜 채택  프로토콜 채택 전     코드 입력 창에 text라고 입력하면 textField에 관한 메서드가 보이지 않습니다.     프로토콜 채택     Class 선언 부분의 마지막에 UITextFieldDelegate를 추가합니다.            델리게이트 패턴을 위해 다양한 프로토콜이 XXXXDelegate라는 식의 이름으로 정의되어 있습니다.              프로토콜 채택 후     코드 입력 창에 text를 입력하면 textField에 관한 메서드가 보입니다.     4. 필요한 프로토콜 메서드를 구현     필요한 메서드를 추가하여 사용할 수 있습니다.   원하는 프로토콜 메서드의 기능은 검색 / 실습을 통해 확인해야합니다.   어떤 글자를 입력 받았는지 확인하는 메서드를 추가하여 테스트하였습니다.     마무리     델리게이트 패턴은 view와 object간의 데이터를 주고 받는 등 소통을 위해 사용!  ","categories": ["UIKit"],
        "tags": ["swift","iOS","Delegate"],
        "url": "/UIKit/Delegate/",
        "teaser": null
      },{
        "title": "[프로그래머스/Swift] 가장 가까운 같은 글자",
        "excerpt":"문제 설명     문자열 s가 주어졌을 때, s의 각 위치마다 자신보다 앞에 나왔으면서, 자신과 가장 가까운 곳에 있는 같은 글자가 어디 있는지 알고 싶습니다. 예를 들어, s=”banana”라고 할 때,  각 글자들을 왼쪽부터 오른쪽으로 읽어 나가면서 다음과 같이 진행할 수 있습니다.            b는 처음 나왔기 때문에 자신의 앞에 같은 글자가 없습니다. 이는 -1로 표현합니다.       a는 처음 나왔기 때문에 자신의 앞에 같은 글자가 없습니다. 이는 -1로 표현합니다.       n은 처음 나왔기 때문에 자신의 앞에 같은 글자가 없습니다. 이는 -1로 표현합니다.       a는 자신보다 두 칸 앞에 a가 있습니다. 이는 2로 표현합니다.       n도 자신보다 두 칸 앞에 n이 있습니다. 이는 2로 표현합니다.       a는 자신보다 두 칸, 네 칸 앞에 a가 있습니다. 이 중 가까운 것은 두 칸 앞이고, 이는 2로 표현합니다.           따라서 최종 결과물은 [-1, -1, -1, 2, 2, 2]가 됩니다.        문자열 s이 주어질 때, 위와 같이 정의된 연산을 수행하는 함수 solution을 완성해주세요.       문제 풀기   제한사항     1 ≤ s의 길이 ≤ 10,000            s은 영어 소문자로만 이루어져 있습니다.           입출력 예                  s       result                       “banana”       [-1, -1, -1, 2, 2, 2]                 “foobar”       [-1, -1, 1, -1, -1, -1]           입출력 예 설명  입출력 예 #1     지문과 같습니다.   입출력 예 #2     설명 생략   나의 풀이  import Foundation  func solution(_ s:String) -&gt; [Int] {     var chArr: [Character] = []     var numArr: [Int] = []     var chIndex: Int = -100 //초기값 0으로 하면 0번째 문자가 중복되면 계산 못해서 임의로 -100          for (i, ch) in s.enumerated() {         //처음에는 무조건 배열 추가         if chArr.count == 0 {             chArr.append(ch)             //print(\"-1\")             numArr.append(-1)         } else {             //따로 저장한 배열 확인             for (j, value) in chArr.enumerated() {                 //같은 값 있으면 마지막 index 확인                 if ch == value {                     chIndex = j                 }             }             //없으면 추가.             if chIndex == -100 {                 chArr.append(ch)                 //print(\"-1\")                 numArr.append(-1)             //있으면 전체 수 - 인덱스 위치             } else {                 numArr.append(chArr.count - chIndex)                 chArr.append(ch)                                                  chIndex = -100             }         }     }         //print(\"chArr: \\(chArr)\")     return numArr }  다른 사람 풀이  import Foundation  func solution(_ s: String) -&gt; [Int] {     var word: [String: Int] = [:]     var result: [Int] = []      for (index, val) in Array(s).map { String($0) }.enumerated() {         if let beforeIndex = word[val] {             result.append(index - beforeIndex)         } else {             result.append(-1)         }          word[val] = index     }      return result }   의견     난 문자가 존재하는지 찾기 위해서 반복문을 한번 더 썼는데 딕셔너리로 푼 사람들이 많은 것 같다.   반복문 줄이는 연습을 해보자 …  ","categories": ["Algorithm"],
        "tags": ["Algorithm","coding test","가장 가까운 같은 글자"],
        "url": "/algorithm/%EA%B0%80%EC%9E%A5%EA%B0%80%EA%B9%8C%EC%9A%B4%EA%B0%99%EC%9D%80%EA%B8%80%EC%9E%90/",
        "teaser": null
      },{
        "title": "[TIL] 내배캠 iOS앱 개발 공부 18일차",
        "excerpt":"데일리 스크럼     알고리즘     빨리 풀긴 했는데 초기 값과, 반복문 횟수 등 다른 사람과의 다른 점을 확인하면서 고민해볼 수 있었다.   풀이 보기            가장 가까운 같은 글자           개인 과제 공부     오늘은 화면 이동 관련해서 공부했다.   화면이동에는 4가지 방법 (1.코드로 화면이동, 2.코드로 스토리보드 객체를 생성해서 화면이동, 3.스토리보드에서 간접 세그웨이를 통한 화면이동, 4.스토리보드에서 직접 세그웨이를 통한 화면이동)이 있는데 그 중 코드로 화면이동을 공부했다.   코드로 화면표시 present(), 코드로 화면 닫기 dismiss()            코드로 화면 이동           내일 목표     과제 제출이 다음주 금요일까지긴 하지만 벌써 3레벨 이상 달성한 팀원들을 보면서 속도를 내야겠다고 생각했다 ㅠㅠ   알고리즘 문제 풀기   키워드 하나씩 실습 하기   과제 풀기  ","categories": ["TIL"],
        "tags": ["TIL"],
        "url": "/TIL/til18/",
        "teaser": null
      },{
        "title": "[UIKit] 얼러트 컨트롤러(UIAlertController) ",
        "excerpt":"얼러트 컨트롤러(UIAlertController)란?     iOS 애플리케이션에서 경고 메시지, 알림 창, 또는 사용자에게 선택 옵션을 제공하는 팝업 창을 표시하는 데 사용되는 클래스입니다.   UIKit 프레임워크에서 제공되며, 모든 iOS 버전에서 사용할 수 있습니다.   스타일     .alert (경고 메시지 / 알림)   .actionSheet (사용자 선택 옵션 목록)   예제 코드  1. 버튼 추가     버튼을 선택했을 때 Alert 창을 띄우기 위해서 버튼을 추가합니다.   “alert 테스트” 버튼을 추가했습니다.    2. UIAlertController 생성  @IBAction func alertTestButtonTapped(_ sender: UIButton) {     //제목은 할일 추가로, 메시지는 할일을 추가하세요로 표시     let alertController = UIAlertController(title: \"할일 추가\", message: \"할일을 추가하세요\", preferredStyle: .alert) }   3. UIAlertController를 화면에 표시 (present)  @IBAction func alertTestButtonTapped(_ sender: UIButton) {     let alertController = UIAlertController(title: \"할 일 추가\", message: \"할 일을 추가하세요\", preferredStyle: .alert)      //present 메서드를 사용하여 화면에 모달로 표시, 추가하지 않으면 안보임     self.present(alertController, animated: true, completion: nil) }   4. alert 동작 확인     preferredStyle에 따라서 스타일이 달라집니다.                  preferredStyle: .alert       preferredStyle: .actionSheet                                         5. alert에 취소 버튼 추가     alert 창에서 버튼이 없어서 창을 닫을 수가 없습니다.   취소 버튼을 추가합니다.     @IBAction func alertTestButtonTapped(_ sender: UIButton) {   let alertController = UIAlertController(title: \"할 일 추가\", message: \"할 일을 추가하세요\", preferredStyle: .alert)    // \"취소\" 버튼을 생성합니다. 제목은 \"취소\"로, 스타일은 .cancel로 설정합니다.           let cancelButton = UIAlertAction(title: \"취소\", style: .cancel, handler: nil)   //생성한 \"취소\" 버튼을 UIAlertController에 추가합니다.   alertController.addAction(cancelButton)        self.present(alertController, animated: true, completion: nil) }           취소 버튼이 생기고 취소가 가능해졌습니다.     6. alert에 TextField 추가     UIAlertController의 addTextField를 사용하여 TextField를 추가합니다.     alertController.addTextField { textField in   textField.placeholder = \"할 일을 입력하세요.\" }           텍스트 필드를 확인 할 수 있습니다.     7. TextField를 처리할 추가 버튼 생성     취소 버튼 추가할때와 방법이 같습니다.     let addButton = UIAlertAction(title: \"추가\", style: .default)  alertController.addAction(addButton)                           실행해보면 버튼은 추가 됐는데 입력값을 처리할 수 없습니다.   입력 값 확인을 위해 코드를 수정합니다.     let addButton = UIAlertAction(title: \"추가\", style: .default) { _ in   // 사용자가 입력한 값을 확인하고 처리합니다.   if let textField = alertController.textFields?.first, let text = textField.text {       print(\"입력된 값: \\(text)\")   } } alertController.addAction(addButton)                     값 입력     출력 결과 확인    마무리     UIAlertController를 사용하면 delegate를 사용하지 않고도 사용자의 상호작용을 처리할 수 있다 !!!  ","categories": ["UIKit"],
        "tags": ["swift","iOS","UIAlertController"],
        "url": "/UIKit/UIAlertController/",
        "teaser": null
      },{
        "title": "[UIKit] present 코드로 화면 이동 (스토리보드 view -> viewController 파일)",
        "excerpt":"코드로 화면 이동     스토리보드 라이브러리에서 view Controller를 추가하지 않고 코드로 작성하여 화면을 이동하는 방법입니다.   1. cocoa touch class 파일 생성     프로젝트에서 우클릭    코코아 터치 클래스 선택     클래스 이름을 정하고 Subclass를 UIViewController로 설정     파일 생성     2. ViewController에서 추가한 컨트롤러 불러오기  버튼 생성 및 코드 추가     ViewController에서 버튼을 생성하고 연결합니다.     화면 연결을 위해 코드를 추가합니다.     @IBAction func nextButtonTapped(_ sender: UIButton) {   let nextVC = NextViewController()   //새로만든 클래스 인스턴스 생성하고 변수에 할당     //present메서드를 사용하여 nextVC를 화면에 표시합니다.    present(nextVC, animated: false, completion: nil)      /*   첫 번째 매개변수 (nextVC): 표시할 뷰 컨트롤러   두 번째 매개변수 (animated): 화면에 애니메이션 표시 유무    세 번째 매개변수 (completion): 뷰 컨트롤러가 표시된 후에 실행할 클로저, 없으면 nil     */ }          실행       실행하면 뭐가 화면이 뜬건지 기존 화면이 작아진 건지 알 수 없습니다.   만들어진 클래스에서 코드를 수정합니다.                                    3. 새로 만든 클래스 파일 수정  Label 추가  import UIKit class NextViewController: UIViewController {     var nextViewLabel = UILabel() //Label 추가      화면에서 label을 볼 수 있게 기본 text를 입력하고 view.addSubview(nextViewLabel) 코드를 추가합니다.     override func viewDidLoad() {   super.viewDidLoad()   view.backgroundColor = .systemPink  //화면 배경색을 핑크로                 nextViewLabel.text = \"Hello\"    //현재 UIViewController의 뷰 계층 구조에 새로운 UILabel을 추가   //화면에 새로운 텍스트 레이블이 추가되어 사용자에게 표시    view.addSubview(nextViewLabel)   }          실행       오토레이아웃을 설정하지 않아서 Hello가 보이지 않습니다.     오토레이아웃 설정     오토레이아웃을 설정합니다.     override func viewDidLoad() {   super.viewDidLoad()   view.backgroundColor = .systemPink  //화면 배경색을 핑크로                 nextViewLabel.text = \"Hello\"    //현재 UIViewController의 뷰 계층 구조에 새로운 UILabel을 추가   //화면에 새로운 텍스트 레이블이 추가되어 사용자에게 표시    view.addSubview(nextViewLabel)          // nextViewLabel의 autoresizing mask를 사용하지 않고 수동으로 레이아웃을 설정   nextViewLabel.translatesAutoresizingMaskIntoConstraints = false   //x축 가운데 위치   nextViewLabel.centerXAnchor.constraint(equalTo: view.centerXAnchor).isActive = true   //y축 가운데 위치   nextViewLabel.centerYAnchor.constraint(equalTo: view.centerYAnchor).isActive = true }           스토리보드에서 하는 x,y 설정이 아래 3줄 코드와 같습니다.       nextViewLabel.translatesAutoresizingMaskIntoConstraints = false nextViewLabel.centerXAnchor.constraint(equalTo: view.centerXAnchor).isActive = true nextViewLabel.centerYAnchor.constraint(equalTo: view.centerYAnchor).isActive = true           실행     정상적으로 Hello가 출력 된 것을 알 수 있습니다.   화면을 아래로 드래그하면 화면이 닫힙니다.     4. View 컨트롤러에서 Text값 전달하여 화면에 출력     Hello 고정 값이 아닌 ViewController에서 문자열을 받아와 출력하는 방법입니다.   추가한 클래스 수정  var nextViewLabel = UILabel() //Label 추가  //label 아래에 옵셔널 변수를 추가합니다.  var testLabel: String?  //View에서 문자열을 받기 위해 추가  // 그리고 ViewDidLoad 함수 안에 코드를 수정합니다.  override func viewDidLoad() {     super.viewDidLoad()     view.backgroundColor = .systemPink  //화면 배경색                  //nextViewLabel.text = \"Hello\"  //기존코드 주석     nextViewLabel.text = testLabel  //Hello 문자열을 변수로 변경      text가 옵셔널 타입으로 되어있어 옵셔널 변수를 추가    View Controller 수정     기존 코드에 넘겨줄 문자열을 추가합니다     @IBAction func nextButtonTapped(_ sender: UIButton) {   let nextVC = NextViewController()      nextVC.testLabel = \"안녕하세요~~!!\" //추가   present(nextVC, animated: false, completion: nil)    }           실행     정상적으로 문자열을 받아 출력    5. 버튼을 만들어서 버튼으로 화면 닫기  var nextViewLabel = UILabel() var testLabel: String?   var backButton = UIButton()     //버튼 추가   //버튼 셋팅 추가  override func viewDidLoad() {     backButton.setTitle(\"뒤로가기!\", for: .normal)     backButton.addTarget(self, action: #selector(backButtonTapped), for: .touchUpInside)     view.addSubview(backButton)      backButton.translatesAutoresizingMaskIntoConstraints = false          backButton.widthAnchor.constraint(equalToConstant: 70).isActive = true     backButton.heightAnchor.constraint(equalToConstant: 40).isActive = true     backButton.bottomAnchor.constraint(equalTo: view.bottomAnchor, constant: -40).isActive = true     backButton.centerXAnchor.constraint(equalTo: view.centerXAnchor).isActive = true } // 버튼 종료 추가  @objc func backButtonTapped() {     //dissmiss는 모달로 표시된 뷰 컨트롤러를 제거함      dismiss(animated: true, completion: nil)    // 전 화면으로 돌아가기     /*     첫번째 파라미터: 모달이 제거되는 애니메이션 실행 유무      두번째 파라미터: 모달이 제거된 후에 실행할 클로저, 없으면 nil      */ }  화면                                    마무리     코드로 화면표시 present(), 코드로 화면 닫기 dismiss()  ","categories": ["UIKit"],
        "tags": ["swift","iOS","present","dismiss"],
        "url": "/uikit/%EC%BD%94%EB%93%9C%EB%A1%9C%ED%99%94%EB%A9%B4%EC%9D%B4%EB%8F%991/",
        "teaser": null
      },{
        "title": "[프로그래머스/Swift] 푸드 파이트 대회",
        "excerpt":"문제 설명     수웅이는 매달 주어진 음식을 빨리 먹는 푸드 파이트 대회를 개최합니다. 이 대회에서 선수들은 1대 1로 대결하며, 매 대결마다 음식의 종류와 양이 바뀝니다. 대결은 준비된 음식들을 일렬로 배치한 뒤, 한 선수는 제일 왼쪽에 있는 음식부터 오른쪽으로, 다른 선수는 제일 오른쪽에 있는 음식부터 왼쪽으로 순서대로 먹는 방식으로 진행됩니다. 중앙에는 물을 배치하고, 물을 먼저 먹는 선수가 승리하게 됩니다.   이때, 대회의 공정성을 위해 두 선수가 먹는 음식의 종류와 양이 같아야 하며, 음식을 먹는 순서도 같아야 합니다. 또한, 이번 대회부터는 칼로리가 낮은 음식을 먼저 먹을 수 있게 배치하여 선수들이 음식을 더 잘 먹을 수 있게 하려고 합니다. 이번 대회를 위해 수웅이는 음식을 주문했는데, 대회의 조건을 고려하지 않고 음식을 주문하여 몇 개의 음식은 대회에 사용하지 못하게 되었습니다.   예를 들어, 3가지의 음식이 준비되어 있으며, 칼로리가 적은 순서대로 1번 음식을 3개, 2번 음식을 4개, 3번 음식을 6개 준비했으며, 물을 편의상 0번 음식이라고 칭한다면, 두 선수는 1번 음식 1개, 2번 음식 2개, 3번 음식 3개씩을 먹게 되므로 음식의 배치는 “1223330333221”이 됩니다. 따라서 1번 음식 1개는 대회에 사용하지 못합니다.        수웅이가 준비한 음식의 양을 칼로리가 적은 순서대로 나타내는 정수 배열 food가 주어졌을 때, 대회를 위한 음식의 배치를 나타내는 문자열을 return 하는 solution 함수를 완성해주세요.       문제 풀기   제한사항     2 ≤ food의 길이 ≤ 9   1 ≤ food의 각 원소 ≤ 1,000   food에는 칼로리가 적은 순서대로 음식의 양이 담겨 있습니다.   food[i]는 i번 음식의 수입니다.   food[0]은 수웅이가 준비한 물의 양이며, 항상 1입니다.   정답의 길이가 3 이상인 경우만 입력으로 주어집니다.   입출력 예                  food       result                       [1, 3, 4, 6]       “1223330333221”                 [1, 7, 1, 2]       “111303111”           입출력 예 설명  입출력 예 #1     문제 예시와 같습니다.   입출력 예 #2     두 선수는 1번 음식 3개, 3번 음식 1개를 먹게 되므로 음식의 배치는 “111303111”입니다.   나의 풀이  import Foundation  func solution(_ food:[Int]) -&gt; String {     var arr: [Int] = []     //배열 앞부분 구하기     for (index, value) in food.dropFirst().map({ $0 / 2 }).enumerated() {         for i in 0..&lt;value {             arr.append(index + 1)         }     }          //배열 뒷부분은 추가     for (index,value) in arr.reversed().enumerated() {         if index == 0 {             //0번일땐 두개 추가              arr.append(0)             arr.append(value)         } else {             arr.append(value)         }     }     //문자열로 변경     return arr.reduce(\"\"){$0 + String($1)} }  다른 사람 풀이  import Foundation  func solution(_ food:[Int]) -&gt; String {     var result = \"\"     for i in food.indices {         result += String(repeating: String(i), count: food[i] / 2)     }     return result + \"0\" + result.reversed() }   의견     map, enumerated, reversed, reduce에 조금 익숙해졌고 첫번째 값을 버릴 수 있는 dropFirst를 알았다.   다른 사람들은 append를 잘 사용하지 않는 것 같다. 다른 방법에 대해서도 찾아보고 익숙해져야겠다.  ","categories": ["Algorithm"],
        "tags": ["Algorithm","coding test","푸드 파이트 대회"],
        "url": "/algorithm/%ED%91%B8%EB%93%9C%ED%8C%8C%EC%9D%B4%ED%8A%B8%EB%8C%80%ED%9A%8C/",
        "teaser": null
      },{
        "title": "[TIL] 내배캠 iOS앱 개발 공부 19일차",
        "excerpt":"데일리 스크럼     알고리즘     map, enumerated, reversed, reduce 골고루 사용해서 풀었다.   풀이 보기            푸드 파이트 대회           개인 과제 공부     오늘은 개인 과제 키워드 중 하나인 AlertController에 대해서 공부하고 실습했다.   UIAlertController를 사용하면 delegate를 사용하지 않고도 사용자의 상호작용을 처리할 수 있다.            얼러트 컨트롤러           내일 목표     table View Cell에서 처리한 데이터를 주고 받는 공부가 필요한 것 같다.   알고리즘 문제 풀기   키워드 하나씩 실습 하기   과제 풀기  ","categories": ["TIL"],
        "tags": ["TIL"],
        "url": "/TIL/til19/",
        "teaser": null
      },{
        "title": "[UIKit] Label 밑줄(underline) 및 가운데줄/취소선(Strikethrough) 긋기",
        "excerpt":"NSAttributedString     텍스트에 대한 서식 및 스타일을 적용하는 데 사용되는 클래스입니다.   NSAttributedString을 사용하면 단순한 문자열을 포맷하고, 텍스트에 다양한 스타일, 폰트, 색상, 그리기 속성 등을 적용할 수 있습니다.   UILabel, UITextView 및 UITextField와 같은 텍스트 표시 및 입력 컨트롤에서 사용할 수 있습니다.   예제 코드     Label을 추가하고 버튼을 선택했을 때 Label에 밑줄 및 취소선이 생기는 예제입니다.   1. Label 및 버튼 추가     2. String 확장(extension) 메서드 구현  extension String {     // MARK: - 밑줄     func underScore() -&gt; NSAttributedString {         let underScore = NSMutableAttributedString(string: self)                 // 전체 문자열에 밑줄 스타일 속성을 추가         underScore.addAttribute(.underlineStyle, value: NSUnderlineStyle.single.rawValue, range: NSMakeRange(0, underScore.length))         return underScore     }     // MARK: - 가운데 밑줄     func strikeThrough() -&gt; NSAttributedString {         let attributeString = NSMutableAttributedString(string: self)          // 전체 문자열에 가운데 밑줄 스타일 속성을 추가         // NSAttributedString.Key를 사용하여 서식과 속성을 적용할 수 있음(NSAttributedString.Key.strikethroughStyle을 .strikethroughStyle로 사용 가능)         attributeString.addAttribute(NSAttributedString.Key.strikethroughStyle, value: NSUnderlineStyle.single.rawValue, range: NSMakeRange(0, attributeString.length))                 return attributeString     } }   3. 밑줄(underline) 버튼 이벤트  @IBAction func underLineButtonTapped(_ sender: UIButton) {     // 레이블의 텍스트에 밑줄을 추가하고 적용     myLabel.attributedText = myLabel.text?.underScore() }   4. 취소선(strikethough) 버튼 이벤트  @IBAction func centerLineButtonTapped(_ sender: UIButton) {     // 레이블의 텍스트에 가운데 밑줄을 추가하고 적용     myLabel.attributedText = myLabel.text?.strikeThrough() }   5. 실행 확인          밑줄(underline)             취소선(strikethough)        마무리     NSAttributedString을 사용하면 다양한 스타일을 적용하여 텍스트를 꾸미는 데 유용하다.   NSAttributedString은 한 번 생성되면 수정할 수 없음. 텍스트를 수정하려면 새로운 NSAttributedString을 생성해야함.  ","categories": ["UIKit"],
        "tags": ["swift","iOS","underline","Strikethrough"],
        "url": "/UIKit/underlineAndStrikethrough/",
        "teaser": null
      },{
        "title": "[프로그래머스/Swift] 콜라 문제",
        "excerpt":"문제 설명     오래전 유행했던 콜라 문제가 있습니다. 콜라 문제의 지문은 다음과 같습니다.            정답은 아무에게도 말하지 마세요.       콜라 빈 병 2개를 가져다주면 콜라 1병을 주는 마트가 있다. 빈 병 20개를 가져다주면 몇 병을 받을 수 있는가?       단, 보유 중인 빈 병이 2개 미만이면, 콜라를 받을 수 없다.           문제를 풀던 상빈이는 콜라 문제의 완벽한 해답을 찾았습니다. 상빈이가 푼 방법은 아래 그림과 같습니다. 우선 콜라 빈 병 20병을 가져가서 10병을 받습니다. 받은 10병을 모두 마신 뒤, 가져가서 5병을 받습니다. 5병 중 4병을 모두 마신 뒤 가져가서 2병을 받고, 또 2병을 모두 마신 뒤 가져가서 1병을 받습니다. 받은 1병과 5병을 받았을 때 남은 1병을 모두 마신 뒤 가져가면 1병을 또 받을 수 있습니다. 이 경우 상빈이는 총 10 + 5 + 2 + 1 + 1 = 19병의 콜라를 받을 수 있습니다.   문제를 열심히 풀던 상빈이는 일반화된 콜라 문제를 생각했습니다. 이 문제는 빈 병 a개를 가져다주면 콜라 b병을 주는 마트가 있을 때, 빈 병 n개를 가져다주면 몇 병을 받을 수 있는지 계산하는 문제입니다. 기존 콜라 문제와 마찬가지로, 보유 중인 빈 병이 a개 미만이면, 추가적으로 빈 병을 받을 순 없습니다. 상빈이는 열심히 고심했지만, 일반화된 콜라 문제의 답을 찾을 수 없었습니다. 상빈이를 도와, 일반화된 콜라 문제를 해결하는 프로그램을 만들어 주세요.        콜라를 받기 위해 마트에 주어야 하는 병 수 a, 빈 병 a개를 가져다 주면 마트가 주는 콜라 병 수 b, 상빈이가 가지고 있는 빈 병의 개수 n이 매개변수로 주어집니다. 상빈이가 받을 수 있는 콜라의 병 수를 return 하도록 solution 함수를 작성해주세요.       문제 풀기   제한사항     1 ≤ b &lt; a ≤ n ≤ 1,000,000   정답은 항상 int 범위를 넘지 않게 주어집니다.   입출력 예                  a       b       n       result                       2       1       20       19                 3       1       20       9           입출력 예 설명  입출력 예 #1     본문에서 설명한 예시입니다.   입출력 예 #2     빈 병 20개 중 18개를 마트에 가져가서, 6병의 콜라를 받습니다. 이때 상빈이가 가지고 있는 콜라 병의 수는 8(20 – 18 + 6 = 8)개 입니다.   빈 병 8개 중 6개를 마트에 가져가서, 2병의 콜라를 받습니다. 이때 상빈이가 가지고 있는 콜라 병의 수는 4(8 – 6 + 2 = 4)개 입니다.   빈 병 4 개중 3개를 마트에 가져가서, 1병의 콜라를 받습니다. 이때 상빈이가 가지고 있는 콜라 병의 수는 2(4 – 3 + 1 = 2)개 입니다.   3번의 교환 동안 상빈이는 9(6 + 2 + 1 = 9)병의 콜라를 받았습니다.   나의 풀이  import Foundation func solution(_ a:Int, _ b:Int, _ n:Int) -&gt; Int {     //a = 반납 콜라, b = 받는 콜라, n = 가진 콜라     var quotient: Int = 0   //몫     var remainder: Int = 0  //나머지     var myCoke: Int = n     var result: Int = 0          while true {         if myCoke / a == 0 {             break         } else {             quotient = myCoke / a             remainder = myCoke % a                          result += (quotient * b) //받는 콜라 계산             myCoke = (quotient * b) + remainder         }     }     return result }   다른 사람 풀이  func solution(_ a:Int, _ b:Int, _ n:Int) -&gt; Int {     return (n &gt; b ? n - b : 0) / (a - b) * b }   의견     벽이 느껴지는 다른 사람의 풀이에 감탄했다…  ","categories": ["Algorithm"],
        "tags": ["Algorithm","coding test","콜라 문제"],
        "url": "/algorithm/%EC%BD%9C%EB%9D%BC%EB%AC%B8%EC%A0%9C/",
        "teaser": null
      },{
        "title": "[TIL] 내배캠 iOS앱 개발 공부 20일차",
        "excerpt":"데일리 스크럼     알고리즘     반복문 없이 고차함수 없이 한 줄로 푼 사람이 있어 벽을 느꼈다.   풀이 보기            콜라문제           개인 과제 공부     TableView에서 Datasource 필수 메서드 구현 및 TableViewCell을 상속받아 클래스를 만들기, TableView에서 row수와 row의 cell 데이터 출력 방법을 공부했다.            데이터 목록 표시           내일 목표     오늘 알고리즘에서도 약간 자존감 떨어졌는데 개인 과제의 속도도 빠르고 꾸미기도 잘 꾸미신분을 보고 자극을 받았다! 내일은 조금 더 속도를 내보는 걸로   알고리즘 문제 풀기   키워드 하나씩 실습 하기   과제 풀기  ","categories": ["TIL"],
        "tags": ["TIL"],
        "url": "/TIL/til20/",
        "teaser": null
      },{
        "title": "[UIKit] UITableView - 데이터 목록 표시",
        "excerpt":"UITableView     세로로만 스크롤 가능한 뷰   iOS 애플리케이션에서 테이블 형식의 데이터를 표시하고 관리하는 데 사용되는 중요한 뷰 컴포넌트입니다.   테이블 뷰는 여러 행으로 구성되며, 각 행에는 하나 이상의 셀이 포함됩니다.   각 셀은 사용자 인터페이스에 정보를 표시하거나 사용자 상호 작용을 위한 컨트롤을 제공합니다.   특징     다양한 셀 유형            UITableView는 특정 유형의 데이터를 표시하기 위해 다양한 스타일과 레이아웃의 셀을 지원합니다. 텍스트, 이미지, 버튼 등 다양한 컨텐츠를 포함할 수 있습니다.           스크롤 기능            테이블 뷰는 데이터가 많거나 너무 긴 경우에도 스크롤하여 모든 데이터에 접근할 수 있도록 합니다.           섹션 및 인덱스            UITableView는 섹션을 사용하여 데이터를 구성하고 섹션 인덱스를 제공하여 사용자가 특정 부분으로 빠르게 이동할 수 있도록 합니다.           셀 재사용            UITableView는 셀을 효율적으로 관리하기 위해 셀 재사용 메커니즘을 사용합니다. 이는 메모리 사용량을 최적화하고 성능을 향상시킵니다.           델리게이트 및 데이터 소스            UITableView는 UITableViewDelegate 및 UITableViewDataSource 프로토콜을 사용하여 사용자 상호 작용 및 데이터 관리를 처리합니다. 데이터 소스는 UITableView에 표시할 데이터를 제공하고, 델리게이트는 사용자 상호 작용 및 테이블 뷰의 동작을 제어합니다.           사용     iOS 애플리케이션에서 매우 일반적으로 사용됩니다.   메시지 리스트, 설정 화면, 사용자 목록 등   UITableView 설정 예제 코드   1. 스토리보드에 Table View 추가     2. TableView 아울렛 변수 추가     스토리보드에 추가한 객체에 접근 할 수 있는 아울렛 변수 추가   class ViewController: UIViewController {         @IBOutlet weak var toDoListTableView: UITableView!       override func viewDidLoad() {         super.viewDidLoad()     }   3. TableView DataSource 추가 및 필수 메서드 구현     ViewController 클래스에 UITableViewDataSource 프로토콜을 확장(extension)하여 UITableViewDataSource 프로토콜의 메서드를 구현   extension ViewController: UITableViewDataSource {     //특정 섹션(section)에 표시할 행(row)의 수를 반환     public func tableView(_ tableView: UITableView, numberOfRowsInSection section: Int) -&gt; Int {         return 10   //10개의 행을 반환하여 표시      }          //메서드는 특정 indexPath에 해당하는 행의 셀을 반환     public func tableView(_ tableView: UITableView, cellForRowAt indexPath: IndexPath) -&gt; UITableViewCell {         //행에 표시할 셀을 생성하고 반환          return UITableViewCell()      } }      섹션은 여러개의 row로 구성된 그룹 (아래 빨간 묶음)    4. DataSource 설정 (델리게이트 설정과 동일)   class ViewController: UIViewController {         @IBOutlet weak var toDoListTableView: UITableView!       override func viewDidLoad() {         super.viewDidLoad()         toDoListTableView.dataSource = self //UITableView의 dataSource를 현재(self)의 ViewController로 설정     }   5. 실행     row 10개가 생겼는데 데이터가 없습니다.     6. row에 Data를 입력하기위해 Cell 추가     라이브러리에서 table view cell을 추가합니다.     7. Cell 식별자(Identifier) 이름 지정          셀을 선택하고 인스펙터(Inspector) 화면에서 식별자 이름을 지정합니다.              식별자 이름을 변경하면 다큐먼트 아웃라인(Document Outline) 화면에서도 변경된 것을 확인할 수 있습니다.         8. Cell에 연결시킬 Class 파일 생성     UITableViewCell를 상속 받는 ToDoCell 클래스를 생성합니다.     9. Cell에 Class 연결     스토리보드에서 Cell을 선택하고 인스펙터 화면에서 클래스를 연결합니다.     10. Cell에 object 추가 및 아울렛 변수 추가     label 2개 스위치 1개를 추가했습니다.     만들어진 객체의 아울렛 변수 추가했습니다.     class ToDoCell: UITableViewCell {   @IBOutlet weak var idLebel: UILabel!        //id   @IBOutlet weak var titleLabel: UILabel!     //title   @IBOutlet weak var isCompleteSwitch: UISwitch!      //스위치         override func awakeFromNib() {       super.awakeFromNib()       // Initialization code   }           11. Cell에 보여줄 배열 생성 및 초기화     구조체 생성 및 배열 초기화       struct ToDo {       var id: Int       var title: String       var isComplete: Bool   }   var toDoListArr: [ToDo] = [       ToDo(id: 1, title: \"테스트1111\", isComplete: true),       ToDo(id: 2, title: \"테스트2222\", isComplete: false),       ToDo(id: 3, title: \"테스트3333\", isComplete: true)   ]           12. UITableViewDataSource 필수 메서드 수정   extension ViewController: UITableViewDataSource {     //특정 섹션에 표시할 행의 수     public func tableView(_ tableView: UITableView, numberOfRowsInSection section: Int) -&gt; Int {         return toDoListArr.count //테이블 뷰에 표시할 셀의 개수를 배열의 수로 변경     }          //특정 indexPath에 해당하는 행의 셀을 반환     public func tableView(_ tableView: UITableView, cellForRowAt indexPath: IndexPath) -&gt; UITableViewCell {         //재사용 가능한 셀을 생성, 식별자를 Cell과 동일하게, cell이 UITableViewCell라서 만들어놓은 Cell로 다운캐스팅         let cell = tableView.dequeueReusableCell(withIdentifier: \"ToDoCell\", for: indexPath) as! ToDoCell                  //ToDoCell 클래스의 아울렛 변수에 배열의 값을 할당         cell.idLebel.text = String(toDoListArr[indexPath.row].id)         cell.titleLabel.text = toDoListArr[indexPath.row].title         cell.isCompleteSwitch.isOn = toDoListArr[indexPath.row].isComplete                  return cell //셀 반환      } }   13. 실행     배열의 데이터을 cell에서 확인할 수 있습니다.     마무리     Table View에서 row와 cell의 데이터는 TableViewDatasource 프로토콜을 채택하여 필수 메서드 구현, viewDidLoad 밑 datasource 설정 필수   UITableViewCell을 상속받는 클래스를 만들고 스토리보드의 Cell과 연결시키기, 스토리보드 Cell의 식별자 추가하기  ","categories": ["UIKit"],
        "tags": ["swift","iOS","UITableView"],
        "url": "/UIKit/UITableView/",
        "teaser": null
      },{
        "title": "[프로그래머스/Swift] 명예의 전당",
        "excerpt":"문제 설명     “명예의 전당”이라는 TV 프로그램에서는 매일 1명의 가수가 노래를 부르고, 시청자들의 문자 투표수로 가수에게 점수를 부여합니다. 매일 출연한 가수의 점수가 지금까지 출연 가수들의 점수 중 상위 k번째 이내이면 해당 가수의 점수를 명예의 전당이라는 목록에 올려 기념합니다. 즉 프로그램 시작 이후 초기에 k일까지는 모든 출연 가수의 점수가 명예의 전당에 오르게 됩니다. k일 다음부터는 출연 가수의 점수가 기존의 명예의 전당 목록의 k번째 순위의 가수 점수보다 더 높으면, 출연 가수의 점수가 명예의 전당에 오르게 되고 기존의 k번째 순위의 점수는 명예의 전당에서 내려오게 됩니다.   이 프로그램에서는 매일 “명예의 전당”의 최하위 점수를 발표합니다. 예를 들어, k = 3이고, 7일 동안 진행된 가수의 점수가 [10, 100, 20, 150, 1, 100, 200]이라면, 명예의 전당에서 발표된 점수는 아래의 그림과 같이 [10, 10, 10, 20, 20, 100, 100]입니다.                 일차         1         2         3         4         5         6         7                   score         10         100         20         150         1         100         200                   명예의 전당 (k = 3)         10         100 10         100 20 10         150 100 20         150 100 20         150 100 100         200 150 100                   발표 점수         10         10         10         20         20         100         100                명예의 전당 목록의 점수의 개수 k, 1일부터 마지막 날까지 출연한 가수들의 점수인 score가 주어졌을 때, 매일 발표된 명예의 전당의 최하위 점수를 return하는 solution 함수를 완성해주세요.            문제 풀기       제한사항     3 ≤ k ≤ 100   7 ≤ score의 길이 ≤ 1,000            0 ≤ score[i] ≤ 2,000           입출력 예                  k       score       result                       3       [10, 100, 20, 150, 1, 100, 200]       [10, 10, 10, 20, 20, 100, 100]                 4       [0, 300, 40, 300, 20, 70, 150, 50, 500, 1000]       [0, 0, 0, 0, 20, 40, 70, 70, 150, 300]           입출력 예 설명  입출력 예 #1     문제의 예시와 같습니다.   입출력 예 #2     아래와 같이, [0, 0, 0, 0, 20, 40, 70, 70, 150, 300]을 return합니다.                일차         1         2         3         4         5         6         7         8         9         10                   score         0         300         40         300         20         70         150         50         500         1000                   명예의 전당 (k = 4)         0         300 0         300 40 0         300 300 40 0         300 300 40 20         300 300 70 40         300 300 150 70         300 300 150 70         500 300 300 150         1000 500 300 300                   발표 점수         0         0         0         0         20         40         70         70         150         300        나의 풀이  import Foundation  func solution(_ k:Int, _ score:[Int]) -&gt; [Int] {     var arr: [Int] = []     //k수만큼 저장     var result: [Int] = []  //결과 값          if (k &gt;= 3 || k &lt;= 100) &amp;&amp; (score.count &gt;= 7 || score.count &lt;= 1000) {          //k개수까지는 무조건 추가         //k개수인 경우 현재 값이 최소값보다 크거나 같으면 최소값을 삭제하고 추가         for i in score {             if arr.count &lt; k {                 arr.append(i)                 arr.sort()                 result.append(arr[0])             } else {                 if let min = arr.min(),                     i &gt;= min {                     arr.remove(at: 0)                     arr.append(i)                     arr.sort()                     result.append(arr[0])                 } else {                     result.append(arr[0])                 }             }         }     }     return result }   다른 사람 풀이  import Foundation func solution(_ k:Int, _ score:[Int]) -&gt; [Int] {     return (0...score.count-1).map{         let end = $0 &lt; k-1 ? $0 : k-1         return Array(score[0...$0].sorted(by: &gt;)[0...end]).last!     } }   의견     런타임 에러가 발생해서 제한사항을 추가했다. 보통 없어도 통과인데 간혹 제한사항 추가해야하는 문제가 있다.   대부분 비슷한 풀이인데 짧게 푼 코드를 찾았다. 다른 사람 코드로 또 배우는 중..  ","categories": ["Algorithm"],
        "tags": ["Algorithm","coding test","명예의 전당"],
        "url": "/algorithm/%EB%AA%85%EC%98%88%EC%9D%98%EC%A0%84%EB%8B%B9/",
        "teaser": null
      },{
        "title": "[TIL] 내배캠 iOS앱 개발 공부 21일차",
        "excerpt":"데일리 스크럼     알고리즘     고차함수를 많이 연습해보고 알고리즘 문제 풀어야하는데 따로 공부없이 아침에 문제를 풀다보니 많이 부족한 것 같다. 꼭 시간내서 클로저, 고차함수 다시.. 공부해봐야겠다   풀이 보기            명예의전당           개인 과제 공부     오늘은 속도를 내서 level3 삭제까지 완료하고 순서바꾸기를 추가했다.   검색 하는 도중에 자동완성이 안되는 메서드가 있었는데 TableViewController를 상속받아 파일을 생성하면 기본적으로 주석처리된 메서드가 있다는걸 알았다.   Delegate에서 제공하는 함수를 많이 알면 다양하게 적용을 시도해 볼 수 있을 것 같다!            Tableview Cell에서 Delegate 사용       Tableview에서 Swipe로 Row 삭제하기       NavigationBar에 Edit 버튼 추가하기       TableView 목록 순서 바꾸기           내일 목표     다른 분들이 UI를 스위치에서 체크박스로 바꾸고 폰트도 변경하고 조금 꾸며도 꾸민 티가 확 나는 것 같다. 내일은 꾸미기에도 조금 도전해보는걸로…   알고리즘 문제 풀기 (문제 풀고 고차함수 연습 꼭 10분이라도..)   과제 풀기  ","categories": ["TIL"],
        "tags": ["TIL"],
        "url": "/TIL/til21/",
        "teaser": null
      },{
        "title": "[UIKit] NavigationBar에 Edit 버튼 추가하기",
        "excerpt":"Navigation Bar에 Edit 버튼 추가하기     navigation과 연결된 상태에서 viewDidLoad에 코드를 추가합니다.       override func viewDidLoad() {         super.viewDidLoad()                  myTodoListTableView.dataSource = self         myTodoListTableView.delegate = self                  //상단 Navigation bar 왼쪽에 Edit 버튼 추가         self.navigationItem.leftBarButtonItem = self.editButtonItem      }       실행 화면     네비게이션 바 왼쪽에 edit 버튼이 생기고 edit 버튼을 누르면 done으로 바뀝니다.   edit 버튼을 선택 시 아무런 변화가 없습니다.               Delegate 상속 후 setEditing 메서드를 추가     UITableViewDelegate를 채택하고 setEditing 메서드를 추가합니다.       override func setEditing(_ editing: Bool, animated: Bool) {         //부모클래스 편집 모드 설정에 관련된 작업을 수행, 없으면 Done 버튼 사라짐          super.setEditing(editing, animated: animated)                   //사용자가 편집 모드로 전환할 때 테이블 뷰의 셀을 편집할 수 있도록 허용하거나 허용하지 않도록 설정         //myTodoListTableView를 편집모드로 변경할 수 있도록 설정          myTodoListTableView.setEditing(editing, animated: true)      }      관련 이벤트가 없으면 ⛔️ 버튼을 클릭하면 아무런 변화가 없습니다.   삭제기능 바로가기       실행 화면              코드가 아닌 스토리보드에 bar Button Item 추가하여 구현하기  1. bar Button Item 추가     라이브러리에서 bar button item을 추가하고 System Item을 Edit으로 변경합니다.      2. 액션버튼 생성     편집모드가 아닐땐 Edit 버튼이 보여야하고 편집모드일때는 Done 버튼이 보여야합니다.   새로운 버튼 설정을 하지 않으면 button title이 edit로만 보입니다.   // MARK: - edit 창 선택 @IBAction func editButtonTapped(_ sender: UIBarButtonItem) {     //편집 모드와 버튼의 Text는 서로 반대      if myTodoListTableView.isEditing {         // 편집 모드 해제         myTodoListTableView.setEditing(false, animated: true)         // 새로운 UIBarButtonItem 생성하여 Edit 버튼으로 설정         let editButton = UIBarButtonItem(barButtonSystemItem: .edit, target: self, action: #selector(editButtonTapped(_:)))         navigationItem.leftBarButtonItem = editButton     } else {         // 편집 모드 활성화         myTodoListTableView.setEditing(true, animated: true)                  // 새로운 UIBarButtonItem 생성하여 Done 버튼으로 설정         let doneButton = UIBarButtonItem(barButtonSystemItem: .done, target: self, action: #selector(editButtonTapped(_:)))         navigationItem.leftBarButtonItem = doneButton     } }       마무리     Navigation Bar에 버튼을 추가하고 TableView Delegate를 채택하여 TableView 편집모드 구현가능  ","categories": ["UIKit"],
        "tags": ["swift","iOS","Navigation","Bar","Edit","Button"],
        "url": "/UIKit/NavigationBarEditButton/",
        "teaser": null
      },{
        "title": "[UIKit] Tableview에서 Swipe로 Row 삭제하기",
        "excerpt":"Tableview에서 Swipe로 Row 삭제하기     TableView에서 Row을 움직여 삭제할 수 있습니다.       예제 코드      // MARK: - TableView 스와이프(swipe) 삭제     func tableView(_ tableView: UITableView, commit editingStyle: UITableViewCell.EditingStyle, forRowAt indexPath: IndexPath) {         // 편집 스타일이 삭제인 경우          if editingStyle == .delete {             //해당 indexPath에 위치한 데이터를 배열에서 제거             myToDoListArray.remove(at: indexPath.row)             // 테이블 뷰에서 해당 행을 애니메이션과 함께 삭제             tableView.deleteRows(at: [indexPath], with: .fade)         }      }       실행화면              버튼 이름 변경     버튼 이름 변경 (Delete -&gt; 삭제)   UITableViewDelegate 채택해야 사용 가능       // MARK: - 삭제 글자 변경 Delete -&gt; 삭제     func tableView(_ tableView: UITableView, titleForDeleteConfirmationButtonForRowAt indexPath: IndexPath) -&gt; String? {         return \"삭제\"     }      버튼 이름 변경 확인          삭제 전 alert 버튼으로 다시 확인하기     alert 추가 코드       // MARK: - TableView 스와이프(swipe) 삭제     func tableView(_ tableView: UITableView, commit editingStyle: UITableViewCell.EditingStyle, forRowAt indexPath: IndexPath) {         if editingStyle == .delete {             let alertController = UIAlertController(title: \"삭제 확인\", message: \"삭제하시겠습니까?\", preferredStyle: .alert)             let cancelButton = UIAlertAction(title: \"취소\", style: .cancel)             let deleteButton = UIAlertAction(title: \"삭제\", style: .default) { _ in                 //해당 indexPath에 위치한 데이터를 배열에서 제거                 self.myToDoListArray.remove(at: indexPath.row)                 // 테이블 뷰에서 해당 행을 애니메이션과 함께 삭제                 tableView.deleteRows(at: [indexPath], with: .fade)             }             alertController.addAction(cancelButton)             alertController.addAction(deleteButton)             present(alertController, animated: true, completion: nil)         }      }     alert 창 확인          마무리     TableView의 편집 버튼을 눌러 삭제를 시도할 수 있지만 Swipe로 삭제 가능   삭제를 되물어보는 기능이 없어 따로 만들어야함   해당 메서드가 XCode에서 자동검색이 되지 않는 것 같다.            ⭐️⭐️⭐️더 찾아보니 내 클래스 파일은 UIViewController를 상속받는 클래스인데 UITableViewController를 상속받는 클래스 파일을 만들면 주석처리된 메서드가 그냥 보인다!!!!!⭐️⭐️⭐️           /*   // Override to support editing the table view.   override func tableView(_ tableView: UITableView, commit editingStyle: UITableViewCell.EditingStyle, forRowAt indexPath: IndexPath) {   if editingStyle == .delete {       // Delete the row from the data source       tableView.deleteRows(at: [indexPath], with: .fade)   } else if editingStyle == .insert {       // Create a new instance of the appropriate class, insert it into the array, and add a new row to the table view   }       }   */                          ","categories": ["UIKit"],
        "tags": ["swift","iOS","TableView Swipe Delete"],
        "url": "/UIKit/TableViewSwipeDelete/",
        "teaser": null
      },{
        "title": "[UIKit] Tableview Cell에서 Delegate 사용",
        "excerpt":"TableViewCell과 ViewController와 상호작용     TableViewCell에는 ViewController에서 가져온 데이터를 보여줍니다.   Cell에서 스위치의 데이터를 변경하고 새로운 데이터를 추가하면 switch 정보가 초기화가 됩니다.   Cell에서 스위치를 변경할때 ViewController의 배열의 값도 변경하면 새로운 값이 추가되어도 스위치의 Value가 바뀌지 않을 것 입니다.          예제 코드     Cell에서 스위치를 변경할때 ViewController의 배열의 값도 변경하면 새로운 값이 추가되어도 스위치의 Value가 바뀌지 않도록하는 예제입니다.   1. 스위치 ValueChanged 액션함수 생성     Cell 클래스에 액션 함수 추가   // MARK: - 스위치 변경 이벤트 @IBAction func switchValueChanged(_ sender: UISwitch) { }   2. 스위치 Delegate 프로토콜 정의     스위치 값이 변경될때마다 해당 정보를 View Controller로 전달 할 수 있는 프로토콜을 Cell class에 정의합니다.   import UIKit  //스위치 값이 변경될때마다 해당 정보를 View Controller로 전달 할 수 있는 프로토콜을 정의 protocol MyToDoListCellDelegate: AnyObject {     func switchValueChanged(_ cell: MyToDoListCell, isOn: Bool) // 스위치 값 변경 시 호출할 메서드 }  class MyToDoListCell: UITableViewCell {   3. 스위치 Delegate 선언  // 스위치 값 변경 이벤트를 처리할 delegate를 선언합니다. var delegate: MyToDoListCellDelegate?   // 스위치 값 변경 이벤트를 처리할 delegate  override func awakeFromNib() {     super.awakeFromNib() }   4. 스위치 ValueChanged 액션함수 수정  // MARK: - 스위치 변경 이벤트 @IBAction func switchValueChanged(_ sender: UISwitch) {     // delegate를 통해 스위치 값 변경 이벤트를 처리할 메서드를 호출합니다.     delegate?.switchValueChanged(self, isOn: sender.isOn) }   5. ViewController에서 스위치 델리게이트 채택     ViewController를 확장하여 스위치 델리게이트 채택   // MARK: - 스위치 변경 이벤트 처리를 위한 Delegate 채택 extension ViewController: MyToDoListCellDelegate {     //필수메서드를 구현하라고 에러가 발생하고 에러를 선택하면 Cell 클래스에서 만들어 놓은 함수가 만들어진다.      func switchValueChanged(_ cell: MyToDoListCell, isOn: Bool) {           &lt;#code#&gt;     } }   6. Cell의 인덱스를 구하고 스위치 Bool 값을 배열에 반영  // MARK: - 스위치 변경 이벤트 처리를 위한 Delegate 채택 extension ViewController: MyToDoListCellDelegate {   //필수메서드를 구현하라고 에러가 발생하고 에러를 선택하면 Cell 클래스에서 만들어 놓은 함수가 만들어진다.    func switchValueChanged(_ cell: MyToDoListCell, isOn: Bool) {     //해당 셀의 인덱스 가져오기     guard let indexPath = myTodoListTableView.indexPath(for: cell) else {       return     }     // 스위치 값을 배열에 반영     //ViewController에 선언한 myToDoListArray 배열에 변경된 스위치 값 설정       myToDoListArray[indexPath.row].toDoIsComplete = isOn   } }   7. ⭐️⭐️⭐️ 스위치 값 변경 이벤트 처리를 위한 Delegate 설정     cellForRowAt 함수 리턴 부분 위에 cell.delegate = self를 추가합니다.   셀에서 발생한 이벤트를 뷰 컨트롤러에서 처리할 수 있도록 연결합니다.   // MARK: - TableView Row에서 보여줄 컨텐츠 func tableView(_ tableView: UITableView, cellForRowAt indexPath: IndexPath) -&gt; UITableViewCell {     //다른코드 생략      cell.delegate = self    //스위치 값 변경 이벤트 처리를 위한 delegate 설정     return cell }    8. 실행화면     스위치 변경 시 배열의 값도 변경하여 데이터를 추가해도 스위치가 초기화되지 않습니다.          스위치 토글 시 취소선(strikeThrough) 추가  1. String 확장 메서드 구현     참고: [UIKit] Label 밑줄(underline) 및 가운데줄/취소선(Strikethrough) 긋기   // MARK: - String 확장(extension) 메서드에 취소선 구현 extension String {     func strikeThrough() -&gt; NSAttributedString {         // NSAttributedString.Key를 사용하여 서식과 속성을 적용할 수 있음(NSAttributedString.Key.strikethroughStyle을 .strikethroughStyle로 사용 가능)         let attributeString = NSMutableAttributedString(string: self)         // 전체 문자열에 취소선 스타일 속성을 추가         attributeString.addAttribute(NSAttributedString.Key.strikethroughStyle, value: NSUnderlineStyle.single.rawValue, range: NSMakeRange(0, attributeString.length))         return attributeString     } }   2. cellForRowAt 메서드 수정     switch 값에 따른 취소선 적용 및 취소선 취소       // MARK: - TableView Row에서 보여줄 컨텐츠     func tableView(_ tableView: UITableView, cellForRowAt indexPath: IndexPath) -&gt; UITableViewCell {         // 다른코드 생략           //title 취소선 - switch 값에 따라 취소선 또는 일반 Text         if cell.myToDoIsCompleteSwitch.isOn {             // 해당 텍스트에 취소선을 적용한 NSAttributedString을 생성             let attributedText = myToDoListArray[indexPath.row].toDoTitle.strikeThrough()             // 취소선이 적용된 NSAttributedString을 텍스트로 설정             cell.myToDoTitleLabel.attributedText = attributedText         } else {             //일반 Text - 취소선 없애기             cell.myToDoTitleLabel.attributedText = NSAttributedString(string: myToDoListArray[indexPath.row].toDoTitle)         }          cell.delegate = self    //스위치 값 변경 이벤트 처리를 위한 delegate 설정         return cell     }   3. Cell 새로고침 추가     스위치 변경 후 label에 취소선을 적용시키도록 새로고침 추가   myTodoListTableView.reloadRows(at: [indexPath], with: .automatic)   // MARK: - 스위치 변경 이벤트 처리를 위한 Delegate 채택 extension ViewController: MyToDoListCellDelegate {     func switchValueChanged(_ cell: MyToDoListCell, isOn: Bool) {         //해당 셀의 인덱스 가져여오기         guard let indexPath = myTodoListTableView.indexPath(for: cell) else {             return         }                 // 스위치 값을 배열에 반영         myToDoListArray[indexPath.row].toDoIsComplete = isOn         // 스위치가 변경될 때마다 테이블 뷰의 해당 셀만 다시 로드, 취소선 때문에         myTodoListTableView.reloadRows(at: [indexPath], with: .automatic)     } }  4. 실행화면          마무리     데이터를 주는 곳에서 델리게이트를 만들고 데이터를 받는 곳에서 델리게이터를 채택하고 사용            Cell클래스의 @IBAction func switchValueChanged(_ sender: UISwitch) 함수 먼저 실행       View클래스에서 델리게이트 채택 후 switchValueChanged 함수에서 스위치 변경 이벤트 처리          ","categories": ["UIKit"],
        "tags": ["swift","iOS","Tableview Cell Delegate"],
        "url": "/UIKit/UITableViewCellDelegate/",
        "teaser": null
      },{
        "title": "[UIKit] TableView 목록 순서 바꾸기",
        "excerpt":"Table View에 목록 순서 바꾸기     navigation bar에서 Edit 버튼을 선택하고 오른쪽에 줄을 선택하고 드래그하면 순서를 변경할 수 있습니다.       TableView Dalegate 채택 후 moveRowAt 메서드 구현     moveRowAt 메서드에서 source / destination Index를 확인 할 수 있습니다.   // MARK: - 목록 순서 변경 func tableView(_ tableView: UITableView, moveRowAt sourceIndexPath: IndexPath, to destinationIndexPath: IndexPath) {     //현재 row(출발지)의 cell 데이터 저장     let sourceId = myToDoListArray[sourceIndexPath.row].toDoid     let sourceTitle = myToDoListArray[sourceIndexPath.row].toDoTitle     let sourceIsComplete = myToDoListArray[sourceIndexPath.row].toDoIsComplete          //선택한 row 배열에서 삭제     myToDoListArray.remove(at: sourceIndexPath.row)          //이동한 위치에 출발지 cell 데이터를 배열의 목적지 index 위치에 추가     myToDoListArray.insert(ToDoList(toDoid: sourceId, toDoTitle: sourceTitle, toDoIsComplete: sourceIsComplete), at: destinationIndexPath.row)          //print(\"목록 변경 후: \\(myToDoListArray)\")     myTodoListTableView.reloadData()    //변경사항 확인을 위해 새로고침 }       실행 화면              마무리     TableView Dalegate 채택 후 moveRowAt 메서드를 통해 순서이동을 구현할 수 있다.  ","categories": ["UIKit"],
        "tags": ["swift","iOS","TableView","moveRowAt"],
        "url": "/uikit/%EB%AA%A9%EB%A1%9D%EC%88%9C%EC%84%9C%EB%B0%94%EA%BE%B8%EA%B8%B0/",
        "teaser": null
      },{
        "title": "[프로그래머스/Swift] 2016년",
        "excerpt":"문제 설명          2016년 1월 1일은 금요일입니다. 2016년 a월 b일은 무슨 요일일까요? 두 수 a ,b를 입력받아 2016년 a월 b일이 무슨 요일인지 리턴하는 함수, solution을 완성하세요. 요일의 이름은 일요일부터 토요일까지 각각 SUN,MON,TUE,WED,THU,FRI,SAT 입니다. 예를 들어 a=5, b=24라면 5월 24일은 화요일이므로 문자열 “TUE”를 반환하세요.            문제 풀기       제한사항     2016년은 윤년입니다.   2016년 a월 b일은 실제로 있는 날입니다. (13월 26일이나 2월 45일같은 날짜는 주어지지 않습니다)   입출력 예                  a       b       result                       5       24       TUE           나의 풀이  import Foundation func solution(_ a:Int, _ b:Int) -&gt; String {     let weekdays = [\"SUN\", \"MON\", \"TUE\", \"WED\", \"THU\" , \"FRI\", \"SAT\"]     let month = String(format: \"%02d\", a)   //한자리인 경우 앞에 0이 붙도록      let day = String(format: \"%02d\", b)     //한자리인 경우 앞에 0이 붙도록           //문자열을 날짜로 변환하기 위해 사용      let dateFormatter = DateFormatter()     dateFormatter.dateFormat = \"yyyyMMdd\"          guard let date = dateFormatter.date(from: \"2016\" + month + day) else { return \"\" }          let calendar = Calendar.current     //현재 달력 가져오기      let weekday = calendar.component(.weekday, from: date)  //요일 추출하기               return weekdays[weekday - 1] }   다른 사람 풀이  func solution(_ a:Int, _ b:Int) -&gt; String {     let w = [\"THU\", \"FRI\", \"SAT\", \"SUN\", \"MON\", \"TUE\", \"WED\"]     let monthDay = [ 31, 29, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31]     let totalDay = monthDay[0..&lt;a-1].reduce(0, +) + b      return w[totalDay % 7] }   의견     이번에는 날짜 관련된 기능을 알아야 할 것 같아 바로 검색을 하고 풀었다.   좋아요 많은 다른 사람 풀이를 봤지만 2016년 기준이라 DateFormatter, Calendar를 쓰는게 년도 입력으로 확장하기에 더 맞는 방법인 것 같다.  ","categories": ["Algorithm"],
        "tags": ["Algorithm","coding test","2016년"],
        "url": "/algorithm/2016%EB%85%84/",
        "teaser": null
      },{
        "title": "[TIL] 내배캠 iOS앱 개발 공부 22일차",
        "excerpt":"데일리 스크럼     알고리즘     오늘은 특정 날짜의 요일을 맞추는 문제였는데 Swift에서 제공하는 함수로 처리할 수 있을 것 같았다. Swift에서의 Date처리 방법을 확인하고 풀었다.   Date, Calendar 관련은 따로 정리해보고 포스팅 해봐야겠다.   풀이 보기            2016년           개인 과제 공부     NavigationBar에 Edit 버튼을 코드로 추가했었는데 스토리보드에서 Button을 추가하는 걸로 수정했다. Edit 버튼을 선택하면 Done으로 바뀌고 Done을 선택하면 Edit로 바뀌는데 Text 변경이 되지 않아 한참 걸렸다. 버튼을 선택할때 마다 bar button item 설정을 변경하는 것으로 해결했다.   Swipe 삭제도 수정버튼을 추가하려면 다른 메서드를 사용해야해서 다시한다고 시간이 걸렸다. 어떤 메서드를 써야하나 찾는게 시간이 걸린다.   Cell의 오른쪽 Swipe 액션으로 수정/삭제 버튼 구현   내일 목표     꾸미기 도전에는 실패했는데 우선 기능 추가와 완성에 조금 더 집중하는걸로   알고리즘 문제 풀기 (문제 풀고 고차함수 연습 꼭 10분이라도..)   과제 풀기  ","categories": ["TIL"],
        "tags": ["TIL"],
        "url": "/TIL/til22/",
        "teaser": null
      },{
        "title": "[UIKit] Cell의 오른쪽 Swipe 액션으로 수정/삭제 버튼 구현",
        "excerpt":"Cell을 오른쪽 Swipe하여 수정 / 삭제 기능 화면보기     Cell을 오른쪽 Swipe하여 수정, 삭제 버튼을 추가했습니다.   실행화면               예제 코드     UITableViewDelegate 채택 후 trailingSwipeActionsConfigurationForRowAt 메서드를 구현합니다.   특정 indexPath에 해당하는 테이블 뷰 셀의 오른쪽 스와이프 액션을 구성할 때 호출됩니다.   // 오른쪽으로 스와이프할 때의 액션을 구성하는 메서드 func tableView(_ tableView: UITableView, trailingSwipeActionsConfigurationForRowAt indexPath: IndexPath) -&gt; UISwipeActionsConfiguration? {     // 삭제 액션 설정     let deleteAction = UIContextualAction(style: .destructive, title: \"삭제\") { (action, view, completionHandler) in         //삭제 기능 추가          let alertController = UIAlertController(title: \"삭제 확인\", message: \"삭제하시겠습니까?\", preferredStyle: .alert)         let cancelButton = UIAlertAction(title: \"취소\", style: .cancel)         let deleteButton = UIAlertAction(title: \"삭제\", style: .default) { _ in             // 데이터 소스에서 해당 셀에 대한 데이터를 삭제             self.myToDoListArray.remove(at: indexPath.row)             // 테이블 뷰에서 해당 셀을 삭제             tableView.deleteRows(at: [indexPath], with: .fade)         }         alertController.addAction(cancelButton)         alertController.addAction(deleteButton)         self.present(alertController, animated: true)              // 처리 완료 핸들러 호출         completionHandler(true)     }          // 수정 액션 설정     let editAction = UIContextualAction(style: .normal, title: \"수정\") { (action, view, completionHandler) in         //수정 기능 추가          let alertController = UIAlertController(title: \"할 일 입력\", message: \"\", preferredStyle: .alert)         alertController.addTextField { textField in             textField.text = self.myToDoListArray[indexPath.row].toDoTitle         }         let cancelButton = UIAlertAction(title: \"취소\", style: .cancel)         let editButton = UIAlertAction(title: \"수정\", style: .default) { _ in             if let editTextField = alertController.textFields?.first,                 let text = editTextField.text {                 self.myToDoListArray[indexPath.row].toDoTitle = text                 // 수정됐는지 확인하기 위해 row 새로고침                 self.myTodoListTableView.reloadRows(at: [indexPath], with: .automatic)             }         }         alertController.addAction(cancelButton)         alertController.addAction(editButton)         self.present(alertController, animated: true)                  completionHandler(true)     }          // 버튼들을 배열로 묶어서 스와이프 액션 구성     let swipeConfiguration = UISwipeActionsConfiguration(actions: [deleteAction, editAction])          // 스와이프 액션 구성 반환     return swipeConfiguration }   마무리     기존에 사용한 메서드 tableView(_ tableView: UITableView, commit editingStyle: UITableViewCell.EditingStyle, forRowAt indexPath: IndexPath) 삭제   기존에 사용한 메서드에서 스와이프를 통한 삭제 기능을 추가했으나 수정 버튼을 추가할 수 없었다.   스와이프로 원하는 액션을 만들어 구성하는 방법으로 원하는 기능 추가 가능  ","categories": ["UIKit"],
        "tags": ["swift","iOS","Tableview","Cell","Swipe","edit","delete"],
        "url": "/uikit/%EC%85%80%EC%98%A4%EB%A5%B8%EC%AA%BD%EC%8A%A4%EC%99%80%EC%9D%B4%ED%94%84%EC%95%A1%EC%85%98/",
        "teaser": null
      },{
        "title": "[프로그래머스/Swift] 카드뭉치",
        "excerpt":"문제 설명     코니는 영어 단어가 적힌 카드 뭉치 두 개를 선물로 받았습니다. 코니는 다음과 같은 규칙으로 카드에 적힌 단어들을 사용해 원하는 순서의 단어 배열을 만들 수 있는지 알고 싶습니다.            원하는 카드 뭉치에서 카드를 순서대로 한 장씩 사용합니다.       한 번 사용한 카드는 다시 사용할 수 없습니다.       카드를 사용하지 않고 다음 카드로 넘어갈 수 없습니다.       기존에 주어진 카드 뭉치의 단어 순서는 바꿀 수 없습니다.           예를 들어 첫 번째 카드 뭉치에 순서대로 [“i”, “drink”, “water”], 두 번째 카드 뭉치에 순서대로 [“want”, “to”]가 적혀있을 때 [“i”, “want”, “to”, “drink”, “water”] 순서의 단어 배열을 만들려고 한다면 첫 번째 카드 뭉치에서 “i”를 사용한 후 두 번째 카드 뭉치에서 “want”와 “to”를 사용하고 첫 번째 카드뭉치에 “drink”와 “water”를 차례대로 사용하면 원하는 순서의 단어 배열을 만들 수 있습니다.        문자열로 이루어진 배열 cards1, cards2와 원하는 단어 배열 goal이 매개변수로 주어질 때, cards1과 cards2에 적힌 단어들로 goal를 만들 있다면 “Yes”를, 만들 수 없다면 “No”를 return하는 solution 함수를 완성해주세요.       문제 풀기   제한사항     1 ≤ cards1의 길이, cards2의 길이 ≤ 10            1 ≤ cards1[i]의 길이, cards2[i]의 길이 ≤ 10       cards1과 cards2에는 서로 다른 단어만 존재합니다.           2 ≤ goal의 길이 ≤ cards1의 길이 + cards2의 길이            1 ≤ goal[i]의 길이 ≤ 10       goal의 원소는 cards1과 cards2의 원소들로만 이루어져 있습니다.           cards1, cards2, goal의 문자열들은 모두 알파벳 소문자로만 이루어져 있습니다.   입출력 예                  cards1       cards2       goal       result                       [“i”, “drink”, “water”]       [“want”, “to”]       [“i”, “want”, “to”, “drink”, “water”]       “Yes”                 [“i”, “water”, “drink”]       [“want”, “to”]       [“i”, “want”, “to”, “drink”, “water”]       “No”           나의 풀이  import Foundation  func solution(_ cards1:[String], _ cards2:[String], _ goal:[String]) -&gt; String {     var cd1 = cards1     var cd2 = cards2     var removeCnt: Int = 0          for i in goal {         if cd1.count != 0 &amp;&amp; i == cd1[0] {             cd1.remove(at: 0)             removeCnt += 1         } else if cd2.count != 0 &amp;&amp; i == cd2[0] {             cd2.remove(at: 0)             removeCnt += 1         }     }          if goal.count == removeCnt {         return \"Yes\"     } else {         return \"No\"     } }   다른 사람 풀이  import Foundation  func solution(_ cards1:[String], _ cards2:[String], _ goal:[String]) -&gt; String {     var reverseCards1 = Array(cards1.reversed())     var reverseCards2 = Array(cards2.reversed())      for g in goal {         if !reverseCards1.isEmpty &amp;&amp; reverseCards1.last == g {             reverseCards1.removeLast()             continue         }         if !reverseCards2.isEmpty &amp;&amp; reverseCards2.last == g {             reverseCards2.removeLast()             continue         }         return \"No\"     }     return \"Yes\" }   나의 풀이방법     goal을 하나씩 불러와서 card의 첫번째 값과 같으면 remove 시키고 삭제 횟수를 증가, 삭제 횟수가 goal 수가 일치하면 Yes, 아니면 No !   다른사람 풀이     이번에는 다른 사람 풀이도 비슷  ","categories": ["Algorithm"],
        "tags": ["Algorithm","coding test","카드뭉치"],
        "url": "/algorithm/%EC%B9%B4%EB%93%9C%EB%AD%89%EC%B9%98/",
        "teaser": null
      },{
        "title": "[TIL] 내배캠 iOS앱 개발 공부 23일차",
        "excerpt":"데일리 스크럼     알고리즘     문제를 보고 어떻게 풀어야겠다 바로 생각이 들었는데 매일 매일 한문제 풀었던게 효과가 있는 것 같다.   풀이 보기            카드뭉치           개인 과제 공부     화면을 이동해서 데이터를 수정하고 화면을 종료 후 데이터가 수정됐는지 확인하는 기능을 추가했다.   화면 이동을 통해서 델리게이트 사용 연습이 되는 것 같다.   TableView Row 선택 후 화면 이동하기   챌린지반     다음주까지 깃허브 앱 메인 화면을 만들어 보는 과제를 받았다.   api를 사용하여 저장소 수를 받아와야하고 코드를 통해 오토레이아웃을 사용해야한다.   조금 빡센것 같은데 개인 과제 복습하면서 챌린지반 과제도 도전해야겠다!!!   내일 목표     개인과제 코드 정리 및 제출   알고리즘 문제 풀기   챌린지반 과제 분석  ","categories": ["TIL"],
        "tags": ["TIL"],
        "url": "/TIL/til23/",
        "teaser": null
      },{
        "title": "[UIKit] TableView Row 선택 후 화면 이동하기",
        "excerpt":"Row 선택 후 화면 이동하기     ViewController를 만들고 TableView Row를 선택하면 Cell의 정보를 확인하는 방법입니다.   1. 실행화면               2. View Controller 생성 및 세그웨이(Segue) 선택     세그웨이 연결 후 row를 선택하면 View Controller가 연결됩니다.   Cell의 데이터를 View Controller로 전달해주기 위해 설정 및 코드를 추가해야합니다.      3. 세그웨이 식별자 설정     세그웨이 이름을 ToDoDetailSegue로 지정하였습니다.      4. UIViewController를 상속받는 class 파일 생성     DetailViewController 이름의 class 파일 생성했습니다.   5. View Controller에 생성한 class 파일 연결     스토리보드 컨트롤뷰와 클래스파일을 연결합니다.      6. DetailView Controller에서 아울렛 변수 설정     아울렛 변수를 생성하고 코드를 수정합니다.      class DetailViewController: UIViewController {     @IBOutlet weak var titleTextField: UITextField!     @IBOutlet weak var detailTextView: UITextView!          //ViewController에서 전달 받은 데이터를 저장하는 변수      var receiveTitle: String?     var receiveDetail: String?          override func viewDidLoad() {         super.viewDidLoad()         //화면이 실행될때 ViewController에서 받은 데이터를 아울렛 변수에 할당         titleTextField.text = receiveTitle                detailTextView.text = receiveDetail   7. View Controller에서 prepare 매서드 설정     TableView가 있는 클래스파일에서 prepare 메서드 설정       //스토리보드에서의 화면 이동     override func prepare(for segue: UIStoryboardSegue, sender: Any?) {         //화면 이동할때 세그웨이 식별자 확인          if segue.identifier == \"ToDoDetailSegue\" {             let cell = sender as! UITableViewCell   //sender를 UITableViewCell로 캐스팅하여 Cell에 할당              let indexPath = self.myTodoListTableView.indexPath(for: cell)   //TableView에서 선택한 셀의 indexPath 가져오기              let detailView = segue.destination as! DetailViewController     //세그웨이 목적지를 새로만든 클래스파일로 형변환              //DetailViewController에 생성한 아울렛 변수에 title, detail 데이터 할당               detailView.receiveTitle = myToDoListArray[indexPath!.row].toDoTitle                  detailView.receiveDetail = myToDoListArray[indexPath!.row].toDoDetail            }     }   8. 실행     처음 동영상처럼 로우를 선택하면 ViewController의 Cell데이터를 DetailViewController에서도 확인할 수 있습니다.       Detail 화면에서 데이터 수정하기     Detail View Controller에서 Title의 TextField, Detail의 TextView를 수정하고 되돌아 갔을때 ViewController에서도 수정된 데이터를 볼 수 있는 예제입니다.   1. 실행 화면           2. 델리게이트 채택     DetailViewController에서 TextField와 TextView 델리게이트 채택 후 메서드를 구현합니다.   // MARK: - 타이틀 처리를 위한 델리게이트 extension DetailViewController: UITextFieldDelegate {     //UITextField에 텍스트를 입력하거나 삭제할 때마다 호출      func textFieldDidChangeSelection(_ textField: UITextField) {      } } // MARK: - 디테일 처리를 위한 델리게이트 extension DetailViewController: UITextViewDelegate {     // UITextView에 텍스트를 입력하거나 삭제할 때마다 호출     func textViewDidChange(_ textView: UITextView) {       } }   3. 델리게이트 설정     델리게이트를 설정합니다.       override func viewDidLoad() {         super.viewDidLoad()         //ViewController에서 받은 데이터 할당         titleTextField.text = receiveTitle              detailTextView.text = receiveDetail                  //델리게이트 설정          titleTextField.delegate = self         detailTextView.delegate = self     }   4. 델리게이트 프로토콜 정의     프로토콜을 정의하고 선언합니다.   import UIKit //TextField 델리게이트  protocol DetailViewControllerTitleDelegate: AnyObject {     func textFieldDidChangeSelection(_ controller: DetailViewController, textField: String) } //TextView 델리게이트  protocol DetailViewControllerDetailDelegate: AnyObject {     func textViewDidChange(_ controller: DetailViewController, textView: String) } class DetailViewController: UIViewController {     //코드생략       //델리게이트 선언      var titleDelegate: DetailViewControllerTitleDelegate?            var detailDelegate: DetailViewControllerDetailDelegate?    5. 메서드 구현     델리게이트 채택 후 생성한 메서드를 구현합니다.   // MARK: - 타이틀 처리를 위한 델리게이트 extension DetailViewController: UITextFieldDelegate {     func textFieldDidChangeSelection(_ textField: UITextField) {         //textField 확인 후 nil 체크          if textField == titleTextField {             if textField.text != nil {                 //textField의 변경을 알림                  titleDelegate?.textFieldDidChangeSelection(self, textField: textField.text!)             }         }     } } // MARK: - 디테일 처리를 위한 델리게이트 extension DetailViewController: UITextViewDelegate {     func textViewDidChange(_ textView: UITextView) {         //textView 확인 후 nil 체크          if textView == detailTextView {             if textView.text != nil {                 //textView 변경 알림                  detailDelegate?.textViewDidChange(self, textView: textView.text)             }         }     } }   6. ViewController에서 생성한 델리게이트 채택     필수 메서드를 구현하고 ViewController의 배열에서 title, detail 데이터를 수정하면 되는데 indexPath를 알 수 없습니다.   // MARK: - 디테일 뷰에서 타이틀 입력 extension ViewController: DetailViewControllerTitleDelegate {     func textFieldDidChangeSelection(_ controller: DetailViewController, textField: String) {         //ViewController에 있는 배열의 데이터 수정      } } // MARK: - 디테일 뷰에서 디테일 입력 extension ViewController: DetailViewControllerDetailDelegate {     func textViewDidChange(_ controller: DetailViewController, textView: String) {         //ViewController에 있는 배열의 데이터 수정     } }   7. DetailViewController에서 indexPath 받을 변수 생성하기     receiveIndexPath 옵셔널 변수와 indexPath 변수를 선언합니다.   ViewDidLoad에서 indexPath 변수의 값을 receiveIndexPath로 할당합니다.   class DetailViewController: UIViewController {     @IBOutlet weak var titleTextField: UITextField!     @IBOutlet weak var detailTextView: UITextView!          //ViewController에서 전달 받은 데이터 저장     var receiveTitle: String?     var receiveDetail: String?     var receiveIndexPath: Int?  //IndexPath를 받기위한 변수           var indexPath: Int = 0          var titleDelegate: DetailViewControllerTitleDelegate?     var detailDelegate: DetailViewControllerDetailDelegate?          override func viewDidLoad() {         super.viewDidLoad()         titleTextField.text = receiveTitle         detailTextView.text = receiveDetail         indexPath = receiveIndexPath!   //indexPath 저장    8. ViewController에서 prepare 메서드 수정     IndexPath를 전달하는 코드와 델리게이트를 설정합니다.       override func prepare(for segue: UIStoryboardSegue, sender: Any?) {         if segue.identifier == \"ToDoDetailSegue\" {             let cell = sender as! UITableViewCell             let indexPath = self.myTodoListTableView.indexPath(for: cell)             let detailView = segue.destination as! DetailViewController             detailView.receiveTitle = myToDoListArray[indexPath!.row].toDoTitle             detailView.receiveDetail = myToDoListArray[indexPath!.row].toDoDetail             detailView.receiveIndexPath = indexPath!.row    //IndexPath 전달              detailView.titleDelegate = self     //타이틀처리를 위한 TextField 델리게이트             detailView.detailDelegate = self    //디테일처리를 위한 TextView 델리게이트         }     }   9. ViewController에서 채택한 메서드 수정     indexPath를 받아 올 수 있어 배열을 수정합니다.   수정된 데이터를 확인할 수 있도록 reload 합니다.   // MARK: - 디테일 뷰에서 타이틀 입력 extension ViewController: DetailViewControllerTitleDelegate {     func textFieldDidChangeSelection(_ controller: DetailViewController, textField: String) {         if let indexPath = controller.receiveIndexPath {             myToDoListArray[indexPath].toDoTitle = textField    //타이틀 자동저장             self.myTodoListTableView.reloadData()   //테이블 뷰 리로드         }     } } // MARK: - 디테일 뷰에서 디테일 입력 extension ViewController: DetailViewControllerDetailDelegate {     func textViewDidChange(_ controller: DetailViewController, textView: String) {         if let indexPath = controller.receiveIndexPath {             myToDoListArray[indexPath].toDoDetail = textView    //디테일 자동저장             self.myTodoListTableView.reloadData()   //테이블 뷰 리로드         }     } }   10. 실행     처음 동영상처럼 ViewController의 TableView에서 Row를 선택하면 DetailViewController 화면으로 이동하고 DetailViewController에서 ViewController Cell데이터를 확인할 수 있습니다.   마무리     데이터를 주고 받을 때 델리게이트를 사용해서 주고 받는 연습이 됩니다.  ","categories": ["UIKit"],
        "tags": ["swift","iOS","Tableview","Cell","Row"],
        "url": "/uikit/%EB%A1%9C%EC%9A%B0%EC%84%A0%ED%83%9D%ED%9B%84%ED%99%94%EB%A9%B4%EC%9D%B4%EB%8F%99/",
        "teaser": null
      },{
        "title": "[프로그래머스/Swift] 과일 장수",
        "excerpt":"문제 설명     과일 장수가 사과 상자를 포장하고 있습니다. 사과는 상태에 따라 1점부터 k점까지의 점수로 분류하며, k점이 최상품의 사과이고 1점이 최하품의 사과입니다. 사과 한 상자의 가격은 다음과 같이 결정됩니다.            한 상자에 사과를 m개씩 담아 포장합니다.       상자에 담긴 사과 중 가장 낮은 점수가 p (1 ≤ p ≤ k)점인 경우, 사과 한 상자의 가격은 p * m 입니다.           과일 장수가 가능한 많은 사과를 팔았을 때, 얻을 수 있는 최대 이익을 계산하고자 합니다.(사과는 상자 단위로만 판매하며, 남는 사과는 버립니다)   예를 들어, k = 3, m = 4, 사과 7개의 점수가 [1, 2, 3, 1, 2, 3, 1]이라면, 다음과 같이 [2, 3, 2, 3]으로 구성된 사과 상자 1개를 만들어 판매하여 최대 이익을 얻을 수 있습니다.            (최저 사과 점수) x (한 상자에 담긴 사과 개수) x (상자의 개수) = 2 x 4 x 1 = 8           사과의 최대 점수 k, 한 상자에 들어가는 사과의 수 m, 사과들의 점수 score가 주어졌을 때, 과일 장수가 얻을 수 있는 최대 이익을 return하는 solution 함수를 완성해주세요.   문제 풀기   제한사항     3 ≤ k ≤ 9   3 ≤ m ≤ 10   7 ≤ score의 길이 ≤ 1,000,000            1 ≤ score[i] ≤ k           이익이 발생하지 않는 경우에는 0을 return 해주세요.   입출력 예                  k       m       score       result                       3       4       [1, 2, 3, 1, 2, 3, 1]       8                 4       3       [4, 1, 2, 2, 4, 4, 4, 4, 1, 2, 4, 2]       33           입출력 예 설명  입출력 예 #1     문제의 예시와 같습니다.   입출력 예 #2     다음과 같이 사과 상자를 포장하여 모두 팔면 최대 이익을 낼 수 있습니다.                  사과       상자       가격                       [1, 1, 2]       1 x 3 = 3                         [2, 2, 2]       2 x 3 = 6                         [4, 4, 4]       4 x 3 = 12                         [4, 4, 4]       4 x 3 = 12                      따라서 (1 x 3 x 1) + (2 x 3 x 1) + (4 x 3 x 2) = 33을 return합니다.   나의 풀이  import Foundation  func solution(_ k:Int, _ m:Int, _ score:[Int]) -&gt; Int {     guard (k &gt;= 3 &amp;&amp; k &lt;= 9) &amp;&amp; (m &gt;= 3 &amp;&amp; m &lt;= 10) &amp;&amp; (score.count &gt;= 7 &amp;&amp; score.count &lt;= 1000000) else { return 0 }          var scoreArr = score.sorted { $0 &gt; $1 }     var sum: Int = 0      //    while scoreArr.count &gt;= m { //        sum += scoreArr.prefix(m).last! * m //         //        let range = 0..&lt;m //        scoreArr.removeSubrange(range) //    }      for (index, value) in scoreArr.enumerated() {         if (index + 1) % m == 0 {             //print(\"index: \\(index), \\(value * m)\")             sum += value * m         }     }          return sum }   다른 사람 풀이  import Foundation  func solution(_ k:Int, _ m:Int, _ score:[Int]) -&gt; Int {     let s = score.sorted(by: &gt;)     return stride(from: m-1, to: score.count, by: m)         .reduce(0) { $0 + s[$1] * m } }   나의 풀이방법     처음에는 정렬 후 m개의 배열을 뽑아서 가장 낮은 값을 구하고 계산을 했다.   while true 문을 써서 그런가 시간 초과로 통과하지 못했다. (아래 11 ~ 15번에서 시간초과 발생)   for문을 사용하고 정렬했으니 m개씩 잘라서 마지막 값이 가장 작은 값이기 때문에 그 값으로 계산하고 해결했다.    테스트 9 &gt; 통과 (143.66ms, 19. 8MB)    테스트 10 &gt; 통과 (200.39ms, 18. 9MB)   테스트 11 &gt; 통과 (2919.63ms, 60.7MB)  테스트 12 &gt; 통과 (2764.20ms, 60.8MB)  테스트 13 &gt; 통과 (2656.91ms, 60. 6MB)  테스트 14 &gt; 통과 (2809.80ms, 60.6MB)   테스트 15 &gt; 통과 (3070.25ms, 60.9MB)  테스트 16 &gt; 통과 (0.12ms, 16.3MB)       다른사람 풀이     stride를 사용하여 푸는 방법도 있다는걸 알았다.  ","categories": ["Algorithm"],
        "tags": ["Algorithm","coding test","과일 장수"],
        "url": "/algorithm/%EA%B3%BC%EC%9D%BC%EC%9E%A5%EC%88%98/",
        "teaser": null
      },{
        "title": "[내배캠] iOS 앱 개발 입문 - ToDoList 만들기 프로젝트",
        "excerpt":"ToDoList 만들기     앱 개발 입문 과제로 ToDoList 만들기를 구현하였습니다.   실행 화면           구현 기능     ToDoList 출력   Alert 버튼으로 할 일 입력   네비게이션 바버튼을 통한 수정, 삭제, 순서 변경   TableView Row선택 시 화면 이동 및 상세 내용보기, 수정내용 자동 저장   총 할일 수, 총 완료 수 확인   프로젝트간 공부한 내용     델리게이트(Delegate) 패턴   얼러트 컨트롤러(UIAlertController)   코드로 화면 이동   Label 밑줄, 취소선 적용   UITableView - 데이터 목록 표시   NavigationBar에 Edit 버튼 추가하기   Tableview에서 Swipe로 Row 삭제하기   Tableview Cell에서 Delegate 사용   TableView 목록 순서 바꾸기   Cell의 오른쪽 Swipe 액션으로 수정/삭제 버튼 구현   TableView Row 선택 후 화면 이동하기   회고     스토리보드를 통해 UI는 어찌어찌 구현하였으나 그 이후 데이터를 TableView에 보여주기, View Controller 간 발생한 이벤트 처리 등 기능은 간단하지만, 그 기능을 위해 알아야하는 델리게이트 패턴, 얼러트컨트롤러, 프로토콜 채택 등 많은 것을 공부할 수 있었다.   첫 주는 강의 및 개인 과제를 위한 핵심 키워드 공부, 둘째 주는 실제 프로젝트 생성 및 기능 추가하기. 간단하지만 스스로 만든 첫 프로젝트를 마무리하면서 완성했다는 성취감을 얻을 수 있었다.  ","categories": ["sparta"],
        "tags": ["ToDoList"],
        "url": "/sparta/ToDoList/",
        "teaser": null
      },{
        "title": "[TIL] 내배캠 iOS앱 개발 공부 24일차",
        "excerpt":"데일리 스크럼     알고리즘     5문제가 시간 초과로 통화하지 못해서 다른 방법을 고민하다가 for문으로 해결했다.   풀이 보기            과일장수           개인 과제 공부     개인 과제 제출날 오후는 살짝 널널한 ? 느낌. 오전에 팀원분 과제 잠시 도와드리고 오후에는 개인과제 해설 영상을 봤다. 그리고 프로젝트 회고 작성   ToDoList 만들기 프로젝트   챌린지반     구현해야하는 내용을 PDF로 주셔서 내용만 확인하고 아직 시작도 못했다.   다음주에 팀과제, 개인과제 따로 있어 주말에 시간날때 조금이라도 시작해야겠다.   주말 목표     챌린지반 과제 시작하기  ","categories": ["TIL"],
        "tags": ["TIL"],
        "url": "/TIL/til24/",
        "teaser": null
      },{
        "title": "[프로그래머스/Swift] 모의고사",
        "excerpt":"문제 설명     수포자는 수학을 포기한 사람의 준말입니다. 수포자 삼인방은 모의고사에 수학 문제를 전부 찍으려 합니다. 수포자는 1번 문제부터 마지막 문제까지 다음과 같이 찍습니다.            1번 수포자가 찍는 방식: 1, 2, 3, 4, 5, 1, 2, 3, 4, 5, …       2번 수포자가 찍는 방식: 2, 1, 2, 3, 2, 4, 2, 5, 2, 1, 2, 3, 2, 4, 2, 5, …       3번 수포자가 찍는 방식: 3, 3, 1, 1, 2, 2, 4, 4, 5, 5, 3, 3, 1, 1, 2, 2, 4, 4, 5, 5, …                1번 문제부터 마지막 문제까지의 정답이 순서대로 들은 배열 answers가 주어졌을 때, 가장 많은 문제를 맞힌 사람이 누구인지 배열에 담아 return 하도록 solution 함수를 작성해주세요.       문제 풀기   제한사항     시험은 최대 10,000 문제로 구성되어있습니다.   문제의 정답은 1, 2, 3, 4, 5중 하나입니다.   가장 높은 점수를 받은 사람이 여럿일 경우, return하는 값을 오름차순 정렬해주세요.   입출력 예                  answers       return                       [1,2,3,4,5]       [1]                 [1,3,2,4,2]       [1,2,3]           입출력 예 설명  입출력 예 #1     수포자 1은 모든 문제를 맞혔습니다.   수포자 2는 모든 문제를 틀렸습니다.   수포자 3은 모든 문제를 틀렸습니다. 따라서 가장 문제를 많이 맞힌 사람은 수포자 1입니다.   입출력 예 #2     모든 사람이 2문제씩을 맞췄습니다.   나의 풀이  import Foundation  func solution(_ answers:[Int]) -&gt; [Int] {     let one: [Int] = [1, 2, 3, 4, 5]     let two: [Int] = [2, 1, 2, 3, 2, 4, 2, 5]     let three: [Int] = [3, 3, 1, 1, 2, 2, 4, 4, 5, 5]          var oneIndex: Int = 0     var twoIndex: Int = 0     var threeIndex: Int = 0          var oneCnt: Int = 0     var twoCnt: Int = 0     var threeCnt: Int = 0          for i in answers {         if i == one[oneIndex] {             oneCnt += 1         }         if i == two[twoIndex] {             twoCnt += 1         }         if i == three[threeIndex] {             threeCnt += 1         }                  if one.count - 1 == oneIndex {             oneIndex = 0         } else {             oneIndex += 1         }         if two.count - 1 == twoIndex {             twoIndex = 0         } else {             twoIndex += 1         }         if three.count - 1 == threeIndex {             threeIndex = 0         } else {             threeIndex += 1         }     }     //print(\"1번수포자: \\(oneCnt), 2번수포자: \\(twoCnt), 3번수포자: \\(threeCnt)\")     var tempArr: [Int] = []     tempArr.append(oneCnt)     tempArr.append(twoCnt)     tempArr.append(threeCnt)          //print(\"max: \\(tempArr.max())\")          var resultArr: [Int] = []          if let max = tempArr.max() {         if max == oneCnt {             resultArr.append(1)         }         if max == twoCnt {             resultArr.append(2)         }         if max == threeCnt {             resultArr.append(3)         }     }     return resultArr }   다른 사람 풀이  import Foundation  func solution(_ answers:[Int]) -&gt; [Int] {     let answer = (         a: [1, 2, 3, 4, 5], // index % 5         b: [2, 1, 2, 3, 2, 4, 2, 5], // index % 8         c: [3, 3, 1, 1, 2, 2, 4, 4, 5, 5] // index % 10     )     var point = [1:0, 2:0, 3:0]      for (i, v) in answers.enumerated() {         if v == answer.a[i % 5] { point[1] = point[1]! + 1 }         if v == answer.b[i % 8] { point[2] = point[2]! + 1 }         if v == answer.c[i % 10] { point[3] = point[3]! + 1 }     }      return point.sorted{ $0.key &lt; $1.key }.filter{ $0.value == point.values.max() }.map{ $0.key } }   나의 풀이방법     패턴이 반복되니까 answer에서 패턴을 하나씩 비교하면서 정답을 count하고 정답 수를 배열에 담은 뒤 가장 큰 값을 구했다.   가장 큰 값과 정답 수가 맞는 사람을 차례로 배열에 추가했다.       다른사람 풀이     어떻게하면 저렇게 생각할 수 있을까? 좋아요가 50개 이상…  ","categories": ["Algorithm"],
        "tags": ["Algorithm","coding test","모의고사"],
        "url": "/algorithm/%EB%AA%A8%EC%9D%98%EA%B3%A0%EC%82%AC/",
        "teaser": null
      },{
        "title": "[TIL] 내배캠 iOS앱 개발 공부 25일차",
        "excerpt":"데일리 스크럼     알고리즘     문제는 생각보다 간단한 것 같은데 3개의 값을 비교하고 집계하고 순위를 정하는게 생각보다 고민스러웠다. 조금 더 쉬운 방법, swift가 제공하는 기본 함수를 사용할 수 없을까 생각했는데 찾지 못하고 처음 생각한대로 풀었다.   풀이 보기            모의고사           팀 프로젝트     오늘은 팀 프로젝트 발제 후 팀프로젝트를 진행했다.   키오스크를 만들어 보는 과제인데 주제를 정하고 구현해야하는 기능과 목표를 확인했다.   필요한 키워드를 골라서 각자 해보고 싶었던 주제를 골라 역할 분담을 했다.   나는 프로젝트에 필요한 이미지파일을 모으고 기본 프로젝트를 Git에 올렸다.   깃허브 풀리퀘스트가 안돼서 엄청 시간 뺐겼는데 내일 차근차근 다시 해본다. !   챌린지반     주말에 생각보다 수월하게 과제를 했다.   테이블뷰 페이징처리만 못하고 기본적인 내용을 오로지 코드로만! 코드로만 작성하고 해냈다.   깃허브 프로필 부분만 코드로 구현하는 내용이었지만 일부분만 스토리보드로 구현하는게 오토레이아웃 잡기가 힘들 것 같아 코드로만 진행했는데 나쁘지 않았다.   코코아팟 설치, Alamofire, SDWebImage 라이브러리를 사용했다.   현재 진행 상황     내일 목표     깃허브 공부 및 챌린지반 과제 페이징 처리 구현하기   챌린지반 과제 블로그 포스팅하기  ","categories": ["TIL"],
        "tags": ["TIL"],
        "url": "/TIL/til25/",
        "teaser": null
      },{
        "title": "[프로그래머스/Swift] 소수 만들기",
        "excerpt":"문제 설명          주어진 숫자 중 3개의 수를 더했을 때 소수가 되는 경우의 개수를 구하려고 합니다. 숫자들이 들어있는 배열 nums가 매개변수로 주어질 때, nums에 있는 숫자들 중 서로 다른 3개를 골라 더했을 때 소수가 되는 경우의 개수를 return 하도록 solution 함수를 완성해주세요.            문제 풀기       제한사항     nums에 들어있는 숫자의 개수는 3개 이상 50개 이하입니다.   nums의 각 원소는 1 이상 1,000 이하의 자연수이며, 중복된 숫자가 들어있지 않습니다.   입출력 예                  nums       result                       [1,2,3,4]       1                 [1,2,7,6,4]       4           입출력 예 설명  입출력 예 #1     [1,2,4]를 이용해서 7을 만들 수 있습니다.   입출력 예 #2     [1,2,4]를 이용해서 7을 만들 수 있습니다.   [1,4,6]을 이용해서 11을 만들 수 있습니다.   [2,4,7]을 이용해서 13을 만들 수 있습니다.   [4,6,7]을 이용해서 17을 만들 수 있습니다.   나의 풀이  import Foundation  func solution(_ nums:[Int]) -&gt; Int {     var answer = 0     var sum: Int = 0          for i in 0..&lt;nums.count {         for j in i + 1..&lt;nums.count {             for k in j + 1..&lt;nums.count {                 sum = nums[i] + nums[j] + nums[k]                    if sum % 2 != 0 {                     for n in 2...sum {                         if sum % n == 0 {                             if (sum != n) {                                 break                             } else {                                 //print(\"sum: \\(sum), n: \\(n), 소수\")                                 answer += 1                             }                         }                     }                 }             }         }     }     return answer }   다른 사람 풀이  import Foundation  func solution(_ nums:[Int]) -&gt; Int {     var answer: Int = 0     var combi: [Int] = [Int](repeating: 0, count: 3)     combination(nums, &amp;combi, 0, nums.count, 0, 3, &amp;answer)      return answer }  func checkPrime(_ num: Int) -&gt; Bool {     var index: Int = 0     for i in 2...num {         if num % i == 0 {             index = i             break         }     }     if index == num {         return true     }     return false }  func combination(_ nums: [Int], _ combi: inout [Int], _ target: Int,                  _ n: Int, _ index: Int, _ k: Int, _ answer: inout Int) {     if k == 0 {         var checkNum: Int = 0         for i in combi {             checkNum += nums[i]         }         // 소수이면 1 더함         if checkPrime(checkNum) {             answer += 1         }     }     else if target == n {         return     }     else {         combi[index] = target         combination(nums, &amp;combi, target + 1, n, index + 1, k - 1, &amp;answer)         combination(nums, &amp;combi, target + 1, n, index, k, &amp;answer)     } }   나의 풀이방법     3자리수 조합을 구하여 더하고 홀수인 것만 소수 판별하여 자기 자신만 나누어 떨어지면 카운트       다른사람 풀이     이번 풀이는 다들 비슷비슷했다. 가장 많은 좋아요가 3개. 기능별로 함수를 만들어 사용했다.  ","categories": ["Algorithm"],
        "tags": ["Algorithm","coding test","소수 만들기"],
        "url": "/algorithm/%EC%86%8C%EC%88%98%EB%A7%8C%EB%93%A4%EA%B8%B0/",
        "teaser": null
      },{
        "title": "[TIL] 내배캠 iOS앱 개발 공부 26일차 - 2024.04.02",
        "excerpt":"알고리즘     3자리 수 덧셈 조합을 먼저 구하고 합이 홀수인 수만 소수 판별 체크   풀이 보기            소수만들기           팀 프로젝트     Git에 올라온 자료를 하나로 합치는 일이 보통 일이 아니다.   수정하지도 않았는데 git status에서 DS_Store, UserInterfaceState 파일때문에 문제가 발생하여 .gitignore에 브랜치 마다 추가하고 팀원들 브랜치를 각각 받아 수동으로 합쳤다. 각자 소스코드 작성하는 스타일이 달라 코드 컨벤션이 필요하구나 깨달았다.   젭에서 새벽 2시까지 토론하고 계신 옆조를 찾아갔는데 같은 문제로 새로 시작하고 계셨다..   오늘은 하나도 진행 못하고 날린 느낌   챌린지반     코코아팟 설치하기   알라모파이어(alamofire) 설치하기   SDWebImage 설치하기   주말에 했던 내용 하나씩 포스팅   내일 목표     팀 과제 진행  ","categories": ["TIL"],
        "tags": ["TIL"],
        "url": "/TIL/til26/",
        "teaser": null
      },{
        "title": "[UIKit] SDWebImage 설치하기",
        "excerpt":"SDWebImage란 ?     SDWebImage는 Objective-C로 작성된 이미지 로딩 및 캐싱 라이브러리입니다. iOS 및 macOS에서 많이 사용되며, Swift에서도 사용할 수 있습니다.   SDWebImage는 비동기 이미지 다운로드, 캐싱 및 관리를 처리하고, 메모리 사용량을 최적화하여 원활한 사용자 경험을 제공합니다.   또한 SDWebImage는 GIF 지원, 프로그레시브 다운로드, 이미지 처리 등의 기능을 제공합니다.   SDWebImage는 iOS 개발 커뮤니티에서 오랫동안 사용되어 온 라이브러리 중 하나입니다.       사용방법  1. 프로젝트 폴더로 이동해서 터미널 오픈     프로젝트 폴더로 이동해서 폴더를 우클릭하고 터미널을 오픈합니다.       2. 명령어를 입력합니다.  imhs@imhsui-MacBookPro MyGithub % pod init       3. 프로젝트 폴더안에 Podfile 확인     프로젝트 폴더 안에 Podfile이 생깁니다.          4. Podfile 더블클릭         5. Podfile 내 SDWebImage 추가     pod ‘SDWebImage’          6. SDWebImage 설치 - pod install         7.project 재시작 - .xcworkspace 파일을 열어야합니다.  ","categories": ["UIKit"],
        "tags": ["swift","iOS","SDWebImage"],
        "url": "/UIKit/SDWebImage/",
        "teaser": null
      },{
        "title": "[UIKit] 알라모파이어(alamofire) 설치하기",
        "excerpt":"알라모파이어(alamofire)란 ?     Alamofire는 iOS, macOS를 위한 Swift 기반 HTTP 네트워킹 라이브러리입니다.   애플에서 자체적으로 네트워크 통신을 위해 제공하는 URLSession API가 있는데, 이를 보완한 것이 Alamofire 입니다.   Alamofire에서는 다양한 기능을 제공하고 있는데, 자세한 내용은 Alamofire github 홈페이지에서 확인가능합니다.       사용방법  1. 프로젝트 폴더로 이동해서 터미널 오픈     프로젝트 폴더로 이동해서 폴더를 우클릭하고 터미널을 오픈합니다.       2. 명령어를 입력합니다.  imhs@imhsui-MacBookPro MyGithub % pod init       3. 프로젝트 폴더안에 Podfile 확인     프로젝트 폴더 안에 Podfile이 생깁니다.          4. Podfile 더블클릭         5. Podfile 내 Alamofire 추가         6. Alamofire 설치         7.project 재시작 - .xcworkspace 파일을 열어야합니다.       8. import Alamofire     import Alamofire 코드를 추가하고 사용합니다.       설치 후 에러 발생 시 (sandbox 에러)         Update your Xcode project build option ENABLE_USER_SCRIPT_SANDBOXING to ‘No’.            Yes로 되어있어 No로 변경합니다.                 에러 참고 사이트            https://stackoverflow.com/questions/76590131/error-while-build-ios-app-in-xcode-sandbox-rsync-samba-13105-deny1-file-w          ","categories": ["UIKit"],
        "tags": ["swift","iOS","alamofire"],
        "url": "/UIKit/alamofire/",
        "teaser": null
      },{
        "title": "[UIKit] 코코아팟(cocoapods) 설치하기",
        "excerpt":"코코아팟(cocoapods)이란 ?     Objective-C 및 Swift Cocoa 프로젝트의 종속성 관리자   즉, CocoaPods은 Objective-C 또는 Swift에서 라이브러리를 사용할 수 있게 도와주는 모듈이다.       설치하기  1. 홈브루 버전 확인 및 업데이트     터미널에서 홈브루 버전확인 및 업데이트를 합니다.   imhs@imhsui-MacBookPro ~ % brew --version  Homebrew 4.2.11 imhs@imhsui-MacBookPro ~ % brew update imhs@imhsui-MacBookPro ~ % brew --version Homebrew 4.2.15       2. 코코아팟 설치     코코아팟 홈페이지 바로가기   코코아팟 홈페이지에서 설치 명령어를 확인할 수 있습니다.   sudo gem install cocoapods   imhs@imhsui-MacBookPro ~ % sudo gem install cocoapods       버전확인  imhs@imhsui-MacBookPro ~ % pod --version 1.15.2  ","categories": ["UIKit"],
        "tags": ["swift","iOS","cocoapods"],
        "url": "/UIKit/cocoapods/",
        "teaser": null
      },{
        "title": "[프로그래머스/Swift] 덧칠하기",
        "excerpt":"문제 설명     어느 학교에 페인트가 칠해진 길이가 n미터인 벽이 있습니다. 벽에 동아리 · 학회 홍보나 회사 채용 공고 포스터 등을 게시하기 위해 테이프로 붙였다가 철거할 때 떼는 일이 많고 그 과정에서 페인트가 벗겨지곤 합니다. 페인트가 벗겨진 벽이 보기 흉해져 학교는 벽에 페인트를 덧칠하기로 했습니다.   넓은 벽 전체에 페인트를 새로 칠하는 대신, 구역을 나누어 일부만 페인트를 새로 칠 함으로써 예산을 아끼려 합니다. 이를 위해 벽을 1미터 길이의 구역 n개로 나누고, 각 구역에 왼쪽부터 순서대로 1번부터 n번까지 번호를 붙였습니다. 그리고 페인트를 다시 칠해야 할 구역들을 정했습니다.   벽에 페인트를 칠하는 롤러의 길이는 m미터이고, 롤러로 벽에 페인트를 한 번 칠하는 규칙은 다음과 같습니다.            롤러가 벽에서 벗어나면 안 됩니다.       구역의 일부분만 포함되도록 칠하면 안 됩니다.           즉, 롤러의 좌우측 끝을 구역의 경계선 혹은 벽의 좌우측 끝부분에 맞춘 후 롤러를 위아래로 움직이면서 벽을 칠합니다. 현재 페인트를 칠하는 구역들을 완전히 칠한 후 벽에서 롤러를 떼며, 이를 벽을 한 번 칠했다고 정의합니다.   한 구역에 페인트를 여러 번 칠해도 되고 다시 칠해야 할 구역이 아닌 곳에 페인트를 칠해도 되지만 다시 칠하기로 정한 구역은 적어도 한 번 페인트칠을 해야 합니다. 예산을 아끼기 위해 다시 칠할 구역을 정했듯 마찬가지로 롤러로 페인트칠을 하는 횟수를 최소화하려고 합니다.   정수 n, m과 다시 페인트를 칠하기로 정한 구역들의 번호가 담긴 정수 배열 section이 매개변수로 주어질 때 롤러로 페인트칠해야 하는 최소 횟수를 return 하는 solution 함수를 작성해 주세요.   문제 풀기   제한사항     1 ≤ m ≤ n ≤ 100,000   1 ≤ section의 길이 ≤ n            1 ≤ section의 원소 ≤ n       section의 원소는 페인트를 다시 칠해야 하는 구역의 번호입니다.       section에서 같은 원소가 두 번 이상 나타나지 않습니다.       section의 원소는 오름차순으로 정렬되어 있습니다.           입출력 예                  n       m       section       result                       8       4       [2, 3, 6]       2                 5       4       [1, 3]       1                 4       1       [1, 2, 3, 4]       4           입출력 예 설명  입출력 예 #1     예제 1번은 2, 3, 6번 영역에 페인트를 다시 칠해야 합니다. 롤러의 길이가 4미터이므로 한 번의 페인트칠에 연속된 4개의 구역을 칠할 수 있습니다. 처음에 3, 4, 5, 6번 영역에 페인트칠을 하면 칠해야 할 곳으로 2번 구역만 남고 1, 2, 3, 4번 구역에 페인트칠을 하면 2번 만에 다시 칠해야 할 곳에 모두 페인트칠을 할 수 있습니다.   2번보다 적은 횟수로 2, 3, 6번 영역에 페인트를 덧칠하는 방법은 없습니다. 따라서 최소 횟수인 2를 return 합니다.   입출력 예 #2     예제 2번은 1, 3번 영역에 페인트를 다시 칠해야 합니다. 롤러의 길이가 4미터이므로 한 번의 페인트칠에 연속된 4개의 구역을 칠할 수 있고 1, 2, 3, 4번 영역에 페인트칠을 하면 한 번에 1, 3번 영역을 모두 칠할 수 있습니다.   따라서 최소 횟수인 1을 return 합니다.   입출력 예 #3     예제 3번은 모든 구역에 페인트칠을 해야 합니다. 롤러의 길이가 1미터이므로 한 번에 한 구역밖에 칠할 수 없습니다. 구역이 4개이므로 각 구역을 한 번씩만 칠하는 4번이 최소 횟수가 됩니다.   따라서 4를 return 합니다.   나의 풀이  import Foundation  func solution(_ n:Int, _ m:Int, _ section:[Int]) -&gt; Int {     var section = section     var cnt: Int = 0     var firstNum: Int = 0          if m &gt;= 1 &amp;&amp; m &lt;= 100000 &amp;&amp; n &gt;= 1 &amp;&amp; n &lt;= 100000 &amp;&amp; section.count &gt; 0 &amp;&amp; section.count &lt;= n {         for i in 0...n/m {             //시작 섹션 확인             if section.count != 0 {                 firstNum = section[0]                                  //롤러에 포함된 섹션 확인해서 지우기                 for j in firstNum..&lt;firstNum + m {                     if section.count != 0 &amp;&amp; j == section[0] {                         section.remove(at: 0)                     }                 }                 cnt += 1             }         }     }     return cnt }   다른 사람 풀이  import Foundation  func solution(_ n:Int, _ m:Int, _ section:[Int]) -&gt; Int {     var now = section[0]     var counter = 0      for s in section {         if s &gt;= now {             counter += 1             now = s + m         }     }      return counter }   나의 풀이방법     시작 섹션에서 롤러 길이만큼 더하기   처음 구한 길이보다 작은 값들은 삭제   다시 시작 세션구하고 반복       다른사람 풀이     시작 위치를 지정하고 최대로 선택할 수 있는 구간의 개수를 계산.. 간단하게 풀 수 있는 문제였구나 …  ","categories": ["Algorithm"],
        "tags": ["Algorithm","coding test","덧칠하기"],
        "url": "/algorithm/%EB%8D%A7%EC%B9%A0%ED%95%98%EA%B8%B0/",
        "teaser": null
      },{
        "title": "[TIL] 내배캠 iOS앱 개발 공부 27일차 - 2024.04.03",
        "excerpt":"알고리즘     한번 롤러질을하면 X M가 칠해지는 롤러로 특정 섹션을 칠하는데 필요한 롤러질 횟수구하기   풀이 보기            덧칠하기           팀 프로젝트     처음에 충돌 났던 소스코드를 하나로 머지하고 나서부터는 이제 협업이 되는 것 같다.   수정 전 새로 받아오고 수정하고 dev 브랜치에 머지하면 공유하고 새로 받아오고를 반복하며 조금 익숙해졌다.   처음에는 스토리보드가 간편하고 좋다고 생각했으나 팀원들과 협업해보니 확실히 코드로 작업해야 더 간편한 것 같다.   챌린지반     오늘 챌린지반 과제는 하지 않았다. - 페이징처리만 남음   내일 목표     팀 과제 진행   코드로 탭바 추가하기, 상세페이지 추가 등 ! ! !  ","categories": ["TIL"],
        "tags": ["TIL"],
        "url": "/TIL/til27/",
        "teaser": null
      },{
        "title": "[minimal-mistakes]블로그 내 검색기능 추가하기 ",
        "excerpt":"블로그에 검색 기능 추가하기입니다.   1. _config.yml 파일 수정하기     _config.yml 파일에서 설정을 변경하면 바로 추가할 수 있습니다.   search 관련 설정을 true로 변경합니다.   search                   : true # true, false (default) search_full_content      : true # true, false (default) search_provider          : lunr # lunr (default), algolia, google lunr:   search_within_pages    : true # true, false (default)       2. 확인  검색기능이 추가되고 검색할 수 있습니다.    ","categories": ["GitHubBlog"],
        "tags": ["GitHub","blog","GitHub blog","검색"],
        "url": "/GitHubBlog/search/",
        "teaser": null
      },{
        "title": "[minimal-mistakes]로컬에서 블로그 실행시키기(bundle exec jekyll serve)",
        "excerpt":"1. 터미널에서 명령어 입력     bundle exec jekyll serve   imhs@imhsui-MacBookPro limlogging.github.io % bundle exec jekyll serve         2. 실행 확인     인터넷 주소창에 http://127.0.0.1:4000/ 접속     ","categories": ["GitHubBlog"],
        "tags": ["GitHub","blog","GitHub blog","bundle exec jekyll serve"],
        "url": "/GitHubBlog/bundleexecjekyllserve/",
        "teaser": null
      },{
        "title": "[minimal-mistakes]블로그 광고(google AdSense) 추가하기 ",
        "excerpt":"1. Google AdSense 시작하기     2. 애드센스에 사이트 연결하기     3. 코드스니펫 확인하기     4. customs.html 수정     _includes / head 경로에 위치한 customs.html 상단에 코드를 추가합니다.   &lt;!-- start custom head snippets --&gt; &lt;!-- 구글 애드센스 추가 --&gt; &lt;script async src=\"https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-8663638822726862\" crossorigin=\"anonymous\"&gt;&lt;/script&gt;   코드 반영 전     코드 반영 후     5. 애드센스 승인 메일 확인     6. ads.txt 파일 추가     애드센스 홈에서 아래와 같은 경고창이 뜨는데 ads.txt파일을 추가하면 됩니다.     지금 해결하기 선택     사이트 URL 선택     코드를 복사합니다.     ads.txt 파일 생성 및 코드 작성     _config.yml파일과 같은 위치에 ads.txt파일을 생성하고 복사한 코드를 추가합니다.     7. 블로그 하단에 광고 추가하기     홈 - 광고 - 광고 단위 기준에서 디스플레이 광고를 선택합니다.     1. 수평형 디스플레이 광고를 생성     2. 코드 받기     3. 코드 추가하기     _layouts 폴더 내 single.html파일 가장 하단에 코드를 추가합니다.   &lt;!-- 하단 광고 추가 --&gt; &lt;div style=\"text-align: center;\"&gt;   &lt;script async src=\"https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-8663638822726862\"       crossorigin=\"anonymous\"&gt;&lt;/script&gt;   &lt;!-- 수평형 디스플레이 광고 --&gt;   &lt;ins class=\"adsbygoogle\"       style=\"display:block\"       data-ad-client=\"ca-pub-8663638822726862\"       data-ad-slot=\"5774789366\"       data-ad-format=\"auto\"       data-full-width-responsive=\"true\"&gt;&lt;/ins&gt;   &lt;script&gt;       (adsbygoogle = window.adsbygoogle || []).push({});   &lt;/script&gt; &lt;/div&gt;   8. 블로그 우측 toc에 광고 추가하기     7번과 동일한 방법으로 수직형 디스플레이 광고를 만들고 코드를 받습니다.   1. html 파일 생성 및 코드 작성     _includes 폴더에 GoogleAdSenseSidbar.html 파일을 추가하고 코드를 작성합니다.   &lt;script async src=\"https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-8663638822726862\"      crossorigin=\"anonymous\"&gt;&lt;/script&gt; &lt;!-- 수직형 디스플레이 광고 --&gt; &lt;ins class=\"adsbygoogle\"      style=\"display:block\"      data-ad-client=\"ca-pub-8663638822726862\"      data-ad-slot=\"8971782438\"      data-ad-format=\"auto\"      data-full-width-responsive=\"true\"&gt;&lt;/ins&gt; &lt;script&gt;      (adsbygoogle = window.adsbygoogle || []).push({}); &lt;/script&gt;   2. _config.yml 파일 수정     toc_ads, toc_sticky 부분을 추가합니다.   # Defaults defaults:   # _posts   - scope:       path: \"\"       type: posts     values:       layout: single       author_profile: true       read_time: true       comments: # true       share: true       related: true       toc_ads: true     #사이드 광고 추가        toc_sticky: true  #사이드 광고 추가  # 사이드바 탐색 기본값 추가        sidebar:         nav: \"categories\"   3. single.html 수정     코드 복붙하니 너무 길어져서 캡처로 대체합니다.    9. 하단 광고 확인     10. 우측 광고 확인    ","categories": ["GitHubBlog"],
        "tags": ["GitHub","blog","GitHub blog","AdSense"],
        "url": "/GitHubBlog/googleAdSense/",
        "teaser": null
      },{
        "title": "[minimal-mistakes]블로그 방문자 통계(google Analytics) 추가하기 ",
        "excerpt":"1. Google Analytics 등록하기     Google Analytics에 접속해서 측정시작합니다.     계정 이름 설정 (자유롭게 작명하면 됩니다.)    블로그 주소 및 시간대를 선택합니다.         2. 트랙킹 ID 확인하기     관리     데이터 스트림     블로그 선택     측정 ID 확인         3. custom.html 수정하기     _includes - head - custom.html에 코드를 추가합니다.   &lt;!-- 구글 애널리틱스 추가 Google tag (gtag.js) --&gt; &lt;script async src=\"https://www.googletagmanager.com/gtag/js?id=G-B9ZRRL1X26\"&gt;&lt;/script&gt; &lt;script&gt;   window.dataLayer = window.dataLayer || [];   function gtag(){dataLayer.push(arguments);}   gtag('js', new Date());    gtag('config', 'G-B9ZRRL1X26'); &lt;/script&gt;       4. _config.yml 수정하기  # Analytics analytics:   provider               : \"google-gtag\" # false (default), \"google\", \"google-universal\", \"google-gtag\", \"custom\"   google:     tracking_id          : \"G-B9ZRRL1X26\"     anonymize_ip         : # true, false (default)       5. 확인하기     홈에서 확인    ","categories": ["GitHubBlog"],
        "tags": ["GitHub","blog","GitHub blog","Analytics"],
        "url": "/GitHubBlog/googleAnalytics/",
        "teaser": null
      },{
        "title": "[minimal-mistakes]블로그에서 검색 노출(Search Console) 사용하기",
        "excerpt":"1. Google Search Console 접속     Google Search Console 접속하기      2. Google Search Console 시작      3. sitemap.xml 추가하기     _config.yml 파일과 같은 경로에 sitemap.xml 파일을 추가 후 코드를 작성합니다.   %안에 내용때문에 코드가 길어지고 달라져서 캡처로 대체합니다 ㅠ ㅠ      4. robots.txt 파일 생성     _config.yml 파일과 같은 경로에 robots.txt 파일을 추가 후 내용 작성합니다.   User-agent: * Allow: / Sitemap: http://localhost:4000/sitemap.xml   5. 새 사이트맵 추가     6. 도메인으로 계속하기     7. txt 레코드 복사     8. _config.yml 파일 수정     google_site_verification 레코드를 붙여넣습니다.   # SEO Related google_site_verification : \"B9n-ap1lRd2h2TkRZ7YJ0o4C6AnWUSXWrBq2xCjZ9ug\" bing_site_verification   : naver_site_verification  : yandex_site_verification : baidu_site_verification  :   9. 완료    ","categories": ["GitHubBlog"],
        "tags": ["GitHub","blog","GitHub blog","Search Console"],
        "url": "/GitHubBlog/googleSearchConsole/",
        "teaser": null
      },{
        "title": "[TIL] 내배캠 iOS앱 개발 공부 30일차 - 2024.04.08",
        "excerpt":"팀프로젝트     팀프로젝트가 바빠서 28, 29일차는 생략!   이번 팀 프로젝트의 개인적인 목표는 기존에 배웠던 내용을 학습하고 깃허브와 익숙해지기였다.   깃허브 머지 역할을 담당하면서 충돌, 브랜치 다시 만들기, 코드로 직접 옮겨쓰기 .. 많은 우여곡절이 있었다. 깃허브를 제대로 마스터하지는 못했지만 기본적인 사용방법을 알아낸 것 같아 만족스러웠다.   기존에 배웠던 내용 + 코드로 UI 작성하기 + 스크롤뷰에서 페이지컨트롤러를 사용하여 이미지 출력하기를 만들어볼 수 있었다.   야근?하는 다른 팀들과 함께… 🧑🏻‍💻     우리조에 난입한 친구들 !     우리팀 발표     발표 무작위 캡처     팀 프로젝트     팀프로젝트   팀 프로젝트 회고     팀프로젝트 회고   내일 목표     새로운 팀에 적응하기   챌린지반 과제  ","categories": ["TIL"],
        "tags": ["TIL"],
        "url": "/TIL/til30/",
        "teaser": null
      },{
        "title": "[프로그래머스/Swift] ⭐️기사단원의 무기⭐️",
        "excerpt":"문제 설명     숫자나라 기사단의 각 기사에게는 1번부터 number까지 번호가 지정되어 있습니다. 기사들은 무기점에서 무기를 구매하려고 합니다.   각 기사는 자신의 기사 번호의 약수 개수에 해당하는 공격력을 가진 무기를 구매하려 합니다. 단, 이웃나라와의 협약에 의해 공격력의 제한수치를 정하고, 제한수치보다 큰 공격력을 가진 무기를 구매해야 하는 기사는 협약기관에서 정한 공격력을 가지는 무기를 구매해야 합니다.   예를 들어, 15번으로 지정된 기사단원은 15의 약수가 1, 3, 5, 15로 4개 이므로, 공격력이 4인 무기를 구매합니다. 만약, 이웃나라와의 협약으로 정해진 공격력의 제한수치가 3이고 제한수치를 초과한 기사가 사용할 무기의 공격력이 2라면, 15번으로 지정된 기사단원은 무기점에서 공격력이 2인 무기를 구매합니다. 무기를 만들 때, 무기의 공격력 1당 1kg의 철이 필요합니다. 그래서 무기점에서 무기를 모두 만들기 위해 필요한 철의 무게를 미리 계산하려 합니다.   기사단원의 수를 나타내는 정수 number와 이웃나라와 협약으로 정해진 공격력의 제한수치를 나타내는 정수 limit와 제한수치를 초과한 기사가 사용할 무기의 공격력을 나타내는 정수 power가 주어졌을 때, 무기점의 주인이 무기를 모두 만들기 위해 필요한 철의 무게를 return 하는 solution 함수를 완성하시오.   문제 풀기   제한사항     1 ≤ number ≤ 100,000   2 ≤ limit ≤ 100   1 ≤ power ≤ limit   입출력 예                  number       limit       power       result                       5       3       2       10                 10       3       2       21           입출력 예 설명  입출력 예 #1     1부터 5까지의 약수의 개수는 순서대로 [1, 2, 2, 3, 2]개입니다. 모두 공격력 제한 수치인 3을 넘지 않기 때문에 필요한 철의 무게는 해당 수들의 합인 10이 됩니다. 따라서 10을 return 합니다.   입출력 예 #2     1부터 10까지의 약수의 개수는 순서대로 [1, 2, 2, 3, 2, 4, 2, 4, 3, 4]개입니다. 공격력의 제한수치가 3이기 때문에, 6, 8, 10번 기사는 공격력이 2인 무기를 구매합니다. 따라서 해당 수들의 합인 21을 return 합니다.   나의 풀이 1번 방법 - 66.7점  import Foundation  func solution(_ number:Int, _ limit:Int, _ power:Int) -&gt; Int {     guard (number &gt;= 1 &amp;&amp; number &lt;= 100000) &amp;&amp; (limit &gt;= 2 &amp;&amp; limit &lt;= 100) &amp;&amp; (power &gt;= 1 &amp;&amp; power &lt;= limit) else { return 0 }      var arr: [Int] = []     var cnt: Int = 0     for i in 1...number {         for j in 1...i {             if i % j == 0 {                 cnt += 1             }         }         arr.append(cnt &lt;= limit ? cnt : power)         cnt = 0     }     return arr.reduce(0, +) }   나의 풀이 2번 방법 - 55.6점  import Foundation  func solution(_ number:Int, _ limit:Int, _ power:Int) -&gt; Int {     guard (number &gt;= 1 &amp;&amp; number &lt;= 100000) &amp;&amp; (limit &gt;= 2 &amp;&amp; limit &lt;= 100) &amp;&amp; (power &gt;= 1 &amp;&amp; power &lt;= limit) else { return 0 }      return (1...number).map { i in         (1...i).filter { j in             i % j == 0         }.count     }.map({         $0 &gt; limit ? power : $0     }).reduce(0, +) }   나의 풀이 3번 방법 - 55.6점  import Foundation  func solution(_ number:Int, _ limit:Int, _ power:Int) -&gt; Int {     guard (number &gt;= 1 &amp;&amp; number &lt;= 100000) &amp;&amp; (limit &gt;= 2 &amp;&amp; limit &lt;= 100) &amp;&amp; (power &gt;= 1 &amp;&amp; power &lt;= limit) else { return 0 }      var arr: [Int] = []     for i in 1...number {         arr.append((1...i).filter { i % $0 == 0 }.count &lt;= limit ? (1...i).filter { i % $0 == 0 }.count : power)     }     return arr.reduce(0, +) }   나의 풀이 4번 방법 - 55.6점  import Foundation  func solution(_ number:Int, _ limit:Int, _ power:Int) -&gt; Int {     guard (number &gt;= 1 &amp;&amp; number &lt;= 100000) &amp;&amp; (limit &gt;= 2 &amp;&amp; limit &lt;= 100) &amp;&amp; (power &gt;= 1 &amp;&amp; power &lt;= limit) else { return 0 }      var arr: [Int] = []     var cnt: Int = 0     for i in 1...number {         cnt = (1...i).filter { j in             i % j == 0         }.count         arr.append(cnt &lt;= limit ? cnt : power)         cnt = 0     }     return arr.reduce(0, +) }   다른 사람 풀이  import Foundation  func solution(_ number:Int, _ limit:Int, _ power:Int) -&gt; Int {          var result = [Int]()          for number in 1...number{         //약수의 개수를 셈         var count = 0                  //16일경우 -&gt; 4까지만 구해도됨         //약수 1로 16을 유추할수있음         //2로 8을 유추할 수 있음         //4 * 4 = 16이므로 이땐 +1         //이외엔 약수 하나로 두 수를 구할 수 있으니 +2         for i in 1...Int(sqrt(Double(number))){             if number % i == 0{                 if( i * i) == number{                     count += 1                 }else{                     count += 2                 }             }         }         //limit을 넘는다면 power를, limit을 넘지 않는다면 그대로         count = count &gt; limit ? power : count         result.append(count)              }     return result.reduce(0){$0 + $1} }   나의 풀이방법     채점 시 11번 ~ 16번 그 근처에 시간초과로 계속 실패했다.   약수구하는 다른방법을 찾으면 시간을 줄일 수 있을 것 같은데 찾지 못했고 어려웠다 ㅠ   결국 구글 검색으로 해결 …..       다른사람 풀이     전체적인 방법은 비슷한데 결국 약수구하는 방법에서 차이가 많이 났다. 통과 못한적은 처음인데 다시 공부해봐야겠다 😭  ","categories": ["Algorithm"],
        "tags": ["Algorithm","coding test","기사단원의 무기"],
        "url": "/algorithm/%EA%B8%B0%EC%82%AC%EB%8B%A8%EC%9B%90%EC%9D%98%EB%AC%B4%EA%B8%B0/",
        "teaser": null
      },{
        "title": "[내배캠] iOS 앱 개발 입문 팀 프로젝트 만들기 - Kiosk 앱",
        "excerpt":"프로젝트     프로젝트 주제: 팀 소개 앱 만들기   프로젝트 기간: 4/1(월) ~ 4/7(일)   인원: 4명 (팀장: 임형섭 / 팀원: 김시종, 금세미, 송동익)   프로젝트 명: Fine Apple Store   프로젝트 소개: 키오스크하면 생각나는 음료가 아닌 본 과정이 iOS 앱 개발 과정인 만큼, 애플 제품을 소개 및 판매하는 앱을 구현하기로 결정.   개발환경            OS : macOS Sonoma 14.3.1       IDE : Xcode 15.3       Language : Swift       협업 Tool : Git (https://github.com/-limlogging/Kiosk3Jo)               팀원 구성 및 역할  임형섭     Github에서 팀원 코드 merge 최종 작업   제품 기초 이미지 파일 준비   스토리보드에서, TabBar, Navigation 기능 추가 (홈, 상품, 마이페이지)   스토리보드 버튼을 코드로 변경   마이페이지 구현 (코드를 통한 UI 구성, TableView, 오토레이아웃 사용)   제품 상세 페이지 구현 (코드를 통한 UI 구성, ScrollView, PageControl를 사용한 슬라이드 이미지 구현)   금세미     UIButton, UIAlertController 기능 구현            문의, 취소, 주문 버튼 클릭 시, UIAlertController를 통해 주문 및 취소 기능 구현, 전체 취소 및 주문 완료 시 UITableView 초기화           제품 이미지 영문명 변경   제품 이미지 확장자 변경(jpeg → png)   컬렉션 뷰와 이미지 연결하여 제품 정보(상품명, 가격) 불러오기   launch screen 디자인   김시종     데이터 모델링(Model → image, title, price)   CollectionView, SegmentedControl 기능 구현            제품군별로 SegmentedControl로 분류       Seg마다 각각의 선택된 제품군 화면출력           탭바 홈 화면 구현   탭바 고객센터 화면 구현   이미지 및 레이아웃 상세 디자인 수정   송동익     프로젝트 초기 UI틀 구성   UITableView 기능 구현   장바구니 기능 구현   장바구니 화면을 보여줄 Modal 기능 구현   물품의 갯수를 Notification Badge 형식으로 구현   Search Bar 기능 구현   새로 출시된 제품 표기 기능 구현   매장의 위치를 보여줄 지도 기능 구현   App Icon 구현   팀원 업무 보조       어려웠던 점 &amp; 해결 방법   임형섭     github를 통해 충돌된 코드를 머지하는 방식이 어려웠으나 프로젝트를 통해 머지방식이 조금 익숙해 졌습니다.   TabBar를 통해 View 이동 시 배열 데이터를 주고 받기 어려워 팀원들의 도움을 받아 해결할 수 있었습니다.   pageControl을 통해서 ScrollView내 imageview를 이동하기 어려웠지만 ScrollView width 지정과 오토레이아웃에 문제가 있는걸 확인하고 해결할 수 있었습니다.   금세미     git 사용법이 익숙하지 않아 팀에 피해를 끼치지 않고 프로젝트 파일을 pull, push, merge 하는 것이 좀 부담스러웠으나 여러번 반복하며 익혔다.   김시종     홈화면 구성할 때 컬렉션 뷰위에 헤더를 구현하고 싶었으나, 가로로 구성된 컬렉션 뷰의 헤더가 위로 구성되는게 아닌 왼쪽으로 오는 것에 대해 위로 올리는 과정이 어려웠던 것 같습니다. 일반적인 방법으로 가로 구성의 컬렉션 뷰 헤더를 위로 구성하는 것이 어렵다는 것을 깨닫고 Compositional Layout 을 사용하게 되었습니다. 아직 이해하기 어려운 개념이지만 헤더를 위에 구성하는 것 까진 성공하게 되었습니다. 추후 컴포지셔널 레이아웃 관련해서 더 공부해야할 것 같습니다.   송동익     데이터 전달방식이다. 내가 알고있던 방법으로 VC간 데이터를 전달했지만, 탭바를 사용하면서 이럴땐 어떻게 전달해야하지? 라는 생각을했고, 내가 아는 모든 지식을 사용해도 전달이 안되었는데, 튜터님께 여쭤보고 바로 해답을 찾았고, 그 문제를 해결하는데는 단 5분도 걸리지않았다. 항상 내 수준에 만족을 하고 있지는 않아 만족을 하기위해 노력을 하고있는데, 그 노력 이상으로 더 열심히 공부해야겠다라는 생각이 든다.       프로젝트 소감  임형섭     github를 통해서 협업을 경험해보고 공부했던 내용을 다시 적용하면서 복습할 수 있었습니다. 특히 다른 사람 코드 작성 방식을 통해 다양한 구현 방법을 확인 해 볼 수 있어 소중한 경험이 되었습니다.   금세미     완성한 앱을 보니 우리가 이 정도 수준의 앱을 만들었다는 것이 믿을 수 없을 정도로 만족스럽고 뿌듯했다.   김시종     처음 프로젝트를 진행하면서 내가 해야할 일이 생기면서 피해끼치지 않고 좋은 프로젝트를 진행하고 싶어 혼자 할때 보다 더 노력을 하게 된 것 같았습니다. 진행될 수록 각자 맡은 내용이 합쳐지고 하나의 결과물이 생기는 과정이 너무 재밌었고 뿌듯했던 과정이었습니다.   송동익     온보딩 주차에 프로젝트를 진행하지 않아서 이번프로젝트가 첫프로젝트였지만, 맡은 임무를 최대한 열심히 하고자 노력을 했다. 하루하루 지나며 아무것도 없던 상태에서 틀이 갖춰지고 하나씩 기능이 갖춰 질때마다, 미천하지만 팀에 기여를 하고있다는 생각에 뿌듯함을 느꼈다.       Wireframe         최종 결과물               시연 영상          ","categories": ["sparta"],
        "tags": ["mini Project"],
        "url": "/sparta/firstTeamProject/",
        "teaser": null
      },{
        "title": "[내배캠] iOS 앱 개발 입문 팀 프로젝트 만들기 / KPT 회고 ",
        "excerpt":"온보딩 프로젝트 KPT 회고  온보딩 프로젝트 발표가 끝났습니다.   팀원들과 프로젝트를 통해 느낀 “Keep (계속할 것)”, “Problem (문제)”, “Try (시도할 것)”의 세 가지 요소를 토대로 프로젝트의 경험을 돌아보고 이야기를 나누었습니다.   Keep     팀원들 간의 소통에 어려움 없이, 커뮤니케이션이 진행되었다.   각자 자신이 하고 싶은 파트를 맡아서 진행하여 더욱 책임감을 가지고 각자의 파트를 완수하였다.   개인이 바라는 기능에 대한 강한 의견 제안보다, 팀 전체 프로젝트 목표를 달성하는 방향을 추구하며 트러블 없이 프로젝트를 완수하였다.   Problem     다양한 문제 해결 방법에 대한 인지            문제점 : 같은 결과를 내기위해 여러가지 구현 방법이 있을 텐데, 다른 방법을 찾아내기 위한 키워드를 알아내기 어려웠다.       해결방안 : 결국에는 공부를 통해서 다양한 키워드를 알 수 있도록 해야 함을 느꼈다.           Git 협업            문제점 : 깃허브를 통한 협업 시 코드컨벤션을 자세하게 작성하지 않아 충돌되는 문제가 발생했다.       해결방안 : 기획 단계에서 구체적인 코드컨벤션을 작성하고 프로젝트를 시작해야 한다.           Try     프로젝트를 진행하며, 나름 디테일하게 생각하고 많은 부분을 앱에 담으려고 노력하고 생각했음에도 불구하고, 다른 팀들의 발표를 보니, 버튼의 색상을 설정하거나, 제품군 안에 한 단계 더 세분화 된 seg를 넣거나, 제품의 색상을 선택하게 하는 등의 놓친 부분이 꽤 많았음을 깨달았다. 다음 프로젝트를 할 때는 좀 더 세세하게 챙겨야겠다는 생각을 했다.   충분히 유져 입장에서 생각을 했다고 하였지만, 결과론적으로 다른 조의 프로젝트와 비교했을 때, 조금은 내실이 부족했다 라는 생각이 든다. 화면 구성이나 기능적인 측면에서 좀 더 유져의 입장에서 생각을 해야겠다 라고 반성을 하게 된다.   기획 단계에서 지금보다 더 상세한 UI 구성이 필요하고, 가능하다면 협업툴(피그마)을 사용한 협업을 경험해보면 좋을 것 같다.   마무리  온보딩 프로젝트보다 많은 소통으로 좋은 결과물이 나온것 같아 만족스럽고 여전히 부족한 점이 많지만 조금 성장하고 있다는 생각을 했습니다.  이번 프로젝트를 돌아보고 다음 프로젝트에서 발전된 방향으로 프로젝트를 진행하도록 하겠습니다.   ","categories": ["sparta"],
        "tags": ["KPT 회고"],
        "url": "/sparta/firstTeamProjectKPT/",
        "teaser": null
      },{
        "title": "[TIL] 내배캠 iOS앱 개발 공부 31일차 - 2024.04.09",
        "excerpt":"알고리즘     오늘의 알고리즘은 도저히 시간초과문제로 풀지 못했다.   구글의 도움을 받아서 문제를 풀 수 있었다.   풀이 보기            기사단원의무기           앱개발 심화     오늘 앱개발 심화반 새로운 팀 편성이 있었다.   새로운 팀에 적응하는 시간이 필요! ! !   프로젝트하는 동안 블로그를 많이 못써서   내일 목표     챌린지 과제 마저하기  ","categories": ["TIL"],
        "tags": ["TIL"],
        "url": "/TIL/til31/",
        "teaser": null
      },{
        "title": "[프로그래머스/Swift] 로또의 최고 순위와 최저 순위",
        "excerpt":"문제 설명     로또 6/45(이하 ‘로또’로 표기)는 1부터 45까지의 숫자 중 6개를 찍어서 맞히는 대표적인 복권입니다. 아래는 로또의 순위를 정하는 방식입니다.                  순위       당첨 내용                       1       6개 번호가 모두 일치                 2       5개 번호가 일치                 3       4개 번호가 일치                 4       3개 번호가 일치                 5       2개 번호가 일치                 6(낙첨)       그 외              로또를 구매한 민우는 당첨 번호 발표일을 학수고대하고 있었습니다. 하지만, 민우의 동생이 로또에 낙서를 하여, 일부 번호를 알아볼 수 없게 되었습니다. 당첨 번호 발표 후, 민우는 자신이 구매했던 로또로 당첨이 가능했던 최고 순위와 최저 순위를 알아보고 싶어 졌습니다.   알아볼 수 없는 번호를 0으로 표기하기로 하고, 민우가 구매한 로또 번호 6개가 44, 1, 0, 0, 31 25라고 가정해보겠습니다. 당첨 번호 6개가 31, 10, 45, 1, 6, 19라면, 당첨 가능한 최고 순위와 최저 순위의 한 예는 아래와 같습니다.                  당첨 번호       31       10       45       1       6       19       결과                       최고 순위 번호       31       0→10       44       1       0→6       25       4개 번호 일치, 3등                 최저 순위 번호       31       0→11       44       1       0→7       25       2개 번호 일치, 5등              순서와 상관없이, 구매한 로또에 당첨 번호와 일치하는 번호가 있으면 맞힌 걸로 인정됩니다.   알아볼 수 없는 두 개의 번호를 각각 10, 6이라고 가정하면 3등에 당첨될 수 있습니다.            3등을 만드는 다른 방법들도 존재합니다. 하지만, 2등 이상으로 만드는 것은 불가능합니다.           알아볼 수 없는 두 개의 번호를 각각 11, 7이라고 가정하면 5등에 당첨될 수 있습니다.            5등을 만드는 다른 방법들도 존재합니다. 하지만, 6등(낙첨)으로 만드는 것은 불가능합니다.                민우가 구매한 로또 번호를 담은 배열 lottos, 당첨 번호를 담은 배열 win_nums가 매개변수로 주어집니다. 이때, 당첨 가능한 최고 순위와 최저 순위를 차례대로 배열에 담아서 return 하도록 solution 함수를 완성해주세요.       문제 풀기   제한사항     lottos는 길이 6인 정수 배열입니다.   lottos의 모든 원소는 0 이상 45 이하인 정수입니다.            0은 알아볼 수 없는 숫자를 의미합니다.       0을 제외한 다른 숫자들은 lottos에 2개 이상 담겨있지 않습니다.       lottos의 원소들은 정렬되어 있지 않을 수도 있습니다.           win_nums은 길이 6인 정수 배열입니다.   win_nums의 모든 원소는 1 이상 45 이하인 정수입니다.            win_nums에는 같은 숫자가 2개 이상 담겨있지 않습니다.       win_nums의 원소들은 정렬되어 있지 않을 수도 있습니다.           입출력 예                  lottos       win_nums       result                       [44, 1, 0, 0, 31, 25]       [31, 10, 45, 1, 6, 19]       [3, 5]                 [0, 0, 0, 0, 0, 0]       [38, 19, 20, 40, 15, 25]       [1, 6]                 [45, 4, 35, 20, 3, 9]       [20, 9, 3, 45, 4, 35]       [1, 1]           입출력 예 설명  입출력 예 #1     문제 예시와 같습니다.   입출력 예 #2     알아볼 수 없는 번호들이 아래와 같았다면, 1등과 6등에 당첨될 수 있습니다.                  당첨 번호       38       19       20       40       15       25       결과                       최고 순위 번호       0→38       0→19       0→20       0→40       0→15       0→25       6개 번호 일치, 1등                 최저 순위 번호       0→21       0→22       0→23       0→24       0→26       0→27       0개 번호 일치, 6등           입출력 예 #3          민우가 구매한 로또의 번호와 당첨 번호가 모두 일치하므로, 최고 순위와 최저 순위는 모두 1등입니다.            실제로 사용되는 로또 순위의 결정 방식과는 약간 다르지만, 이 문제에서는 지문에 명시된 대로 로또 순위를 결정하도록 합니다.       나의 풀이  import Foundation  func solution(_ lottos:[Int], _ win_nums:[Int]) -&gt; [Int] {     var result: [Int] = [6, 6, 5, 4, 3, 2, 1]     var min: Int  = 0     var zeroCnt = lottos.filter { $0 == 0 }.count              for i in win_nums {         for j in lottos {             if j == i {                 min += 1             }         }     }          return [result[min + zeroCnt], result[min]] }   다른 사람 풀이  import Foundation  func solution(_ lottos:[Int], _ win_nums:[Int]) -&gt; [Int] {      let zeroCount = lottos.filter { $0 == 0}.count     let winCount: Int = win_nums.filter { lottos.contains($0) }.count       return [min(7-winCount-zeroCount,6), min(7-winCount,6)] }   나의 풀이방법     일치하는 개수를 Index로 가지는 결과를 리턴하기 위한 배열 생성   0의 개수 구하기   일치하는 개수 구하기   일치하는 수를 확인하고 순위 리턴       다른사람 풀이     zero 카운트 구하는게 변수도 비슷하고 구하는 방법도 똑같았다. 다만 일치하는 수를 구하고 결과를 리턴하는 부분에 차이가 있는데 신기했다.  ","categories": ["Algorithm"],
        "tags": ["Algorithm","coding test","로또의 최고 순위와 최저 순위"],
        "url": "/algorithm/%EB%A1%9C%EB%98%90%EC%9D%98%EC%B5%9C%EA%B3%A0%EC%88%9C%EC%9C%84%EC%99%80%EC%B5%9C%EC%A0%80%EC%88%9C%EC%9C%84/",
        "teaser": null
      },{
        "title": "[TIL] 내배캠 iOS앱 개발 공부 32일차 - 2024.04.11",
        "excerpt":"알고리즘     쉽게 풀었던 오늘의 알고리즘 문제   풀이 보기            로또의 최고 순위와 최저 순위           챌린지반 과제     결국 마지막 페이징 처리는 못했지만 제출했다.   내일 우선 포스팅 예정   화면이동     스토리보드로 화면 연결은 쉽지만 이후 코드로 연결하기, 자동연결이지만 데이터 전달하기등 화면이동의 다양한 방법에 대해서 공부했다.   코드로 화면 이동1 - present   코드로 화면 이동2 - instantiateViewController   코드로 화면 이동3 - performSegue   코드로 화면 이동4 - prepare   내일 목표     팀 프로젝트, 선거 휴무를 지나면서 공부한 내용을 많이 정리하지 못했다 ㅠ 다시 조금씩… 작성해야겠다.   개인 과제 시작하기 , 챌린지 과제 마저 수정  ","categories": ["TIL"],
        "tags": ["TIL"],
        "url": "/TIL/til32/",
        "teaser": null
      },{
        "title": "[UIKit] instantiateViewController 코드로 화면 이동 (다음 화면이 스토리보드에 있지만 세그웨이 연결이 아닌 경우)",
        "excerpt":"세그웨이 없이 코드로 화면 이동     코드로 스토리보드 객체를 생성해서 화면을 이동하는 방법입니다.   1. View Controller에 버튼 추가 및 액션함수 생성     버튼 추가         버튼 액션함수 생성   // MARK: - 다음 화면으로 이동하는 버튼 @IBAction func nextButtonTapped(_ sender: UIButton) { }   2. ViewController 파일 생성     UIViewController를 상속받는 NextViewController 생성     3. 스토리보드에 View Controller 추가 및 class파일 등록, 스토리보드 ID 등록     4. 버튼 액션 함수 수정   // MARK: - 다음 화면으로 이동하는 버튼 @IBAction func nextButtonTapped(_ sender: UIButton) {     //현재 스토리보드에서 \"NextVC\"라는 식별자로 뷰 컨트롤러를 인스턴스화를 시도     guard let nextVC = storyboard?.instantiateViewController(identifier: \"NextVC\") as? NextViewController else { return }     //인스턴스화가 성공하면 새로 생성된 뷰 컨트롤러를 모달로 표시     self.present(nextVC, animated: true, completion: nil) }   5. 실행 화면           마무리     세그웨이 없이 ViewController에 스토리보드ID를 지정하고 연결하기  ","categories": ["UIKit"],
        "tags": ["swift","iOS","instantiateViewController"],
        "url": "/uikit/%EC%BD%94%EB%93%9C%EB%A1%9C%ED%99%94%EB%A9%B4%EC%9D%B4%EB%8F%992/",
        "teaser": null
      },{
        "title": "[UIKit] performSegue 코드로 화면 이동 (스토리보드에서 view와 view를 세그웨이로 연결, 식별자사용)",
        "excerpt":"View와 View를 세그웨이로 연결하고 코드로 화면 이동     세그웨이 식별자를 사용해서 화면이동   1. View Controller에 버튼 추가 및 액션함수 생성     버튼 추가         버튼 액션함수 생성   // MARK: - 다음 화면으로 이동하는 버튼 @IBAction func nextButtonTapped(_ sender: UIButton) { }   2. 스토리보드에서 View Controller 생성 및 연결     스토리보드에 새로 뷰컨트롤러를 추가합니다 (바탕 노란색)   뷰 컨트롤러에서 마우스 우클릭으로 드래그 후 옆에 새로 만든 뷰컨트롤러로 드래그하고 마우스를 떼면 Manual Segue 창이 뜹니다.   Show를 선택합니다.     3. 세그웨이 식별자ID를 추가     세그웨이는 화면 이동을 담당하는 객체입니다.   세그웨이를 선택하고 식별자ID를 추가합니다.     4. 버튼 액션 함수 수정   // MARK: - 다음 화면으로 이동하는 버튼 @IBAction func nextButtonTapped(_ sender: UIButton) {     // 스토리보드에서 View와 View를 세그웨이로 연결 (매뉴얼 세그웨이 or 간접 세그웨이)     self.performSegue(withIdentifier: \"NextVCSegue\", sender: self) //식별자를 사용하여 세그웨이를 실행 }   5. 실행 화면           마무리     view - view를 세그웨이로 연결하고 식별자 ID를 통해 세그웨이를 실행  ","categories": ["UIKit"],
        "tags": ["swift","iOS","performSegue"],
        "url": "/uikit/%EC%BD%94%EB%93%9C%EB%A1%9C%ED%99%94%EB%A9%B4%EC%9D%B4%EB%8F%993/",
        "teaser": null
      },{
        "title": "[UIKit] prepare 코드로 화면 이동 (스토리보드에서 버튼과 view를 세그웨이로 연결, 추가 정보 전달)",
        "excerpt":"스토리보드 버튼과 View를 세그웨이로 연결하고 코드로 화면 이동     세그웨이를 통해 연결됐지만 추가적인 정보를 전달 가능   1. View Controller에 버튼 추가 및 액션함수 생성     버튼을 추가하고 액션함수는 생성하지 않습니다.      2. View Controller 생성 하고 버튼과 연결     뷰 컨트롤러에서 버튼을 마우스 우클릭으로 드래그 후 옆에 새로 만든 뷰컨트롤러로 드래그하고 마우스를 떼면 Action Segue 창이 뜹니다.   Show를 선택합니다.   버튼을 누르면 View Controller로 바로 이동합니다.      3. 세그웨이 식별자ID를 추가     세그웨이는 화면 이동을 담당하는 객체입니다.   세그웨이를 선택하고 식별자ID를 추가합니다.     4. 이동하는 뷰컨트롤러에 Label 추가     버튼으로 화면이동 시 Label의 text값을 변경하기 위함입니다.     5. Next View Controller 수정     Label을 변경하기 위한 코드 수정   전체코드   import UIKit  class NextViewController: UIViewController {     @IBOutlet weak var textLabel: UILabel!     var tempLabel: String?          override func viewDidLoad() {         super.viewDidLoad()                  textLabel.text = tempLabel     } }   6. View Controller prepare 함수 추가     버튼으로 다음화면으로 이동하면서 Label의 값을 변경하기 위해 prepare 함수를 추가하고 코드를 작성합니다.   import UIKit  class ViewController: UIViewController {     override func viewDidLoad() {         super.viewDidLoad()     }          override func prepare(for segue: UIStoryboardSegue, sender: Any?) {         if segue.identifier == \"NextVCSegue\" {             print(\"prepare 함수 실행\")             let nextVC = segue.destination as? NextViewController             nextVC?.tempLabel = \"안녕하세요~~\"         }     } }   7. 실행 화면           마무리     세그웨이를 통해 버튼과 뷰가 자동으로 연결되었으나 데이터 전달등 추가적인 작업을 위해 prepare 함수 추가  ","categories": ["UIKit"],
        "tags": ["swift","iOS","prepare"],
        "url": "/uikit/%EC%BD%94%EB%93%9C%EB%A1%9C%ED%99%94%EB%A9%B4%EC%9D%B4%EB%8F%994/",
        "teaser": null
      },{
        "title": "[내배캠] 챌린지반 과제 1차 제출 - GitHub App 만들기",
        "excerpt":"챌린지반 과제 목표     본인의 깃허브 프로필 페이지를 만들어주세요.   화면 상단에는 프로필 상세 정보가 출력되고 아래는 Repository 목록이 출력되는 앱을 만들어주세요.   Repository 목록은 페이징 처리를 위하여 본인 Repository를 가져온 후 apple의 Repository를 붙여주세요.       요구사항     iOS 15 이상   Swift 5 이상   git을 사용해주세요.   README를 작성해주세요.   가능하다면 MVC 아키텍처를 사용해주세요.            기본 iOS에서 제공하는 ViewController를 사용하면 됩니다.           오픈소스 라이브러리는 아래의 룰을 따라주세요.            필수 사용                    Alamofire           KingFisher or SDWebImage                       아래의 라이브러리는 사용하지 마세요.                    RxSwift, RxCocoa, Rx…..           Moya           SnapKit                       그 외의 라이브러리는 사용하셔도 됩니다. 단 사용하시면 나중에 이유를 설명할 수 있어야 합니다.           Pull To Refresh 기능 구현해주세요.   다음 페이지 스크롤링 가능하게 해주세요.(페이징처리)   디자인은 Code, Storyboard 편하신 방법으로 하시면 됩니다.            단 Code 작성할 때 Frame 기반은 지양해주세요.           TableView나 CollectionView를 사용해주세요.            Delegate, DataSource를 사용해주세요.           디자인은 과제채점에 영향을 주지 않습니다.       라이브러리 설치     코코아팟(cocoapods) 설치하기   알라모파이어(alamofire) 설치하기   SDWebImage 설치하기       새로고침 기능   // MARK: - viewDidLoad() override func viewDidLoad() {     super.viewDidLoad()     //Pull to refresh 추가     tableViewRefresh() }  // MARK: - Pull to refresh 컨트롤 추가 func tableViewRefresh() {     let refreshControl = UIRefreshControl()     refreshControl.attributedTitle = NSAttributedString(string: \"새로고침\")     refreshControl.addTarget(self, action: #selector(refreshData), for: .valueChanged)     repositoriesTableView.refreshControl = refreshControl }  // MARK: - pull to refresh 메서드 @objc func refreshData() {     DispatchQueue.main.asyncAfter(deadline: .now() + 1.0) {         // 테이블 뷰 리로드         self.repositoriesTableView.reloadData()         // UIRefreshControl 종료         self.repositoriesTableView.refreshControl?.endRefreshing()     } }       깃허브에서 정보 가져오기  프로필  // MARK: - 깃허브에서 프로필 정보 가져오기 func getGithubProfile() {     AF.request(profileUrl).responseJSON { response in         switch response.result {         case.success(let value):             if let json = value as? [String: Any],                 let name = json[\"name\"] as? String,                 let login = json[\"login\"] as? String,                 let followers = json[\"followers\"] as? Int,                 let following = json[\"following\"] as? Int,                 let repoCnt = json[\"public_repos\"] as? Int,                 let avatarURLString = json[\"avatar_url\"] as? String,                 let avatarURL = URL(string: avatarURLString) {                                  let profile = GithubProfile(myImage: avatarURL, name: name, login: login, followers: followers, following: following, repoCnt: repoCnt)                                  self.showProfileInfo(profile)                                 }         case .failure(let error):             print(\"error: \\(error)\")         }     } }  // 구조체에서 데이터를 가져와 label 및 imageView에 보여주는 함수 func showProfileInfo(_ profile: GithubProfile) {     //SDWebImage를 사용하여 프로필 이미지 다운로드 및 출력     profileImageView.sd_setImage(with: profile.myImage, placeholderImage: nil, options: [], completed: nil)          profileName.text = profile.name     // 이름 출력     profileLogin.text = profile.login   // 로그인 출력     profileFollowers.text = \"Followers: \\(String(profile.followers))\"   //followers     profileFollowing.text = \"Following: \\(String(profile.following))\"   //following          self.repoCnt = profile.repoCnt     repositoriesTableView.reloadData()  //최초 실행하면 numberOfRowsInSection를 먼저 실행하고 깃허브 데이터를 받아와서 row 수가 0임, row수를 깃허브 repo수 만큼 보이도록 새로고침 추가 }   레포지토리   // MARK: - 깃허브에서 리포지토리 정보 가져오기 func getGithubRepositories() {     AF.request(repositoriesUrl).responseJSON { response in         switch response.result {         case.success(let value):             if let repositories = value as? [[String: Any]] {                 for repo in repositories {                     if let name = repo[\"name\"] as? String,                         let htmlUrl = repo[\"html_url\"] as? String {                             //description, language는 없거나 Null 값이 있어서 닐 코얼레싱 추가                             let description = repo[\"description\"] as? String ?? \"\"                             let language = repo[\"language\"] as? String ?? \"\"                                                          //배열에 저장                             self.repoArr.append(GithubRepositories(name: name, htmlUrl: htmlUrl, description: description, language: language))                     }                 }             }         case .failure(let error):             print(\"에러: \\(error)\")         }     } }       실행화면         실행영상              마무리     테이블뷰 row를 선택할때 배열의 row로 해야하는데 로딩하자마자 tableview에 데이터를 보여주기위해서 프로필에서 repoCnt를 구했다.   로딩때 데이터를 보여주기위해 reload를 많이 사용했는데 다른 방법이 있을 것 같다.   api를 사용할 때 아래 경고문이 떴는데 개선할 방법을 찾지 못했다. 다른 방법을 고민해야할 것 같다.            ‘responseJSON(queue:dataPreprocessor:emptyResponseCodes:emptyRequestMethods:options:completionHandler:)’ is deprecated: responseJSON deprecated and will be removed in Alamofire 6. Use responseDecodable instead.           새로고침할때 배열을 다시 가져오는건데 배열을 초기화 하고 다시 불러야하나 고민했는데 우선 그냥 진행했다.   페이징처리를 못해서 찾아보고 추가해야겠다.   배운내용을 활용해서 구현하였고 라이브러리 설치와 api 사용을 경험해볼 수 있었다.   튜터님 피드백 받고 다시 수정 해봐야겠다. 우선 제출! 🔥🔥🔥  ","categories": ["sparta"],
        "tags": ["챌린지","과제","깃허브앱"],
        "url": "/sparta/%EC%B1%8C%EB%A6%B0%EC%A7%80%EB%B0%98%EA%B3%BC%EC%A0%9C1-1/",
        "teaser": null
      },{
        "title": "[TIL] 내배캠 iOS앱 개발 공부 33일차 - 2024.04.12",
        "excerpt":"알고리즘     오늘의 알고리즘 문제는 1시간정도 고민했는데 생각보다 풀리지 않아서 못 풀었다.   갈수록 어려워지는건지 .. 밑천이 들어나는건지 .. 고차함수를 다시 복습해야겠다.   챌린지반 과제     1차 제출은 했는데 튜터님이 피드백을 주셨다. 피드백 주신내용으로 다시 수정해볼예정 ㅠ ㅠ   챌린지반 과제 1차 제출   내일 목표     개인 과제 시작하기 , 챌린지 과제 마저 수정하기 , 깃 ,, 알고리즘 …  ","categories": ["TIL"],
        "tags": ["TIL"],
        "url": "/TIL/til33/",
        "teaser": null
      },{
        "title": "[프로그래머스/Swift] 옹알이(2)",
        "excerpt":"문제 설명          머쓱이는 태어난 지 11개월 된 조카를 돌보고 있습니다. 조카는 아직 “aya”, “ye”, “woo”, “ma” 네 가지 발음과 네 가지 발음을 조합해서 만들 수 있는 발음밖에 하지 못하고 연속해서 같은 발음을 하는 것을 어려워합니다. 문자열 배열 babbling이 매개변수로 주어질 때, 머쓱이의 조카가 발음할 수 있는 단어의 개수를 return하도록 solution 함수를 완성해주세요.            문제 풀기       제한사항     1 ≤ babbling의 길이 ≤ 100   1 ≤ babbling[i]의 길이 ≤ 30   문자열은 알파벳 소문자로만 이루어져 있습니다.   입출력 예                  babbling       result                       [“aya”, “yee”, “u”, “maa”]       1                 [“ayaye”, “uuu”, “yeye”, “yemawoo”, “ayaayaa”]       2           입출력 예 설명  입출력 예 #1     [“aya”, “yee”, “u”, “maa”]에서 발음할 수 있는 것은 “aya”뿐입니다. 따라서 1을 return합니다.   입출력 예 #2     [“ayaye”, “uuu”, “yeye”, “yemawoo”, “ayaayaa”]에서 발음할 수 있는 것은 “aya” + “ye” = “ayaye”, “ye” + “ma” + “woo” = “yemawoo”로 2개입니다. “yeye”는 같은 발음이 연속되므로 발음할 수 없습니다. 따라서 2를 return합니다.   유의사항     네 가지를 붙여 만들 수 있는 발음 이외에는 어떤 발음도 할 수 없는 것으로 규정합니다. 예를 들어 “woowo”는 “woo”는 발음할 수 있지만 “wo”를 발음할 수 없기 때문에 할 수 없는 발음입니다.   나의 풀이  import Foundation  func solution(_ babbling:[String]) -&gt; Int {     let mussuk: [String] = [\"aya\", \"ye\", \"woo\", \"ma\"]     var overlapFlag: Bool = false     var cnt: Int = 0          for word in babbling {         for babyWord in mussuk {             //중복 확인             if word.contains(babyWord + babyWord) {                 overlapFlag = true             }         }                  if overlapFlag {             overlapFlag = false         } else {             //중복이 아니면 단어체크             //print(\"체크할 단어: \\(word)\")             var tempWord: String = word             for babyWord in mussuk {                 tempWord = tempWord.replacingOccurrences(of: babyWord, with: \".\")             }                          //.으로만 된 단어는 발음 가능             if tempWord.allSatisfy({ $0 == \".\" }) {                 cnt += 1             }         }     }          return cnt }   다른 사람 풀이  import Foundation  func solution(_ babbling:[String]) -&gt; Int {     var count: Int = 0     for element in babbling {         var str = String(element)         str = str.replacingOccurrences(of: \"aya\", with: \"1\")         str = str.replacingOccurrences(of: \"ye\", with: \"2\")         str = str.replacingOccurrences(of: \"woo\", with: \"3\")         str = str.replacingOccurrences(of: \"ma\", with: \"4\")         if Int(str) != nil &amp;&amp; !str.contains(\"11\") &amp;&amp; !str.contains(\"22\") &amp;&amp; !str.contains(\"33\") &amp;&amp; !str.contains(\"44\"){             count += 1         }     }         return count }   나의 풀이방법     중복해서 나오는 단어를 찾아서 발음할 수 있는 단어에서 제외시키기   발음 가능한 단어를 .으로 바꿔버리기   문자열을 이루는 문자가 .으로만 이루어진 경우 발음 가능 카운트   contains, replacingOccurrences, allSatisfy 컬렉션에 대해 작동하는 메서드를 잘 사용한것 같아 개인적으로는 만족스러웠다.       다른사람 풀이     다른 풀이도 replacingOccurrences을 사용해서 많이 푼 것 같다.  ","categories": ["Algorithm"],
        "tags": ["Algorithm","swift","coding test","프로그래머스","알고리즘","옹알이"],
        "url": "/algorithm/%EC%98%B9%EC%95%8C%EC%9D%B4(2)/",
        "teaser": null
      },{
        "title": "[UIKit] URLSession이란? ",
        "excerpt":"URLSession이란?     Swift에서 URLSession은 네트워크 작업을 수행하기 위한 핵심 클래스입니다. 이 클래스를 사용하여 HTTP 및 HTTPS를 통한 데이터를 전송하고, 데이터를 다운로드하거나 업로드하며, 기타 네트워크 관련 작업을 처리할 수 있습니다.   URLSession의 주요 특징     비동기적 네트워킹 (Asynchronous Networking) URLSession은 비동기적으로 네트워크 요청을 처리하므로, 네트워크 작업이 백그라운드에서 수행될 수 있습니다.  이는 앱의 성능을 향상시키고 응답성을 유지하는 데 도움이 됩니다.   다양한 데이터 전송 방식 지원 URLSession을 사용하여 데이터를 업로드하거나 다운로드할 수 있으며, JSON, 이미지, 파일 등 다양한 데이터 형식을 처리할 수 있습니다.  이번 숙련 챕터에서의 예제는 JSON 데이터를 다운로드하여 사용합니다.   캐시와 쿠키 관리 URLSession은 네트워크 응답을 캐싱하고 쿠키를 관리할 수 있는 기능을 제공합니다.   예제코드     깃허브 API를 통해 JSON형식으로 구성된 깃허브 프로필 정보 가져와 Xcode에서 출력하는 예제입니다.   1. GitHub 프로필 정보 확인     아래 주소로 접속하면 데이터를 확인할 수 있습니다.   https://api.github.com/users/깃허브아이디   {   \"login\": \"limlogging\",   \"id\": 156410026,   \"node_id\": \"U_kgDOCVKgqg\",   \"avatar_url\": \"https://avatars.githubusercontent.com/u/156410026?v=4\",   \"gravatar_id\": \"\",   \"url\": \"https://api.github.com/users/limlogging\",   \"html_url\": \"https://github.com/limlogging\",   \"followers_url\": \"https://api.github.com/users/limlogging/followers\",   \"following_url\": \"https://api.github.com/users/limlogging/following{/other_user}\",   \"gists_url\": \"https://api.github.com/users/limlogging/gists{/gist_id}\",   \"starred_url\": \"https://api.github.com/users/limlogging/starred{/owner}{/repo}\",   \"subscriptions_url\": \"https://api.github.com/users/limlogging/subscriptions\",   \"organizations_url\": \"https://api.github.com/users/limlogging/orgs\",   \"repos_url\": \"https://api.github.com/users/limlogging/repos\",   \"events_url\": \"https://api.github.com/users/limlogging/events{/privacy}\",   \"received_events_url\": \"https://api.github.com/users/limlogging/received_events\",   \"type\": \"User\",   \"site_admin\": false,   \"name\": \"HyeongSub Lim\",   \"company\": null,   \"blog\": \"\",   \"location\": null,   \"email\": null,   \"hireable\": null,   \"bio\": null,   \"twitter_username\": null,   \"public_repos\": 10,   \"public_gists\": 0,   \"followers\": 5,   \"following\": 8,   \"created_at\": \"2024-01-12T07:38:28Z\",   \"updated_at\": \"2024-03-31T05:44:31Z\" }   2. 프로필 정보를 담을 구조체 정의     깃허브 api주소에서 확인한 key 값으로 구조체 변수를 정의합니다.   swift에서 카멜케이스를 사용하는데 image의 경우 키 값이 avatar_url이라 CodingKey를 사용하여 카멜케이스로 변경합니다.   프로토콜            Codable                    Codable은 Swift 4에서 추가된 프로토콜           Codable은 Encodable과 Decodable을 결합한 것           데이터를 쉽게 인코딩(직렬화) 및 디코딩(역직렬화)할 수 있도록 도와줌                       Encodable                    타입을 JSON이나 다른 형식으로 인코딩할 수 있도록 함                       Decodable                    JSON이나 다른 형식의 데이터를 타입으로 디코딩할 수 있도록 함                           struct GitHubProfile: Codable {     let login: String           // GitHub 사용자의 로그인 이름     let profileImage: String    // GitHub 사용자의 프로필 이미지 URL      // CodingKeys 열거형: JSON 데이터와 구조체 속성 간의 매핑을 지정     enum CodingKeys: String, CodingKey {         case login // login 속성은 JSON의 login 키와 매핑         case profileImage = \"avatar_url\" // profileImage 속성은 JSON의 avatar_url 키와 매핑     } }   3. 데이터를 받아오고 저장하기  class GitHubProfileViewController: UIViewController {     // GitHub 사용자 프로필 정보를 가져올 URL     let url: String = \"https://api.github.com/users/limlogging\"          override func viewDidLoad() {         super.viewDidLoad()         // GitHub 프로필 정보를 가져오는 함수 호출         getGitHubProfile(url)     }          // GitHub 프로필 정보를 가져오는 함수 정의     func getGitHubProfile(_ urlString: String) {         // URL 문자열을 URL 객체로 변환         guard let url = URL(string: urlString) else { return }                  // URLSession 객체 생성: HTTP 요청을 수행하기 위한 세션         let session = URLSession(configuration: .default)                  // 데이터 태스크 생성: 비동기적으로 URL로부터 데이터를 가져옴         let task = session.dataTask(with: url) {             (data, response, error) in             if let error = error {                 // 에러가 발생한 경우 에러 메시지 출력                 print(error)             } else if let data = data {                 do {                     // JSON 데이터를 GitHubProfile 구조체로 디코딩                     let gitHubProfile = try JSONDecoder().decode(GitHubProfile.self, from: data)                     // 디코딩된 GitHub 프로필 정보 출력                     print(\"login: \\(gitHubProfile.login)\")                     print(\"profileImage: \\(gitHubProfile.profileImage)\")                 } catch {                     // 디코딩 실패 시 에러 메시지 출력                     print(\"Decode Error: \\(error)\")                 }             }         }         // 데이터 태스크 시작         task.resume()     } }   4. 출력결과  login: limlogging profileImage: https://avatars.githubusercontent.com/u/156410026?v=4   마무리     URL: 요청할 URL 생성, GitHub API의 사용자 프로필 정보를 가져올 URL을 저장   session: URLSession 객체를 생성하여 HTTP 요청을 수행하기 위한 세션을 설정   dataTask: URLSession 객체를 사용하여 비동기적으로 데이터를 가져오는 데이터 태스크를 생성. 클로저를 활용하여 데이터를 받아온 후의 동작을 지정   resume: 데이터 태스크를 시작하여 비동기적으로 데이터를 가져오는 작업을 실행  ","categories": ["UIKit"],
        "tags": ["swift","iOS","URLSession"],
        "url": "/UIKit/URLSession/",
        "teaser": null
      },{
        "title": "[내배캠] iOS 앱 개발 숙련 개인 과제 - WishList 앱 만들기 1",
        "excerpt":"WishList 앱 만들기     네트워크 통신과 내부 저장소를 사용하여 WishList 앱 만들기입니다.       과제 요구사항     필수과제            Lv1. 데이터 모델링하기       Lv2. 위시 리스트 메인 페이지 구현       Lv3. “위시 리스트 보기” 페이지 구현           선택과제            Lv4. TableView에서 스와이프하여 삭제기능 구현       Lv5. UIRefreshControl을 사용한 새로고침 구현               스토리보드를 사용해서 시작     코드베이스로 시작했다가 버튼 위치 조절하고 이것 저것 하다보니 개발 속도가 더뎌 스토리보드로 바꿔서 새로 시작했습니다. ㅠ       기능 구현  1. 스토리보드에 UI 구성하기     확실히 코드로 하나씩 하는것보다 빠릅니다. ㅠ ㅠ      2. Data 가져오기     dummyjson 사이트에서 랜덤하게 데이터를 받아옵니다.   원래 주석처리된 부분처럼 사용했는데 경고 메시지가 많이 발생해서 튜터님 가이드에 따라 속성감시자로 수정했습니다.   getData()  func getData() {     let productID: Int = Int.random(in: 1...100)      if let url = URL(string: \"https://dummyjson.com/products/\\(productID)\") {         print(\"url: \\(url)\")         //URLSessionDataTask를 사용하여 비동기적으로 데이터 요청         let task = URLSession.shared.dataTask(with: url) { (data, response, error) in             if let error = error {                 print(\"Error: \\(error)\")             } else if let data = data {                 do {                     let product = try JSONDecoder().decode(ProductsManager.self, from: data)                                  self.currentProduct = product   //데이터 설정   //                        DispatchQueue.main.async { //                            self.productPriceLabel.text = String(product.price) //                            self.productTitleLabel.text = product.title //                            self.productDescriptionLabel.text = product.description //                             //                        } //                        DispatchQueue.main.async { //                            //이미지 URL 가져오기 //                            if let productUrlString = product.thumbnail as? String, //                               let productImageUrl = URL(string: productUrlString) { //                                // 이미지 데이터를 다운로드하여 이미지 뷰에 표시 //                                if let imageData = try? Data(contentsOf: productImageUrl) { //                                    //DispatchQueue.main.async { //                                    self.productImageView.image = UIImage(data: imageData) //                                    //} //                                } //                            } //                        }                 } catch {                     print(\"Decode Error: \\(error)\")                 }             }         }         task.resume()     } }       속성감시자 설정  private var currentProduct: ProductsManager? = nil {     didSet {         //currentProduct가 nil이 아닌지 확인하고 종료하기          guard let currentProduct = self.currentProduct else { return }                  //메인 스레드에서 UI 업데이트를 수행         DispatchQueue.main.async {             self.productImageView.image = nil             self.productTitleLabel.text = currentProduct.title             self.productDescriptionLabel.text = currentProduct.description             self.productPriceLabel.text = \"\\(currentProduct.price)$\"         }                  // 백그라운드 스레드에서 제품의 섬네일 이미지를 비동기적으로 가져오기          DispatchQueue.global().async { [weak self] in             // 제품의 섬네일 이미지 데이터를 가져와 UIImage로 변환             if let data = try? Data(contentsOf: currentProduct.thumbnail), let image = UIImage(data: data) {                 // 가져온 이미지를 메인 스레드에서 productImageView에 설정하여 이미지 출력                  DispatchQueue.main.async { self?.productImageView.image = image }             }         }     } }   3. CoreData 저장하기     coredata 설정이 데이터베이스 테이블을 만들고 컬럼을 추가하는 것과 비슷한 것 같다.   Entities 추가 및 Attributes 추가     AppDelegate.swift 파일 수정     처음 프로젝트 만들때 코어데이터를 추가하고 만들면 자동으로 코드가 추가됩니다.   import CoreData, persistentContainer 메서드, saveContext 메서드를 추가합니다.   core Data를 나중에 추가하는 경우 파일 추가에서 Data Model로 생성하면 됩니다.   import UIKit import CoreData //필수   @main class AppDelegate: UIResponder, UIApplicationDelegate {     //중간코드 생략       // MARK: - Core Data stack     lazy var persistentContainer: NSPersistentContainer = {         let container = NSPersistentContainer(name: \"MyWishList\")   //core data 이름          container.loadPersistentStores(completionHandler: { (storeDescription, error) in             if let error = error as NSError? {                 fatalError(\"Unresolved error \\(error), \\(error.userInfo)\")             }         })         return container     }()      // MARK: - Core Data Saving support     func saveContext () {         let context = persistentContainer.viewContext         if context.hasChanges {             do {                 try context.save()             } catch {                 let nserror = error as NSError                 fatalError(\"Unresolved error \\(nserror), \\(nserror.userInfo)\")             }         }     } }       viewController 수정  import CoreData //필수   class ViewController: UIViewController {     //UIApplication의 shared 인스턴스를 통해 AppDelegate에 접근하고 persistentContainer 속성 반환     var persistentContainer: NSPersistentContainer? {         (UIApplication.shared.delegate as? AppDelegate)?.persistentContainer     } }  위시리스트 담기 버튼 수정     alert를 사용하여 입력 확인, 중복 데이터인 경우 알림창을 띄우도록 하였습니다.       // MARK: - 위시 리스트 담기 버튼 선택     @IBAction func addToWishListButtonTapped(_ sender: UIButton) {         guard let product = self.currentProduct else { return }                  // 위시리스트 담기 전 중복 확인         if checkId(String(product.id)) {             let alertController = UIAlertController(title: \"중복 확인\", message: \"이미 위시 리스트에 포함되어 있습니다.\", preferredStyle: .alert)             let cancel = UIAlertAction(title: \"확인\", style: .cancel, handler: { _ in return })                          alertController.addAction(cancel)             present(alertController, animated: true, completion: nil)         } else {             //코어데이터에 저장             guard let context = self.persistentContainer?.viewContext else { return }             let myWishList = MyWishList(context: context)                          myWishList.id = String(product.id)             myWishList.title = product.title             myWishList.price = String(product.price)             //저장             try? context.save()                          let alertController = UIAlertController(title: \"위시 리스트 담기\", message: \"해당 상품을 위시 리스트에 담았습니다.\", preferredStyle: .alert)             let addToWishList = UIAlertAction(title: \"확인\", style: .default, handler: { _ in return })                          alertController.addAction(addToWishList)             present(alertController, animated: true, completion: nil)         }     }   중복 ID 체크     // MARK: - 중복 ID 체크     func checkId(_ id: String) -&gt; Bool {         //true 중복, false 중복아님         guard let context = self.persistentContainer?.viewContext else { return true }         let request = MyWishList.fetchRequest()         guard let myWishList = try? context.fetch(request) else { return true }                  if myWishList.filter({ $0.id == id}).count != 0 {             //중복             return true         } else {             //중복 아님             return false         }     }       4. 다른 상품 보기      // MARK: - 다른 상품 보기 버튼 선택     @IBAction func otherProductButtonTapped(_ sender: UIButton) {         self.getData()     }   5. 위시리스트보기     viewController와 별개로 WishListViewController파일을 추가하였습니다.   import CoreData  class WishListViewController: UIViewController {     // MARK: - 코어데이터를 사용하기 위한 설정     var persistentContainer: NSPersistentContainer? {         (UIApplication.shared.delegate as? AppDelegate)?.persistentContainer     }     var productList: [MyWishList] = []  //코어데이터를 가져와 배열에 담기           @IBOutlet weak var wishListTableView: UITableView!          override func viewDidLoad() {         super.viewDidLoad()         wishListTableView.dataSource = self //데이터소스 설정                           getCoreData()   //데이터가져오기      }     //나머지 코드 생략  }       코어데이터 가져오기      // MARK: - CoreData에서 데이터 가져오기     func getCoreData() {         guard let context = self.persistentContainer?.viewContext else { return }              let request = MyWishList.fetchRequest()              if let products = try? context.fetch(request) {             self.productList = products         }     }   tableView Data Source 추가  extension WishListViewController: UITableViewDataSource {     func tableView(_ tableView: UITableView, numberOfRowsInSection section: Int) -&gt; Int {         return productList.count     }          func tableView(_ tableView: UITableView, cellForRowAt indexPath: IndexPath) -&gt; UITableViewCell {         let cell = tableView.dequeueReusableCell(withIdentifier: \"WishListTableViewCell\", for: indexPath) as? WishListTableViewCell                          let id = \"[\" + (productList[indexPath.row].id ?? \"\") + \"]\"         let title = productList[indexPath.row].title         let price = productList[indexPath.row].price                  cell?.productIdLabel.text = id         cell?.productTitleLabel.text = title         cell?.productPriceLabel.text = price                  return cell ?? UITableViewCell()     } }   실행화면     메인화면, 다른상품보기, 위시리스트 확인 화면입니다.            실행영상              마무리     가격에 , 추가해야하는데 빼먹어버렸다. 내일 다시 추가할 예정   필수 과제까지는 완료했는데 선택과제도 내일 다시 구현 에정   ⭐️⭐️ 데이터가져오기 및 코어데이터 사용은 강의 예제와 동일해서 많이 사용해보고 익숙해져야겠다. ⭐️⭐️  ","categories": ["sparta"],
        "tags": ["sparta","앱 개발 숙련","WishList","ios","uikit","swift"],
        "url": "/sparta/wishList1/",
        "teaser": null
      },{
    "title": "Hi, guys!!! 👋🏻👋🏻",
    "excerpt":"About     🧑🏻‍💻 iOS Developer   🌱 Swift   🌿 currently learning Storyboard, SwiftUI   ⚡ github blog: https://limlogging.github.io/  ","url": "http://localhost:4000/about/"
  },{
    "title": "Posts by Category",
    "excerpt":" ","url": "http://localhost:4000/categories/"
  },{
    "title": "Algorithm",
    "excerpt":" ","url": "http://localhost:4000/categories/Algorithm/"
  },{
    "title": "Git",
    "excerpt":" ","url": "http://localhost:4000/categories/git/"
  },{
    "title": "GitHub Blog",
    "excerpt":" ","url": "http://localhost:4000/categories/GitHubBlog/"
  },{
    "title": "내배캠 부트캠프",
    "excerpt":" ","url": "http://localhost:4000/categories/sparta/"
  },{
    "title": "Swift",
    "excerpt":" ","url": "http://localhost:4000/categories/swift/"
  },{
    "title": "SwiftUI",
    "excerpt":" ","url": "http://localhost:4000/categories/SwiftUI/"
  },{
    "title": "Today I Learned",
    "excerpt":" ","url": "http://localhost:4000/categories/TIL/"
  },{
    "title": "UIKit",
    "excerpt":" ","url": "http://localhost:4000/categories/UIKit/"
  },{
    "title": null,
    "excerpt":"","url": "http://localhost:4000/"
  },{
    "title": null,
    "excerpt":"var idx = lunr(function () {   this.field('title')   this.field('excerpt')   this.field('categories')   this.field('tags')   this.ref('id')    this.pipeline.remove(lunr.trimmer)    for (var item in store) {     this.add({       title: store[item].title,       excerpt: store[item].excerpt,       categories: store[item].categories,       tags: store[item].tags,       id: item     })   } });  $(document).ready(function() {   $('input#search').on('keyup', function () {     var resultdiv = $('#results');     var query = $(this).val().toLowerCase();     var result =       idx.query(function (q) {         query.split(lunr.tokenizer.separator).forEach(function (term) {           q.term(term, { boost: 100 })           if(query.lastIndexOf(\" \") != query.length-1){             q.term(term, {  usePipeline: false, wildcard: lunr.Query.wildcard.TRAILING, boost: 10 })           }           if (term != \"\"){             q.term(term, {  usePipeline: false, editDistance: 1, boost: 1 })           }         })       });     resultdiv.empty();     resultdiv.prepend(''+result.length+' 개 결과 발견 ');     for (var item in result) {       var ref = result[item].ref;       if(store[ref].teaser){         var searchitem =           ''+             ''+               ''+                 ''+store[ref].title+''+               ' '+               ''+                 ''+               ''+               ''+store[ref].excerpt.split(\" \").splice(0,20).join(\" \")+'... '+             ''+           '';       }       else{     \t  var searchitem =           ''+             ''+               ''+                 ''+store[ref].title+''+               ' '+               ''+store[ref].excerpt.split(\" \").splice(0,20).join(\" \")+'... '+             ''+           '';       }       resultdiv.append(searchitem);     }   }); }); ","url": "http://localhost:4000/assets/js/lunr/lunr-en.js"
  },{
    "title": null,
    "excerpt":"step1list = new Array(); step1list[\"ΦΑΓΙΑ\"] = \"ΦΑ\"; step1list[\"ΦΑΓΙΟΥ\"] = \"ΦΑ\"; step1list[\"ΦΑΓΙΩΝ\"] = \"ΦΑ\"; step1list[\"ΣΚΑΓΙΑ\"] = \"ΣΚΑ\"; step1list[\"ΣΚΑΓΙΟΥ\"] = \"ΣΚΑ\"; step1list[\"ΣΚΑΓΙΩΝ\"] = \"ΣΚΑ\"; step1list[\"ΟΛΟΓΙΟΥ\"] = \"ΟΛΟ\"; step1list[\"ΟΛΟΓΙΑ\"] = \"ΟΛΟ\"; step1list[\"ΟΛΟΓΙΩΝ\"] = \"ΟΛΟ\"; step1list[\"ΣΟΓΙΟΥ\"] = \"ΣΟ\"; step1list[\"ΣΟΓΙΑ\"] = \"ΣΟ\"; step1list[\"ΣΟΓΙΩΝ\"] = \"ΣΟ\"; step1list[\"ΤΑΤΟΓΙΑ\"] = \"ΤΑΤΟ\"; step1list[\"ΤΑΤΟΓΙΟΥ\"] = \"ΤΑΤΟ\"; step1list[\"ΤΑΤΟΓΙΩΝ\"] = \"ΤΑΤΟ\"; step1list[\"ΚΡΕΑΣ\"] = \"ΚΡΕ\"; step1list[\"ΚΡΕΑΤΟΣ\"] = \"ΚΡΕ\"; step1list[\"ΚΡΕΑΤΑ\"] = \"ΚΡΕ\"; step1list[\"ΚΡΕΑΤΩΝ\"] = \"ΚΡΕ\"; step1list[\"ΠΕΡΑΣ\"] = \"ΠΕΡ\"; step1list[\"ΠΕΡΑΤΟΣ\"] = \"ΠΕΡ\"; step1list[\"ΠΕΡΑΤΑ\"] = \"ΠΕΡ\"; step1list[\"ΠΕΡΑΤΩΝ\"] = \"ΠΕΡ\"; step1list[\"ΤΕΡΑΣ\"] = \"ΤΕΡ\"; step1list[\"ΤΕΡΑΤΟΣ\"] = \"ΤΕΡ\"; step1list[\"ΤΕΡΑΤΑ\"] = \"ΤΕΡ\"; step1list[\"ΤΕΡΑΤΩΝ\"] = \"ΤΕΡ\"; step1list[\"ΦΩΣ\"] = \"ΦΩ\"; step1list[\"ΦΩΤΟΣ\"] = \"ΦΩ\"; step1list[\"ΦΩΤΑ\"] = \"ΦΩ\"; step1list[\"ΦΩΤΩΝ\"] = \"ΦΩ\"; step1list[\"ΚΑΘΕΣΤΩΣ\"] = \"ΚΑΘΕΣΤ\"; step1list[\"ΚΑΘΕΣΤΩΤΟΣ\"] = \"ΚΑΘΕΣΤ\"; step1list[\"ΚΑΘΕΣΤΩΤΑ\"] = \"ΚΑΘΕΣΤ\"; step1list[\"ΚΑΘΕΣΤΩΤΩΝ\"] = \"ΚΑΘΕΣΤ\"; step1list[\"ΓΕΓΟΝΟΣ\"] = \"ΓΕΓΟΝ\"; step1list[\"ΓΕΓΟΝΟΤΟΣ\"] = \"ΓΕΓΟΝ\"; step1list[\"ΓΕΓΟΝΟΤΑ\"] = \"ΓΕΓΟΝ\"; step1list[\"ΓΕΓΟΝΟΤΩΝ\"] = \"ΓΕΓΟΝ\";  v = \"[ΑΕΗΙΟΥΩ]\"; v2 = \"[ΑΕΗΙΟΩ]\"  function stemWord(w) {   var stem;   var suffix;   var firstch;   var origword = w;   test1 = new Boolean(true);    if(w.length '+result.length+' 개 결과 발견 ');     for (var item in result) {       var ref = result[item].ref;       if(store[ref].teaser){         var searchitem =           ''+             ''+               ''+                 ''+store[ref].title+''+               ' '+               ''+                 ''+               ''+               ''+store[ref].excerpt.split(\" \").splice(0,20).join(\" \")+'... '+             ''+           '';       }       else{     \t  var searchitem =           ''+             ''+               ''+                 ''+store[ref].title+''+               ' '+               ''+store[ref].excerpt.split(\" \").splice(0,20).join(\" \")+'... '+             ''+           '';       }       resultdiv.append(searchitem);     }   }); }); ","url": "http://localhost:4000/assets/js/lunr/lunr-gr.js"
  },{
    "title": null,
    "excerpt":"var store = [   {%- for c in site.collections -%}     {%- if forloop.last -%}       {%- assign l = true -%}     {%- endif -%}     {%- assign docs = c.docs | where_exp:'doc','doc.search != false' -%}     {%- for doc in docs -%}       {%- if doc.header.teaser -%}         {%- capture teaser -%}{{ doc.header.teaser }}{%- endcapture -%}       {%- else -%}         {%- assign teaser = site.teaser -%}       {%- endif -%}       {         \"title\": {{ doc.title | jsonify }},         \"excerpt\":           {%- if site.search_full_content == true -%}             {{ doc.content | newline_to_br |               replace:\" \", \" \" |               replace:\" \", \" \" |               replace:\" \", \" \" |               replace:\" \", \" \" |               replace:\" \", \" \" |               replace:\" \", \" \" |               replace:\" \", \" \" |               replace:\" \", \" \"|             strip_html | strip_newlines | jsonify }},           {%- else -%}             {{ doc.content | newline_to_br |               replace:\" \", \" \" |               replace:\" \", \" \" |               replace:\" \", \" \" |               replace:\" \", \" \" |               replace:\" \", \" \" |               replace:\" \", \" \" |               replace:\" \", \" \" |               replace:\" \", \" \"|             strip_html | strip_newlines | truncatewords: 50 | jsonify }},           {%- endif -%}         \"categories\": {{ doc.categories | jsonify }},         \"tags\": {{ doc.tags | jsonify }},         \"url\": {{ doc.url | relative_url | jsonify }},         \"teaser\": {{ teaser | relative_url | jsonify }}       }{%- unless forloop.last and l -%},{%- endunless -%}     {%- endfor -%}   {%- endfor -%}{%- if site.lunr.search_within_pages -%},   {%- assign pages = site.pages | where_exp:'doc','doc.search != false' -%}   {%- for doc in pages -%}     {%- if forloop.last -%}       {%- assign l = true -%}     {%- endif -%}   {     \"title\": {{ doc.title | jsonify }},     \"excerpt\":         {%- if site.search_full_content == true -%}           {{ doc.content | newline_to_br |             replace:\" \", \" \" |             replace:\" \", \" \" |             replace:\" \", \" \" |             replace:\" \", \" \" |             replace:\" \", \" \" |             replace:\" \", \" \" |             replace:\" \", \" \" |             replace:\" \", \" \"|           strip_html | strip_newlines | jsonify }},         {%- else -%}           {{ doc.content | newline_to_br |             replace:\" \", \" \" |             replace:\" \", \" \" |             replace:\" \", \" \" |             replace:\" \", \" \" |             replace:\" \", \" \" |             replace:\" \", \" \" |             replace:\" \", \" \" |             replace:\" \", \" \"|           strip_html | strip_newlines | truncatewords: 50 | jsonify }},         {%- endif -%}       \"url\": {{ doc.url | absolute_url | jsonify }}   }{%- unless forloop.last and l -%},{%- endunless -%}   {%- endfor -%} {%- endif -%}] ","url": "http://localhost:4000/assets/js/lunr/lunr-store.js"
  },{
    "title": null,
    "excerpt":"      {% for post in site.posts %}              {{ site.url }}{{ post.url }}         {% if post.lastmod == null %}         {{ post.date | date_to_xmlschema }}         {% else %}         {{ post.lastmod | date_to_xmlschema }}         {% endif %}         {% if post.sitemap.changefreq == null %}         weekly         {% else %}         {{ post.sitemap.changefreq }}         {% endif %}         {% if post.sitemap.priority == null %}         0.5         {% else %}         {{ post.sitemap.priority }}         {% endif %}          {% endfor %} ","url": "http://localhost:4000/sitemap.xml"
  },{
    "title": null,
    "excerpt":"","url": "http://localhost:4000/page2/"
  },{
    "title": null,
    "excerpt":"","url": "http://localhost:4000/page3/"
  },{
    "title": null,
    "excerpt":"","url": "http://localhost:4000/page4/"
  },{
    "title": null,
    "excerpt":"","url": "http://localhost:4000/page5/"
  },{
    "title": null,
    "excerpt":"","url": "http://localhost:4000/page6/"
  },{
    "title": null,
    "excerpt":"","url": "http://localhost:4000/page7/"
  },{
    "title": null,
    "excerpt":"","url": "http://localhost:4000/page8/"
  },{
    "title": null,
    "excerpt":"","url": "http://localhost:4000/page9/"
  },{
    "title": null,
    "excerpt":"","url": "http://localhost:4000/page10/"
  },{
    "title": null,
    "excerpt":"","url": "http://localhost:4000/page11/"
  },{
    "title": null,
    "excerpt":"","url": "http://localhost:4000/page12/"
  },{
    "title": null,
    "excerpt":"","url": "http://localhost:4000/page13/"
  },{
    "title": null,
    "excerpt":"","url": "http://localhost:4000/page14/"
  },{
    "title": null,
    "excerpt":"","url": "http://localhost:4000/page15/"
  },{
    "title": null,
    "excerpt":"","url": "http://localhost:4000/page16/"
  },{
    "title": null,
    "excerpt":"","url": "http://localhost:4000/page17/"
  },{
    "title": null,
    "excerpt":"","url": "http://localhost:4000/page18/"
  },{
    "title": null,
    "excerpt":"","url": "http://localhost:4000/page19/"
  },{
    "title": null,
    "excerpt":"","url": "http://localhost:4000/page20/"
  },{
    "title": null,
    "excerpt":"","url": "http://localhost:4000/page21/"
  },{
    "title": null,
    "excerpt":"","url": "http://localhost:4000/page22/"
  },{
    "title": null,
    "excerpt":"","url": "http://localhost:4000/page23/"
  },{
    "title": null,
    "excerpt":"","url": "http://localhost:4000/page24/"
  },{
    "title": null,
    "excerpt":"","url": "http://localhost:4000/page25/"
  },{
    "title": null,
    "excerpt":"","url": "http://localhost:4000/page26/"
  },{
    "title": null,
    "excerpt":"","url": "http://localhost:4000/page27/"
  },{
    "title": null,
    "excerpt":"","url": "http://localhost:4000/page28/"
  },{
    "title": null,
    "excerpt":"","url": "http://localhost:4000/page29/"
  },{
    "title": null,
    "excerpt":"","url": "http://localhost:4000/page30/"
  },{
    "title": null,
    "excerpt":"{% if page.xsl %}{% endif %}Jekyll{{ site.time | date_to_xmlschema }}{{ page.url | absolute_url | xml_escape }}{% assign title = site.title | default: site.name %}{% if page.collection != \"posts\" %}{% assign collection = page.collection | capitalize %}{% assign title = title | append: \" | \" | append: collection %}{% endif %}{% if page.category %}{% assign category = page.category | capitalize %}{% assign title = title | append: \" | \" | append: category %}{% endif %}{% if title %}{{ title | smartify | xml_escape }}{% endif %}{% if site.description %}{{ site.description | xml_escape }}{% endif %}{% if site.author %}{{ site.author.name | default: site.author | xml_escape }}{% if site.author.email %}{{ site.author.email | xml_escape }}{% endif %}{% if site.author.uri %}{{ site.author.uri | xml_escape }}{% endif %}{% endif %}{% if page.tags %}{% assign posts = site.tags[page.tags] %}{% else %}{% assign posts = site[page.collection] %}{% endif %}{% if page.category %}{% assign posts = posts | where: \"categories\", page.category %}{% endif %}{% unless site.show_drafts %}{% assign posts = posts | where_exp: \"post\", \"post.draft != true\" %}{% endunless %}{% assign posts = posts | sort: \"date\" | reverse %}{% assign posts_limit = site.feed.posts_limit | default: 10 %}{% for post in posts limit: posts_limit %}{% assign post_title = post.title | smartify | strip_html | normalize_whitespace | xml_escape %}{{ post_title }}{{ post.date | date_to_xmlschema }}{{ post.last_modified_at | default: post.date | date_to_xmlschema }}{{ post.id | absolute_url | xml_escape }}{% assign excerpt_only = post.feed.excerpt_only | default: site.feed.excerpt_only %}{% unless excerpt_only %}{% endunless %}{% assign post_author = post.author | default: post.authors[0] | default: site.author %}{% assign post_author = site.data.authors[post_author] | default: post_author %}{% assign post_author_email = post_author.email | default: nil %}{% assign post_author_uri = post_author.uri | default: nil %}{% assign post_author_name = post_author.name | default: post_author %}{{ post_author_name | default: \"\" | xml_escape }}{% if post_author_email %}{{ post_author_email | xml_escape }}{% endif %}{% if post_author_uri %}{{ post_author_uri | xml_escape }}{% endif %}{% if post.category %}{% elsif post.categories %}{% for category in post.categories %}{% endfor %}{% endif %}{% for tag in post.tags %}{% endfor %}{% assign post_summary = post.description | default: post.excerpt %}{% if post_summary and post_summary != empty %}{% endif %}{% assign post_image = post.image.path | default: post.image %}{% if post_image %}{% unless post_image contains \"://\" %}{% assign post_image = post_image | absolute_url %}{% endunless %}{% endif %}{% endfor %}","url": "http://localhost:4000/feed.xml"
  }]
